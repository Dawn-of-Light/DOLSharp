using log4net;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Numerics;
using System.Reflection;

namespace DOL.GS.Geometry
{
	/// <summary>
	/// Very basic Wavefront Obj file parser, parse only v, f and g (badly) entries
	/// with specific code to load obj file generated by Uthgard navgen tool
	/// </summary>
	public static class WavefrontObjFile
	{
		private static readonly ILog log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

		public static (Vector3[], List<List<(int, int, int)>>) Load(Zone zone, string filename)
		{
			if (!File.Exists(filename))
				return (null, null);
			var offset = new Vector3(zone.XOffset, zone.YOffset, 0);
			var vertices = new List<Vector3>();
			var objects = new List<List<(int, int, int)>>();
			using (var reader = new StreamReader(filename))
			{
				string line;

				var faces = new List<(int, int, int)>();
				while ((line = reader.ReadLine()) != null)
				{
					if (string.IsNullOrWhiteSpace(line))
						continue;

					try
					{
						var args = line.Split(' ');
						switch (args[0])
						{
							// we ignore g entries, it's not very useful here
							case "v":
								// ATTENTION: the Y and Z are inverted so we load the model with DAOC coordinates (Z up instead of Y)
								var v = new Vector3(float.Parse(args[1], CultureInfo.InvariantCulture), float.Parse(args[3], CultureInfo.InvariantCulture), float.Parse(args[2], CultureInfo.InvariantCulture));
								v *= 32;
								vertices.Add(v);
								break;
							case "f":
								faces.Add((int.Parse(args[1]) - 1, int.Parse(args[2]) - 1, int.Parse(args[3]) - 1));
								break;
							case "g":
								if (vertices.Count > 0 && faces.Count > 0)
								{
									objects.Add(faces);
									faces = new List<(int, int, int)>();
								}
								break;
						}
					}
					catch (Exception e)
					{
						log.Debug($"Error when parsing obj file {filename}", e);
					}
				}
				if (vertices.Count > 0 && faces.Count > 0)
					objects.Add(faces);
			}
			return (vertices.ToArray(), objects);
		}
	}
}
