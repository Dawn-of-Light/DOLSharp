<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NHibernate</name>
    </assembly>
    <members>
        <member name="T:NHibernate.Cache.CachedItem">
            <summary>
            An item of cached data, timestamped with the time it was cached, when it was locked,
            when it was unlocked
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ILockable">
            <summary>
            Summary description for ILockable.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ILockable.Lock(System.Int64,System.Int32)">
            <summary>
            
            </summary>
            <param name="timeout"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ILockable.IsGettable(System.Int64)">
            <summary>
            
            </summary>
            <param name="txTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ILockable.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            
            </summary>
            <param name="txTimestamp"></param>
            <param name="newVersion"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cache.ILockable.IsLock">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.Lock(System.Int64,System.Int32)">
            <summary>
            Lock the item
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.IsGettable(System.Int64)">
            <summary>
            Is this item visible to the timestamped transaction?
            </summary>
            <param name="txTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.CachedItem.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Don't overwite already cached items
            </summary>
            <param name="txTimestamp"></param>
            <param name="newVersion"></param>
            <param name="comparator"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.FreshTimestamp">
            <summary>
            The timestamp on the cached data
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.Value">
            <summary>
            The actual cached data
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CachedItem.IsLock">
            <summary>
            Not a lock!
            </summary>
        </member>
        <member name="T:NHibernate.Cache.CacheException">
            <summary>
            Represents any exception from an <see cref="T:NHibernate.Cache.ICache"/>.
            </summary>
        </member>
        <member name="T:NHibernate.HibernateException">
            <summary>
            Any exception that occurs in the O-R persistence layer.
            </summary>
            <remarks>
            Exceptions that occur in the database layer are left as native exceptions.
            </remarks>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.HibernateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.HibernateException"/> class 
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Cache.CacheException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Cache.CacheException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Cache.CacheFactory">
            <summary>
            Factory class for creating an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/>.
            </summary>
        </member>
        <member name="F:NHibernate.Cache.CacheFactory.ReadOnly">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Cache.CacheFactory.ReadWrite">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Cache.CacheFactory.NonstrictReadWrite">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Cache.CacheFactory.Transactional">
            <summary></summary>
            <remarks>
            No providers implement transactional caching currently,
            it was ported from Hibernate just for the sake of completeness.
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.CacheFactory.CreateCache(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Creates an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> from the parameters.
            </summary>
            <param name="node">The <see cref="T:System.Xml.XmlNode"/> that contains the attribute <c>usage</c>.</param>
            <param name="name">The name of the class the strategy is being created for.</param>
            <param name="mutable"><c>true</c> if the object being stored in the cache is mutable.</param>
            <returns>An <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> to use for this object in the <see cref="T:NHibernate.Cache.ICache"/>.</returns>
        </member>
        <member name="M:NHibernate.Cache.CacheFactory.CreateCache(System.String,System.String,System.Boolean)">
            <summary>
            Creates an <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> from the parameters.
            </summary>
            <param name="usage">The name of the strategy that <see cref="T:NHibernate.Cache.ICacheProvider"/> should use for the class.</param>
            <param name="name">The name of the class the strategy is being created for.</param>
            <param name="mutable"><c>true</c> if the object being stored in the cache is mutable.</param>
            <returns>An <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> to use for this object in the <see cref="T:NHibernate.Cache.ICache"/>.</returns>
        </member>
        <member name="T:NHibernate.Cache.CacheLock">
            <summary>
            A soft lock which supports concurrent locking,
            timestamped with the time it was released
            </summary>
            <remarks>
            This class was named Lock in H2.1
            </remarks>
        </member>
        <member name="T:NHibernate.Cache.ISoftLock">
            <summary>
            Marker interface, denoting a client-visible "soft lock" on a cached item.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.Lock(System.Int64,System.Int32)">
            <summary>
            Increment the lock, setting the
            new lock timeout
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.Unlock(System.Int64)">
            <summary>
            Decrement the lock, setting the unlock
            timestamp if now unlocked
            </summary>
            <param name="currentTimestamp"></param>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.IsPuttable(System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Can the timestamped transaction re-cache this
            locked item now?
            </summary>
        </member>
        <member name="M:NHibernate.Cache.CacheLock.IsGettable(System.Int64)">
            <summary>
            locks are not returned to the client!
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CacheLock.WasLockedConcurrently">
            <summary>
            Was this lock held concurrently by multiple
            transactions?
            </summary>
        </member>
        <member name="P:NHibernate.Cache.CacheLock.IsLock">
            <summary>
            Yes, this is a lock
            </summary>
        </member>
        <member name="T:NHibernate.Cache.HashtableCache">
            <summary>
            A simple <c>Hashtable</c> based cache
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ICache">
            <summary>
            Implementors define a caching algorithm.
            </summary>
            <remarks>
            All implementations MUST be threadsafe.
            
            <para>
            The key is the <c>id</c> of the object that is being cached and the 
            value is a <see cref="T:NHibernate.Cache.CachedItem"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ICache.Get(System.Object)">
            <summary>
            Get the object from the Cache
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICache.Put(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Cache.ICache.Remove(System.Object)">
            <summary>
            Remove an item from the Cache.
            </summary>
            <param name="key">The Key of the Item in the Cache to remove.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Clear">
            <summary>
            Clear the Cache
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Destroy">
            <summary>
            Clean up.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Lock(System.Object)">
            <summary>
            If this is a clustered cache, lock the item
            </summary>
            <param name="key">The Key of the Item in the Cache to lock.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.Unlock(System.Object)">
            <summary>
            If this is a clustered cache, unlock the item
            </summary>
            <param name="key">The Key of the Item in the Cache to unlock.</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICache.NextTimestamp">
            <summary>
            Generate a timestamp
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cache.ICache.Timeout">
            <summary>
            Get a reasonable "lock timeout"
            </summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Get(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Put(System.Object,System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Remove(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Destroy">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Lock(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.Unlock(System.Object)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCache.NextTimestamp">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cache.HashtableCache.Timeout">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Cache.HashtableCacheProvider">
            <summary>
            Cache Provider plugin for NHibernate that is configured by using
            <c>hibernate.cache.provider_class="NHibernate.Cache.HashtableCacheProvider"</c>
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ICacheProvider">
            <summary>
            Support for pluggable caches
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.BuildCache(System.String,System.Collections.IDictionary)">
            <summary>
            Configure the cache
            </summary>
            <param name="regionName">the name of the cache region</param>
            <param name="properties">configuration settings</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.NextTimestamp">
            <summary>
            generate a timestamp
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.Start(System.Collections.IDictionary)">
            <summary>
            Callback to perform any necessary initialization of the underlying cache implementation
            during ISessionFactory construction.
            </summary>
            <param name="properties">current configuration settings</param>
        </member>
        <member name="M:NHibernate.Cache.ICacheProvider.Stop">
            <summary>
            Callback to perform any necessary cleanup of the underlying cache implementation
            during <see cref="M:NHibernate.ISessionFactory.Close"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.HashtableCacheProvider.BuildCache(System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="regionName"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.HashtableCacheProvider.NextTimestamp">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.HashtableCacheProvider.Start(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="properties"></param>
        </member>
        <member name="M:NHibernate.Cache.HashtableCacheProvider.Stop">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Cache.ICacheConcurrencyStrategy">
            <summary>
            Implementors manage transactional access to cached data.
            </summary>
            <remarks>
            <para>
            Transactions pass in a timestamp indicating transaction start time.
            </para>
            <para>
            When used to Cache Entities and Collections the <c>key</c> is the <c>id</c> of the
            Entity/Collection and the <c>value</c> should be set to the <see cref="T:NHibernate.Impl.CacheEntry"/> 
            for an Entity and the results of <see cref="T:NHibernate.Collection.PersistentCollection"/>.Disassemble for a Collection.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Get(System.Object,System.Int64)">
            <summary>
            Attempt to retrieve an object from the Cache
            </summary>
            <param name="key">The key (id) of the object to get out of the Cache.</param>
            <param name="txTimestamp">A timestamp prior to the transaction start time</param>
            <returns>The cached object or <c>null</c></returns>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Put(System.Object,System.Object,System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Attempt to cache an object, after loading from the database
            </summary>
            <param name="key">The key (id) of the object to put in the Cache.</param>
            <param name="value">The value</param>
            <param name="txTimestamp">A timestamp prior to the transaction start time</param>
            <param name="version">the version number of the object we are putting</param>
            <param name="versionComparer">a Comparer to be used to compare version numbers</param>
            <returns><c>true</c> if the object was successfully cached</returns>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Lock(System.Object,System.Object)">
            <summary>
            We are going to attempt to update/delete the keyed object
            </summary>
            <param name="key">The key</param>
            <param name="version"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Evict(System.Object)">
            <summary>
            Called after an item has become stale (before the transaction completes).
            </summary>
            <param name="key"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Update(System.Object,System.Object)">
            <summary>
            Called after an item has been updated (before the transaction completes),
            instead of calling Evict().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Insert(System.Object,System.Object)">
            <summary>
            Called after an item has been inserted (before the transaction completes), instead of calling Evict().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <remarks>This method is used by "synchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Release(System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Called when we have finished the attempted update/delete (which may or
            may not have been successful), after transaction completion.
            </summary>
            <param name="key">The key</param>
            <param name="lock">The soft lock</param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.AfterUpdate(System.Object,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Called after an item has been updated (after the transaction completes),
            instead of calling Release().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <param name="lock"></param>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.AfterInsert(System.Object,System.Object,System.Object)">
            <summary>
            Called after an item has been inserted (after the transaction completes), instead of calling release().
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <remarks>This method is used by "asynchronous" concurrency strategies.</remarks>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Remove(System.Object)">
            <summary>
            Evict an item from the cache immediately (without regard for transaction isolation).
            </summary>
            <param name="key"></param>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Clear">
            <summary>
            Evict all items from the cache immediately.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="M:NHibernate.Cache.ICacheConcurrencyStrategy.Destroy">
            <summary>
            Clean up all resources.
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="P:NHibernate.Cache.ICacheConcurrencyStrategy.Cache">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Cache.ICache"/> for this strategy to use.
            </summary>
            <value>The <see cref="T:NHibernate.Cache.ICache"/> for this strategy to use.</value>
        </member>
        <member name="P:NHibernate.Cache.ICacheConcurrencyStrategy.MinimalPuts">
            <summary>
            Enable "minimal puts" mode for this cache
            </summary>
            <exception cref="T:NHibernate.Cache.CacheException"></exception>
        </member>
        <member name="T:NHibernate.Cache.IQueryCache">
            <summary>
            Defines the contract for caches capable of storing query results.  These
            caches should only concern themselves with storing the matching result ids.
            The transactional semantics are necessarily less strict than the semantics
            of an item cache.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.IQueryCacheFactory">
            <summary>
            Defines a factory for query cache instances.  These factories are responsible for
            creating individual QueryCache instances.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.IQueryCacheFactory.GetQueryCache(System.String,NHibernate.Cache.ICacheProvider,NHibernate.Cache.UpdateTimestampsCache,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="regionName"></param>
            <param name="provider"></param>
            <param name="updateTimestampsCache"></param>
            <param name="props"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cache.NonstrictReadWriteCache">
            <summary>
            Caches data that is sometimes updated without ever locking the cache. 
            If concurrent access to an item is possible, this concurrency strategy 
            makes no guarantee that the item returned from the cache is the latest 
            version available in the database. Configure your cache timeout accordingly! 
            This is an "asynchronous" concurrency strategy.
            <seealso cref="T:NHibernate.Cache.ReadWriteCache"/> for a much stricter algorithm
            </summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Get(System.Object,System.Int64)">
            <summary>
            Get the most recent version, if available.
            </summary>
            <param name="key"></param>
            <param name="txTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Put(System.Object,System.Object,System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Add an item to the cache
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="txTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Lock(System.Object,System.Object)">
            <summary>
            Do nothing
            </summary>
            <param name="key"></param>
            <param name="version"></param>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Destroy">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Evict(System.Object)">
            <summary>
            Invalidate the item
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Update(System.Object,System.Object)">
            <summary>
            Invalidate the item
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Insert(System.Object,System.Object)">
            <summary>
            Do nothing
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.Release(System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Invalidate the item (again, for safety).
            </summary>
            <param name="key"></param>
            <param name="lock"></param>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.AfterUpdate(System.Object,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Invalidate the item (again, for safety).
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <param name="lock"></param>
        </member>
        <member name="M:NHibernate.Cache.NonstrictReadWriteCache.AfterInsert(System.Object,System.Object,System.Object)">
            <summary>
            Do nothing
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
        </member>
        <member name="P:NHibernate.Cache.NonstrictReadWriteCache.Cache">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Cache.ReadOnlyCache">
            <summary>
            Caches data that is never updated
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Get(System.Object,System.Int64)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Lock(System.Object,System.Object)">
            <summary>
            Unsupported!
            </summary>
            <param name="key"></param>
            <param name="version"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Put(System.Object,System.Object,System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="timestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Release(System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Unsupported!
            </summary>
            <param name="key"></param>
            <param name="lock"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.AfterUpdate(System.Object,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Unsupported!
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <param name="lock"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.AfterInsert(System.Object,System.Object,System.Object)">
            <summary>
            Do nothing.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Evict(System.Object)">
            <summary>
            Do nothing.
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Insert(System.Object,System.Object)">
            <summary>
            Do nothing.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadOnlyCache.Update(System.Object,System.Object)">
            <summary>
            Unsupported!
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="T:NHibernate.Cache.ReadWriteCache">
            <summary>
            Caches data that is sometimes updated while maintaining the semantics of
            "read committed" isolation level. If the database is set to "repeatable
            read", this concurrency strategy <em>almost</em> maintains the semantics.
            Repeatable read isolation is compromised in the case of concurrent writes.
            This is an "asynchronous" concurrency strategy.
            </summary>
            <remarks>
            If this strategy is used in a cluster, the underlying cache implementation
            must support distributed hard locks (which are held only momentarily). This
            strategy also assumes that the underlying cache implementation does not do
            asynchronous replication and that state has been fully replicated as soon
            as the lock is released.
            <seealso cref="T:NHibernate.Cache.NonstrictReadWriteCache"/> for a faster algorithm
            <seealso cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.NextLockId">
            <summary>
            Generate an id for a new lock. Uniqueness per cache instance is very
            desirable but not absolutely critical. Must be called from one of the
            synchronized methods of this class.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Get(System.Object,System.Int64)">
            <summary>
            Do not return an item whose timestamp is later than the current
            transaction timestamp. (Otherwise we might compromise repeatable
            read unnecessarily.) Do not return an item which is soft-locked.
            Always go straight to the database instead.
            </summary>
            <remarks>
            Note that since reading an item from that cache does not actually
            go to the database, it is possible to see a kind of phantom read
            due to the underlying row being updated after we have read it
            from the cache. This would not be possible in a lock-based
            implementation of repeatable read isolation. It is also possible
            to overwrite changes made and committed by another transaction
            after the current transaction read the item from the cache. This
            problem would be caught by the update-time version-checking, if 
            the data is versioned or timestamped.
            </remarks>
            <param name="key"></param>
            <param name="txTimestamp"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Lock(System.Object,System.Object)">
            <summary>
            Stop any other transactions reading or writing this item to/from
            the cache. Send them straight to the database instead. (The lock
            does time out eventually.) This implementation tracks concurrent
            locks by transactions which simultaneously attempt to write to an
            item.
            </summary>
            <param name="key"></param>
            <param name="version"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Put(System.Object,System.Object,System.Int64,System.Object,System.Collections.IComparer)">
            <summary>
            Do not add an item to the cache unless the current transaction
            timestamp is later than the timestamp at which the item was
            invalidated. (Otherwise, a stale item might be re-added if the
            database is operating in repeatable read isolation mode.)
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="txTimestamp"></param>
            <returns>Whether the item was actually put into the cache</returns>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.DecrementLock(System.Object,NHibernate.Cache.CacheLock)">
            <summary>
            decrement a lock and put it back in the cache
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Release(System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="clientLock"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Remove(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Destroy">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.AfterUpdate(System.Object,System.Object,System.Object,NHibernate.Cache.ISoftLock)">
            <summary>
            Re-cache the updated state, if and only if there there are
            no other concurrent soft locks. Release our lock.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
            <param name="clientLock"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.AfterInsert(System.Object,System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="version"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Evict(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Insert(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.Update(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Cache.ReadWriteCache.IsUnlockable(NHibernate.Cache.ISoftLock,NHibernate.Cache.ILockable)">
            <summary>
            Is the client's lock commensurate with the item in the cache?
            If it is not, we know that the cache expired the original
            lock.
            </summary>
        </member>
        <member name="P:NHibernate.Cache.ReadWriteCache.Cache">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Cache.StandardQueryCache">
            <summary>
            The standard implementation of the Hibernate <see cref="T:NHibernate.Cache.IQueryCache"/>
            interface.  This implementation is very good at recognizing stale query
            results and re-running queries when it detects this condition, recaching
            the new results.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.StandardQueryCacheFactory">
            <summary>
            Standard Hibernate implementation of the IQueryCacheFactory interface.  Returns
            instances of <see cref="T:NHibernate.Cache.StandardQueryCache"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Cache.Timestamper">
            <summary>
            Generates increasing identifiers (in a single application domain only).
            </summary>
            <remarks>
            Not valid across multiple application domains. Identifiers are not necessarily
            strictly increasing, but usually are.
            </remarks>
        </member>
        <member name="F:NHibernate.Cache.Timestamper.OneMs">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Cache.Timestamper.Next">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cache.UpdateTimestampsCache">
            <summary>
            Tracks the timestamps of the most recent updates to particular tables. It is
            important that the cache timeout of the underlying cache implementation be set
            to a higher value than the timeouts of any of the query caches. In fact, we 
            recommend that the the underlying cache not be configured for expiry at all.
            Note, in particular, that an LRU cache expiry policy is never appropriate.
            </summary>
        </member>
        <member name="M:NHibernate.Cache.UpdateTimestampsCache.Invalidate(System.Object[])">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Cfg.AssemblyHbmOrderer">
            <summary>
            Analyzes the contents of the <c>hbm.xml</c> files embedded in the 
            <see cref="T:System.Reflection.Assembly"/> for their dependency order.
            </summary>
            <remarks>
            This solves the problem caused when you have embedded <c>hbm.xml</c> files
            that contain subclasses/joined-subclasses that make use of the <c>extends</c>
            attribute.  This ensures that those subclasses/joined-subclasses will not be
            processed until after the class they extend is processed.
            </remarks>
        </member>
        <member name="F:NHibernate.Cfg.AssemblyHbmOrderer._classes">
            <summary>
            An unordered <see cref="T:System.Collections.IList"/> of all the mapped classes contained
            in the assembly.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.AssemblyHbmOrderer._hbmResources">
            <summary>
            An <see cref="T:System.Collections.IList"/> of all the <c>hbm.xml</c> resources found
            in the assembly.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.AssemblyHbmOrderer.#ctor(System.Reflection.Assembly)">
            <summary>
            Creates a new instance of <see cref="T:NHibernate.Cfg.AssemblyHbmOrderer"/>
            </summary>
            <param name="assembly">The <see cref="T:System.Reflection.Assembly"/> to order the <c>hbm.xml</c> files in.</param>
        </member>
        <member name="M:NHibernate.Cfg.AssemblyHbmOrderer.GetHbmFiles">
            <summary>
            Gets an <see cref="T:System.Collections.IList"/> of <c>hbm.xml</c> resources in the correct order.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IList"/> of <c>hbm.xml</c> resources in the correct order.
            </returns>
        </member>
        <member name="M:NHibernate.Cfg.AssemblyHbmOrderer.OrderedHbmFiles(System.Collections.IList)">
            <summary>
            Returns an <see cref="T:System.Collections.IList"/> of <c>hbm.xml</c> files in the order that ensures
            base classes are loaded before their subclass/joined-subclass.
            </summary>
            <param name="unorderedClasses">An <see cref="T:System.Collections.IList"/> of <see cref="T:NHibernate.Cfg.AssemblyHbmOrderer.ClassEntry"/> objects.</param>
            <returns>
            An <see cref="T:System.Collections.IList"/> of <see cref="T:System.String"/> objects that contain the <c>hbm.xml</c> file names.
            </returns>
        </member>
        <member name="T:NHibernate.Cfg.AssemblyHbmOrderer.ClassEntry">
            <summary>
            Holds information about mapped classes found in the <c>hbm.xml</c> files.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.AssemblyHbmOrderer.ClassEntry.BaseClassName">
            <summary>
            Gets the name of the Class that this Class inherits from, or <c>null</c>
            if this does not inherit from any mapped Class.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.AssemblyHbmOrderer.ClassEntry.ClassName">
            <summary>
            Gets the name of this Class.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.AssemblyHbmOrderer.ClassEntry.FileName">
            <summary>
            Gets the name of the <c>hbm.xml</c> file this class was found in.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Binder.FullClassName(System.String,NHibernate.Cfg.Mappings)">
            <summary>
            Converts a partial class name into a fully qualified one
            </summary>
            <param name="className"></param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Binder.ClassForFullNameChecked(System.String,System.String)">
            <summary>
            Attempts to find a type by its full name. Throws a MappingException using
            the provided <c>errorMessage</c> in case of failure.
            </summary>
            <param name="fullName">name of the class to find</param>
            <param name="errorMessage">Error message to use for
            the <see cref="T:NHibernate.MappingException"/> in case of failure. Should contain
            the <c>{0}</c> formatting placeholder.</param>
            <returns></returns>
            <exception cref="T:NHibernate.MappingException">
            Thrown when there is an error loading the class.
            </exception>
        </member>
        <member name="M:NHibernate.Cfg.Binder.ClassForNameChecked(System.String,NHibernate.Cfg.Mappings,System.String)">
            <summary>
            Similar to <see cref="M:NHibernate.Cfg.Binder.ClassForFullNameChecked(System.String,System.String)"/>, but handles short class names
            by calling <see cref="M:NHibernate.Cfg.Binder.FullClassName(System.String,NHibernate.Cfg.Mappings)"/>.
            </summary>
            <param name="name"></param>
            <param name="mappings"></param>
            <param name="errorMessage"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Binder.BindProperty(System.Xml.XmlNode,NHibernate.Mapping.Property,NHibernate.Cfg.Mappings)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="model"></param>
            <param name="mappings"></param>
        </member>
        <member name="M:NHibernate.Cfg.Binder.BindCollection(System.Xml.XmlNode,NHibernate.Mapping.Collection,System.String,System.String,NHibernate.Cfg.Mappings)">
            <remarks>
            Called for all collections
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Binder.BindArray(System.Xml.XmlNode,NHibernate.Mapping.Array,System.String,System.String,NHibernate.Cfg.Mappings)">
            <remarks>
            Called for arrays and primitive arrays
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Binder.BindListSecondPass(System.Xml.XmlNode,NHibernate.Mapping.List,System.Collections.IDictionary,NHibernate.Cfg.Mappings)">
            <remarks>
            Called for Lists, arrays, primitive arrays
            </remarks>>
        </member>
        <member name="M:NHibernate.Cfg.Binder.BindMapSecondPass(System.Xml.XmlNode,NHibernate.Mapping.Map,System.Collections.IDictionary,NHibernate.Cfg.Mappings)">
            <summary>
            Called for Maps
            </summary>
            <param name="node"></param>
            <param name="model"></param>
            <param name="classes"></param>
            <param name="mappings"></param>
        </member>
        <member name="M:NHibernate.Cfg.Binder.BindCollectionSecondPass(System.Xml.XmlNode,NHibernate.Mapping.Collection,System.Collections.IDictionary,NHibernate.Cfg.Mappings)">
            <remarks>
            Called for all collections
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.Configuration">
            <summary>
            An instance of <c>Configuration</c> allows the application to specify properties
            and mapping documents to be used when creating a <c>ISessionFactory</c>.
            </summary>
            <remarks>
            Usually an application will create a single <c>Configuration</c>, build a single instance
            of <c>ISessionFactory</c>, and then instanciate <c>ISession</c>s in threads servicing
            client requests.
            <para>
            The <c>Configuration</c> is meant only as an initialization-time object. <c>ISessionFactory</c>s
            are immutable and do not retain any association back to the <c>Configuration</c>
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.Cfg.Configuration.MappingSchemaXMLNS">
            <summary>
            The XML Namespace for the nhibernate-mapping
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.Configuration.CfgSchemaXMLNS">
            <summary>
            The XML Namespace for the nhibernate-configuration
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Reset">
            <summary>
            Clear the internal state of the <see cref="T:NHibernate.Cfg.Configuration"/> object.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.#ctor">
            <summary>
            Create a new Configuration object.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetClassMapping(System.Type)">
            <summary>
            Get the mapping for a particular class
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetCollectionMapping(System.String)">
            <summary>
            Get the mapping for a particular collection role
            </summary>
            <param name="role">a collection role</param>
            <returns><see cref="T:NHibernate.Mapping.Collection"/></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddFile(System.String)">
            <summary>
            Read mappings from a particular XML file. This method is equivalent
            to <see cref="M:NHibernate.Cfg.Configuration.AddXmlFile(System.String)"/>.
            </summary>
            <param name="xmlFile"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlFile(System.String)">
            <summary>
            Read mappings from a particular XML file.
            </summary>
            <param name="xmlFile">a path to a file</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXml(System.String)">
            <summary>
            Read mappings from a <c>string</c>. This method is equivalent to
            <see cref="M:NHibernate.Cfg.Configuration.AddXmlString(System.String)"/>.
            </summary>
            <param name="xml">an XML string</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlString(System.String)">
            <summary>
            Read mappings from a <c>string</c>
            </summary>
            <param name="xml">an XML string</param>
            <returns>This configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddDocument(System.Xml.XmlDocument)">
            <summary>
            Read mappings from an <c>XmlDocument</c>.
            </summary>
            <param name="doc">A loaded XmlDocument that contains the Mappings.</param>
            <returns>This Configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddValidatedDocument(System.Xml.XmlDocument)">
            <summary>
            Takes the validated XmlDocument and has the Binder do its work of
            creating Mapping objects from the Mapping Xml.
            </summary>
            <param name="doc">The <b>validated</b> XmlDocument that contains the Mappings.</param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.CreateMappings">
            <summary>
            Create a new <c>Mappings</c> to add classes and collection
            mappings to.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddInputStream(System.IO.Stream)">
            <summary>
            Read mappings from a <c>Stream</c>.
            </summary>
            <param name="xmlInputStream">The stream containing XML</param>
            <returns>This Configuration object.</returns>
            <remarks>
            The <see cref="T:System.IO.Stream"/> passed in through the parameter <c>xmlInputStream</c>
            is not <b>guaranteed</b> to be cleaned up by this method.  It is the callers responsiblity to
            ensure that the <c>xmlInputStream</c> is properly handled when this method
            completes.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddResource(System.String,System.Reflection.Assembly)">
            <summary>
            Adds the Mappings in the Resource of the Assembly.
            </summary>
            <param name="path">The path to the Resource file in the Assembly</param>
            <param name="assembly">The Assembly that contains the Resource file.</param>
            <returns>This Configuration object.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddClass(System.Type)">
            <summary>
            Read a mapping from an application resource, using a convention.
            The class <c>Foo.Bar.Foo</c> is mapped by the resource named
            <c>Foo.Bar.Foo.hbm.xml</c>, embedded in the class' assembly.
            </summary>
            <param name="persistentClass">The type to map.</param>
            <returns>This configuration object.</returns>
            <remarks>
            If the mappings and classes are defined in different assemblies
            or don't follow the naming convention, then this method cannot
            be used.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.String)">
            <summary>
            Adds all of the Assembly's Resource files that end with "<c>hbm.xml</c>"
            </summary>
            <param name="assemblyName">The name of the Assembly to load.</param>
            <returns>This Configuration object.</returns>
            <remarks>
            The Assembly must be in the local bin, probing path, or GAC so that the
            Assembly can be loaded by name.  If these conditions are not satisfied
            then your code should load the Assembly and call the override 
            <see cref="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly)"/> instead.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly)">
            <summary>
            Adds all of the Assembly's Resource files that end with "hbm.xml" 
            </summary>
            <param name="assembly">The loaded Assembly.</param>
            <returns>This Configuration object.</returns>
            <remarks>
            This assumes that the <c>hbm.xml</c> files in the Assembly need to be put
            in the correct order by NHibernate.  See <see cref="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly,System.Boolean)">
            AddAssembly(Assembly assembly, bool skipOrdering)</see>
            for the impacts and reasons for letting NHibernate order the 
            <c>hbm.xml</c> files.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddAssembly(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Adds all of the Assembly's Resource files that end with "hbm.xml" 
            </summary>
            <param name="assembly">The loaded Assembly.</param>
            <param name="skipOrdering">
            A <see cref="T:System.Boolean"/> indicating if the ordering of hbm.xml files can be skipped.
            </param>
            <returns>This Configuration object.</returns>
            <remarks>
            <p>
            The order of <c>hbm.xml</c> files only matters if the attribute "extends" is used.
            The ordering should only be done when needed because it takes extra time 
            to read the Xml files to find out the order the files should be passed to the Binder.  
            If you don't use the "extends" attribute then it is reccommended to call this 
            with <c>skipOrdering=true</c>.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddDirectory(System.IO.DirectoryInfo)">
            <summary>
            Read all mapping documents from a directory tree. Assume that any
            file named <c>*.hbm.xml</c> is a mapping document.
            </summary>
            <param name="dir">a directory</param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GenerateDropSchemaScript(NHibernate.Dialect.Dialect)">
            <summary>
            Generate DDL for droping tables
            </summary>
            <remarks>
            <seealso cref="T:NHibernate.Tool.hbm2ddl.SchemaExport"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GenerateSchemaCreationScript(NHibernate.Dialect.Dialect)">
            <summary>
            Generate DDL for creating tables
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SecondPassCompile">
            <remarks>
            This method may be called many times!!
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.BuildSessionFactory">
            <summary>
            Instantitate a new <c>ISessionFactory</c>, using the properties and mappings in this
            configuration. The <c>ISessionFactory</c> will be immutable, so changes made to the
            <c>Configuration</c> after building the <c>ISessionFactory</c> will not affect it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetInterceptor(NHibernate.IInterceptor)">
            <summary>
            Configure an <see cref="T:NHibernate.IInterceptor"/>
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetProperties(System.Collections.IDictionary)">
            <summary>
            Specify a completely new set of properties
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddProperties(System.Collections.IDictionary)">
            <summary>
            Adds an <see cref="T:System.Collections.IDictionary"/> of configuration properties.  The 
            Key is the name of the Property and the Value is the <see cref="T:System.String"/>
            value of the Property.
            </summary>
            <param name="properties">An <see cref="T:System.Collections.IDictionary"/> of configuration properties.</param>
            <returns>
            This <see cref="T:NHibernate.Cfg.Configuration"/> object.
            </returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetProperty(System.String,System.String)">
            <summary>
            Sets the value of the configuration property.
            </summary>
            <param name="name">The name of the property.</param>
            <param name="value">The value of the property.</param>
            <returns>
            This <see cref="T:NHibernate.Cfg.Configuration"/> object.
            </returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.GetProperty(System.String)">
            <summary>
            Gets the value of the configuration property.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>The configured value of the property, or <c>null</c> if the property was not specified.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure">
            <summary>
            Configure NHibernate using the <c>&lt;hibernate-configuration&gt;</c> section
            from the application config file, if found, or the file <c>hibernate.cfg.xml</c>
            otherwise.
            </summary>
            <returns>A Configuration object initialized with the file.</returns>
            <remarks>
            To configure NHibernate explicitly using <c>hibernate.cfg.xml</c>, ignoring
            the application configuration file, use this code:
            <code>
            	configuration.Configure( "path/to/hibernate.cfg.xml" );
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.Xml.XmlNode)">
            <summary>
            Configure NHibernate from an <see cref="T:System.Xml.XmlNode"/> representing the root
            <c>&lt;hibernate-configuration&gt;</c> element.
            </summary>
            <param name="node">Configuration node</param>
            <returns>This Configuration object</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.String)">
            <summary>
            Configure NHibernate using the file specified.
            </summary>
            <param name="resource">The location of the Xml file to use to configure NHibernate.</param>
            <returns>A Configuration object initialized with the file.</returns>
            <remarks>
            Calling Configure(string) will overwrite the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.Reflection.Assembly,System.String)">
            <summary>
            Configure NHibernate using a resource contained in an Assembly.
            </summary>
            <param name="assembly">The <see cref="T:System.Reflection.Assembly"/> that contains the resource.</param>
            <param name="resourceName">The name of the manifest resource being requested.</param>
            <returns>A Configuration object initialized from the manifest resource.</returns>
            <remarks>
            Calling Configure(Assembly, string) will overwrite the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.Configure(System.Xml.XmlTextReader)">
            <summary>
            Configure NHibernate using the specified XmlTextReader.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlTextReader"/> that contains the Xml to configure NHibernate.</param>
            <returns>A Configuration object initialized with the file.</returns>
            <remarks>
            Calling Configure(XmlTextReader) will overwrite the values set in app.config or web.config
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetCacheConcurrencyStrategy(System.Type,NHibernate.Cache.ICacheConcurrencyStrategy)">
            <summary>
            Set up a cache for an entity class
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetCacheConcurrencyStrategy(System.String,NHibernate.Cache.ICacheConcurrencyStrategy)">
            <summary>
            Set up a cache for a collection role
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.BuildSettings">
            <summary>
            Create an object-oriented view of the configuration properties
            </summary>
            <returns>A <see cref="T:NHibernate.Cfg.Settings"/> object initialized from the settings properties.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.SetNamingStrategy(NHibernate.Cfg.INamingStrategy)">
            <summary>
            Set a custom naming strategy
            </summary>
            <param name="namingStrategy">the NamingStrategy to set</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.LoadMappingDocument(System.Xml.XmlTextReader)">
            <summary>
            Load and validate the mappings in the <see cref="T:System.Xml.XmlTextReader"/> against
            the nhibernate-mapping-2.0 schema, without adding them to the configuration.
            </summary>
            <remarks>
            This method is made public to be usable from the unit tests. It is not intended
            to be called by end users.
            </remarks>
            <param name="hbmReader">The XmlReader that contains the mapping.</param>
            <returns>Validated XmlDocument built from the XmlReader.</returns>
        </member>
        <member name="M:NHibernate.Cfg.Configuration.AddXmlReader(System.Xml.XmlTextReader)">
            <summary>
            Adds the Mappings in the <see cref="T:System.Xml.XmlTextReader"/> after validating it
            against the nhibernate-mapping-2.0 schema.
            </summary>
            <param name="hbmReader">The XmlTextReader that contains the mapping.</param>
            <returns>This Configuration object.</returns>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.MappingSchemaCollection">
            <summary></summary>
            <remarks>Allocate on first use as we are expensive in time/space</remarks>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.CfgSchemaCollection">
            <summary></summary>
            <remarks>Allocate on first use as we are expensive in time/space</remarks>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.ClassMappings">
            <summary>
            The class mappings 
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.CollectionMappings">
            <summary>
            The collection mappings
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.TableMappings">
            <summary>
            The table mappings
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamedQueries">
            <summary>
            The named queries
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Interceptor">
            <summary>
            Gets or sets the <see cref="T:NHibernate.IInterceptor"/> to use.
            </summary>
            <value>The <see cref="T:NHibernate.IInterceptor"/> to use.</value>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Properties">
            <summary>
            Gets or sets the <see cref="T:System.Collections.IDictionary"/> that contains the configuration
            Properties and their values.
            </summary>
            <value>
            The <see cref="T:System.Collections.IDictionary"/> that contains the configuration
            Properties and their values.
            </value>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.Imports">
            <summary>
            Get the query language imports
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamedSQLQueries">
            <summary>
            The named SQL queries
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Configuration.NamingStrategy">
            <summary>
            Naming strategy for tables and columns
            </summary>
        </member>
        <member name="T:NHibernate.Engine.IMapping">
            <summary>
            Defines operations common to "compiled" mappings (ie. <c>SessionFactory</c>) and
            "uncompiled" mappings (ie <c>Configuration</c> that are used by implementors of <c>IType</c>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IMapping.GetIdentifierType(System.Type)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.IMapping.GetIdentifierPropertyName(System.Type)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.IMapping.GetPropertyType(System.Type,System.String)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cfg.ConfigurationSectionHandler">
            <summary>
            Summary description for ConfigurationSectionHandler.
            </summary>
        </member>
        <member name="T:NHibernate.Cfg.DefaultNamingStrategy">
            <summary>
            The default <cref name="INamingStrategy"/>
            </summary>
            <remarks>See <cref name="ImprovedNamingStrategy"/> for a better alternative</remarks>
        </member>
        <member name="T:NHibernate.Cfg.INamingStrategy">
            <summary>
            A set of rules for determining the physical column and table names given the information in the mapping
            document. May be used to implement project-scoped naming standards for database objects.
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return a table name for an entity class
            </summary>
            <param name="className">the fully-qualified class name</param>
            <returns>a table name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return a column name for a property path expression 
            </summary>
            <param name="propertyName">a property path</param>
            <returns>a column name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.TableName(System.String)">
            <summary>
            Alter the table name given in the mapping document
            </summary>
            <param name="tableName">a table name</param>
            <returns>a table name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.ColumnName(System.String)">
            <summary>
            Alter the column name given in the mapping document
            </summary>
            <param name="columnName">a column name</param>
            <returns>a column name</returns>
        </member>
        <member name="M:NHibernate.Cfg.INamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return a table name for a collection
            </summary>
            <param name="className">the fully-qualified name of the owning entity class</param>
            <param name="propertyName">a property path</param>
            <returns>a table name</returns>
        </member>
        <member name="F:NHibernate.Cfg.DefaultNamingStrategy.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return the unqualified class name
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return the unqualified property name
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.TableName(System.String)">
            <summary>
            Return the argument
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.ColumnName(System.String)">
            <summary>
            Return the argument
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.DefaultNamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return the unqualified property name
            </summary>
            <param name="className"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.IInterceptor">
            <summary>
            Allows user code to inspect and/or change property values before they are written and after they
            are read from the database
            </summary>
            <remarks>
            <para>
            There might be a single instance of <c>IInterceptor</c> for a <c>SessionFactory</c>, or a new
            instance might be specified for each <c>ISession</c>. Whichever approach is used, the interceptor
            must be serializable if the <c>ISession</c> is to be serializable. This means that <c>SessionFactory</c>
            -scoped interceptors should implement <c>ReadResolve()</c>.
            </para>
            <para>
            The <c>ISession</c> may not be invoked from a callback (nor may a callback cause a collection or
            proxy to be lazily initialized).
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IInterceptor.OnLoad(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called just before an object is initialized
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may change the <c>state</c>, which will be propagated to the persistent
            object. Note that when this method is called, <c>entity</c> will be an empty
            uninitialized instance of the class.</remarks>
            <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnFlushDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called when an object is detected to be dirty, during a flush.
            </summary>
            <param name="currentState"></param>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the detected <c>currentState</c>, which will be propagated to
            both the database and the persistent object. Note that all flushes end in an actual
            synchronization with the database, in which as the new <c>currentState</c> will be propagated
            to the object, but not necessarily (immediately) to the database. It is strongly recommended
            that the interceptor <b>not</b> modify the <c>previousState</c>.
            </remarks>
            <returns><c>true</c> if the user modified the <c>currentState</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnSave(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is saved
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            The interceptor may modify the <c>state</c>, which will be used for the SQL <c>INSERT</c>
            and propagated to the persistent object
            </remarks>
            <returns><c>true</c> if the user modified the <c>state</c> in any way</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.OnDelete(System.Object,System.Object,System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called before an object is deleted
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
            <param name="propertyNames"></param>
            <param name="state"></param>
            <param name="types"></param>
            <remarks>
            It is not recommended that the interceptor modify the <c>state</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.IInterceptor.PreFlush(System.Collections.ICollection)">
            <summary>
            Called before a flush
            </summary>
            <param name="entities">The entities</param>
        </member>
        <member name="M:NHibernate.IInterceptor.PostFlush(System.Collections.ICollection)">
            <summary>
            Called after a flush that actually ends in execution of the SQL statements required to
            synchronize in-memory state with the database.
            </summary>
            <param name="entities">The entitites</param>
        </member>
        <member name="M:NHibernate.IInterceptor.IsUnsaved(System.Object)">
            <summary>
            Called when a transient entity is passed to <c>SaveOrUpdate</c>.
            </summary>
            <remarks>
            The return value determines if the object is saved
            <list>
            	<item><c>true</c> - the entity is passed to <c>Save()</c>, resulting in an <c>INSERT</c></item>
            	<item><c>false</c> - the entity is passed to <c>Update()</c>, resulting in an <c>UPDATE</c></item>
            	<item><c>null</c> - Hibernate uses the <c>unsaved-value</c> mapping to determine if the object is unsaved</item>
            </list>
            </remarks>
            <param name="entity">A transient entity</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IInterceptor.FindDirty(System.Object,System.Object,System.Object[],System.Object[],System.String[],NHibernate.Type.IType[])">
            <summary>
            Called from <c>Flush()</c>. The return value determines whether the entity is updated
            </summary>
            <remarks>
            	<list>
            		<item>an array of property indicies - the entity is dirty</item>
            		<item>an empty array - the entity is not dirty</item>
            		<item><c>null</c> - use Hibernate's default dirty-checking algorithm</item>
            	</list>
            </remarks>
            <param name="entity">A persistent entity</param>
            <param name="currentState"></param>
            <param name="id"></param>
            <param name="previousState"></param>
            <param name="propertyNames"></param>
            <param name="types"></param>
            <returns>An array of dirty property indicies or <c>null</c> to choose default behavior</returns>
        </member>
        <member name="M:NHibernate.IInterceptor.Instantiate(System.Type,System.Object)">
            <summary>
            Instantiate the entity class. Return <c>null</c> to indicate that Hibernate should use the default
            constructor of the class
            </summary>
            <param name="type">A mapped type</param>
            <param name="id">The identifier of the new instance</param>
            <returns>An instance of the class, or <c>null</c> to choose default behaviour</returns>
        </member>
        <member name="T:NHibernate.Cfg.Environment">
            <summary>
            Provides access to configuration info
            </summary>
            <remarks>
            Hibernate has two property scopes:
            <list>
            	<item>
            	 Factory-Level properties may be passed to the <c>ISessionFactory</c> when it is instantiated.
            	 Each instance might have different property values. If no properties are specified, the
            	 factory gets them from Environment
            	</item>
            	<item>
            	 System-Level properties are shared by all factory instances and are always determined
            	 by the <c>Environment</c> properties
            	</item>
            </list>
            In NHibernate, <c>&lt;nhibernate&gt;</c> section in the application configuration file
            corresponds to Java system-level properties; <c>&lt;hibernate-configuration&gt;</c>
            section is considered to be the session-factory-level configuration. It is possible
            to use the configuration file at the same time.
            </remarks>
        </member>
        <member name="M:NHibernate.Cfg.Environment.VerifyProperties(System.Collections.IDictionary)">
            <summary>
            Issue warnings to user when any obsolete property names are used.
            </summary>
            <param name="props"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Cfg.Environment.Version">
            <summary>
            NHibernate version (informational).
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Environment.Properties">
            <summary>
            Gets a copy of the configuration found in <c>&lt;nhibernate&gt;</c> section
            of app.config/web.config.
            </summary>
            <remarks>
            This is the replacement for hibernate.properties
            </remarks>
        </member>
        <member name="P:NHibernate.Cfg.Environment.UseReflectionOptimizer">
            <summary>
            Enables or disables use of the reflection optimizer.
            </summary>
            <remarks>
            This property is read from the <c>&lt;nhibernate&gt;</c> section
            of the application configuration file by default. Since it is not
            always convenient to configure NHibernate through the application
            configuration file, it is also possible to set the property value
            manually. This should only be done before a session factory is
            created, otherwise the change may not take effect.
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.ImprovedNamingStrategy">
            <summary>
            Summary description for ImprovedNamingStrategy.
            </summary>
        </member>
        <member name="F:NHibernate.Cfg.ImprovedNamingStrategy.Instance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.ClassToTableName(System.String)">
            <summary>
            Return the unqualified class name, mixed case converted to underscores
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.PropertyToColumnName(System.String)">
            <summary>
            Return the full property path with underscore seperators, mixed case converted to underscores
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.TableName(System.String)">
            <summary>
            Convert mixed case to underscores
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.ColumnName(System.String)">
            <summary>
            Convert mixed case to underscores
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.ImprovedNamingStrategy.PropertyToTableName(System.String,System.String)">
            <summary>
            Return the full property path prefixed by the unqualified class name, with underscore seperators, mixed case converted to underscores
            </summary>
            <param name="className"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Cfg.Mappings">
            <summary>
            A collection of mappings from classes and collections to relational database tables.
            </summary>
            <remarks>Represents a single <c>&lt;hibernate-mapping&gt;</c> element.</remarks>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.#ctor(System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IDictionary,System.Collections.IList,System.Collections.IList,NHibernate.Cfg.INamingStrategy)">
            <summary>
            
            </summary>
            <param name="classes"></param>
            <param name="collections"></param>
            <param name="tables"></param>
            <param name="queries"></param>
            <param name="sqlqueries"></param>
            <param name="imports"></param>
            <param name="caches"></param>
            <param name="secondPasses"></param>
            <param name="propertyReferences"></param>
            <param name="namingStrategy"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddCache(System.String,NHibernate.Cache.ICacheConcurrencyStrategy)">
            <summary>
            Associates the class name with the cache strategy.
            </summary>
            <param name="name">The classname of the class to cache.</param>
            <param name="cache">The <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> to use for caching.</param>
            <exception cref="T:NHibernate.MappingException">Thrown when <c>name</c> already has a <c>cache</c> associated with it.</exception>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddClass(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddCollection(NHibernate.Mapping.Collection)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddUniquePropertyReference(System.Type,System.String)">
            <summary>
            
            </summary>
            <param name="referencedClass"></param>
            <param name="propertyName"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.GetClass(System.Type)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.GetCollection(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddImport(System.String,System.String)">
            <summary>
            Adds an import to allow for the full class name <c>Namespace.BusClass</c> 
            to be referenced as <c>BusClass</c> or some other name in Hql.
            </summary>
            <param name="className">The name of the class that is being renamed.</param>
            <param name="rename">The new name to use in Hql for the class.</param>
            <exception cref="T:NHibernate.MappingException">Thrown when the rename already identifies another Class.</exception>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddTable(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="schema"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.GetTable(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="schema"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddQuery(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="query"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddSQLQuery(System.String,NHibernate.Mapping.NamedSQLQuery)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="query"></param>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.GetQuery(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Cfg.Mappings.AddSecondPass(NHibernate.Cfg.Binder.AbstractSecondPass)">
            <summary>
            
            </summary>
            <param name="sp"></param>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.NamingStrategy">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultNamespace">
            <summary>
            The default namespace for persistent classes
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultAssembly">
            <summary>
            The default assembly for persistent classes
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.SchemaName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultCascade">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.DefaultAccess">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Mappings.IsAutoImport">
            <summary>
            Gets or sets a boolean indicating if the Fully Qualified Type name should
            automattically have an import added as the class name.
            </summary>
            <value><c>true</c> if the class name should be used as an import.</value>
            <remarks>
            AutoImport is used to shorten the string used to refer to Types to just their
            class.  So if the type <c>MyAssembly.MyNamespace.MyClass, MyAssembly</c> has an <c>auto-import="false"</c>
            then all use of in HQL would need to be the fully qualified version <c>MyAssembly.MyNamespace.MyClass</c>.
            If <c>auto-import="true"</c> the the Type could be referred to in hql by just the class
            name of <c>MyClass</c>.
            </remarks>
        </member>
        <member name="T:NHibernate.Cfg.Settings">
            <summary>
            Settings that affect the behavior of NHibernate at runtime.
            </summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.IsShowSqlEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.IsOuterJoinFetchEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.IsScrollableResultSetsEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.IsGetGeneratedKeysEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.BatchSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.MaximumFetchDepth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.IsAutoCreateSchema">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.IsAutoDropSchema">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.IsAutoUpdateSchema">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.StatementFetchSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.QuerySubstitutions">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.Dialect">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.DefaultSchemaName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.IsolationLevel">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.ConnectionProvider">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.TransactionFactory">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.SessionFactoryName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.CacheProvider">
            <summary></summary> 
        </member>
        <member name="P:NHibernate.Cfg.Settings.PrepareSql">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Cfg.Settings.CommandTimeout">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Cfg.SettingsFactory">
            <summary>
            Reads configuration properties and configures a <see cref="T:NHibernate.Cfg.Settings"/> instance. 
            </summary>
        </member>
        <member name="T:NHibernate.Collection.AbstractCollectionPersister">
            <summary>
            Summary description for AbstractCollectionPersister.
            </summary>
        </member>
        <member name="T:NHibernate.Metadata.ICollectionMetadata">
            <summary>
            Exposes collection metadata to the application
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.KeyType">
            <summary>
            The collection key type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.ElementType">
            <summary>
            The collection element type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IndexType">
            <summary>
            The collection index type (or null if the collection has no index)
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.HasIndex">
            <summary>
            Is the collection indexed?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.Role">
            <summary>
            The name of this collection role
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsArray">
            <summary>
            Is the collection an array?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsPrimitiveArray">
            <summary>
            Is the collection a primitive array?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.ICollectionMetadata.IsLazy">
            <summary>
            Is the collection lazily initialized?
            </summary>
        </member>
        <member name="T:NHibernate.Collection.IQueryableCollection">
            <summary>
            A collection role that may be queried or loaded by outer join.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.IPropertyMapping">
            <summary>
            Abstraction of all mappings that define properties: entities, collection elements.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.IPropertyMapping.ToType(System.String)">
            <summary>
            Given a component path expression, get the type of the property
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IPropertyMapping.ToColumns(System.String,System.String)">
            <summary>
            Given a query alias and a property path, return the qualified column name
            </summary>
            <param name="alias"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.IPropertyMapping.Type">
            <summary>
            Get the type of the thing containing the properties
            </summary>
        </member>
        <member name="T:NHibernate.Persister.IJoinable">
            <summary>
            Anything that can be loaded by outer join - namely persisters for classes or collections.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.IJoinable.SelectFragment(System.String,System.String,System.Boolean)">
            <summary>
            All columns to select, when loading.
            </summary>
            <param name="alias"></param>
            <param name="suffix"></param>
            <param name="includeCollectionColumns"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IJoinable.WhereJoinFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get the where clause part of any joins (optional operation)
            </summary>
            <param name="alias"></param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IJoinable.FromJoinFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get the from clause part of any joins (optional operation)
            </summary>
            <param name="alias"></param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IJoinable.ConsumesAlias">
            <summary>
            Ugly, very ugly....
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.IJoinable.Name">
            <summary>
            An identifying name; a class name or collection role name.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IJoinable.TableName">
            <summary>
            The table to join to.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IJoinable.JoinKeyColumnNames">
            <summary>
            The columns to join on.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IJoinable.IsCollection">
            <summary>
            Is this instance actually a ICollectionPersister?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IJoinable.IsManyToMany">
            <summary>
            Is this instance actually a many-to-many association?
            </summary>
        </member>
        <member name="T:NHibernate.Collection.ICollectionPersister">
            <summary>
            <p>A strategy for persisting a collection role. Defines a contract between
            the persistence strategy and the actual persistent collection framework
            and session. Does not define operations that are required for querying
            collections, or loading by outer join.</p>
            <p>
            Implements persistence of a collection instance while the instance is
            referenced in a particular role.</p>
            <p>
            This class is highly coupled to the <see cref="T:NHibernate.Collection.PersistentCollection"/>
            hierarchy, since double dispatch is used to load and update collection 
            elements.</p>
            </summary>
            <remarks>
            May be considered an immutable view of the mapping object
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.Initialize(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initialize the given collection with the given key
            </summary>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.ReadKey(System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the key from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <param name="rs"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.ReadElement(System.Data.IDataReader,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the element from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <param name="rs"></param>
            <param name="owner"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.ReadIndex(System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the index from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <param name="rs"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.ReadIdentifier(System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read the identifier from a row of the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <param name="rs"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.WriteKey(System.Data.IDbCommand,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Write the key to an <see cref="T:System.Data.IDbCommand"/>
            </summary>
            <param name="st"></param>
            <param name="key"></param>
            <param name="writeOrder"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.WriteElement(System.Data.IDbCommand,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Write the element to an <see cref="T:System.Data.IDbCommand"/>
            </summary>
            <param name="st"></param>
            <param name="elt"></param>
            <param name="writeOrder"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.WriteIndex(System.Data.IDbCommand,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Write the index to an <see cref="T:System.Data.IDbCommand"/>
            </summary>
            <param name="st"></param>
            <param name="idx"></param>
            <param name="writeOrder"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.WriteIdentifier(System.Data.IDbCommand,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Write the identifier to an <see cref="T:System.Data.IDbCommand"/>
            </summary>
            <param name="st"></param>
            <param name="idx"></param>
            <param name="writeOrder"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.Remove(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Completely remove the persistent state of the collection
            </summary>
            <param name="id"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.Recreate(NHibernate.Collection.PersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            (Re)create the collection's persistent state
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.DeleteRows(NHibernate.Collection.PersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Delete the persistent state of any elements that were removed from the collection
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.UpdateRows(NHibernate.Collection.PersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Update the persistent state of any elements that were modified
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.ICollectionPersister.InsertRows(NHibernate.Collection.PersistentCollection,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Insert the persistent state of any new collection elements
            </summary>
            <param name="collection"></param>
            <param name="key"></param>
            <param name="session"></param>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.Cache">
            <summary>
            Get the cache
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.HasCache">
            <summary>
            Is this collection role cacheable
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.CollectionType">
            <summary>
            Get the associated <c>IType</c>
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.KeyType">
            <summary>
            Get the "key" type (the type of the foreign key)
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.IndexType">
            <summary>
            Get the "index" type for a list or map (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.ElementType">
            <summary>
            Get the "element" type
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.ElementClass">
            <summary>
            Return the element class of an array, or null otherwise
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.IsPrimitiveArray">
            <summary>
            Is this an array or primitive values?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.IsArray">
            <summary>
            Is this an array?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.IsOneToMany">
            <summary>
            Is this a one-to-many association?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.HasIndex">
            <summary>
            Is this an "indexed" collection? (list or map)
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.IsLazy">
            <summary>
            Is this collection lazyily initialized?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.IsInverse">
            <summary>
            Is this collection "inverse", so state changes are not propogated to the database.
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.Role">
            <summary>
            Get the name of this collection role (the fully qualified class name, extended by a "property path")
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.OwnerClass">
            <summary>
            Get the entity class that "owns" this collection
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.IdentifierGenerator">
            <summary>
            Get the surrogate key generation strategy (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.IdentifierType">
            <summary>
            Get the type of the surrogate key
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.HasOrphanDelete">
            <summary>
            Does this collection implement "orphan delete"?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.HasOrdering">
            <summary>
            Is this an ordered collection? (An ordered collection is
            ordered by the initialization operation, not by sorting
            that happens in memory, as in the case of a sorted collection.)
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ICollectionPersister.CollectionSpace">
            <summary>
            Get the "space" that holds the persistent state
            </summary>
        </member>
        <member name="M:NHibernate.Collection.IQueryableCollection.SelectFragment(System.String)">
            <summary>
            Generate a list of collection index and element columns
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.IQueryableCollection.GetSQLWhereString(System.String)">
            <summary>
            Get the extra where clause filter SQL
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.IQueryableCollection.GetSQLOrderByString(System.String)">
            <summary>
            Get the order by SQL
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Collection.IQueryableCollection.IndexColumnNames">
            <summary>
            Get the names of the collection index columns if this is an indexed collection (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IQueryableCollection.ElementColumnNames">
            <summary>
            Get the names of the collection element columns (or the primary key columns in the case of a one-to-many association)
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IQueryableCollection.KeyColumnNames">
            <summary>
            Get the names of the collection key columns
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IQueryableCollection.HasWhere">
            <summary>
            Does this collection role have a where clause filter?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IQueryableCollection.ElementPersister">
            <summary>
            Get the persister of the element class, if this is a
            collection of entities (optional operation).  Note that
            for a one-to-many association, the returned persister
            must be <c>OuterJoinLoadable</c>.
            </summary>
        </member>
        <member name="P:NHibernate.Collection.IQueryableCollection.EnableJoinedFetch">
            <summary>
            Should we load this collection role by outer joining?
            </summary>
        </member>
        <member name="M:NHibernate.Collection.AbstractCollectionPersister.ReadElement(System.Data.IDataReader,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Reads the Element from the IDataReader.  The IDataReader will probably only contain
            the id of the Element.
            </summary>
            <param name="rs"></param>
            <param name="owner"></param>
            <param name="session"></param>
            <returns></returns>
            <remarks>See ReadElementIdentifier for an explanation of why this method will be depreciated.</remarks>
        </member>
        <member name="M:NHibernate.Collection.AbstractCollectionPersister.ReadElementIdentifier(System.Data.IDataReader,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Gets just the Identifier of the Element for the Collection.
            </summary>
            <param name="rs"></param>
            <param name="owner"></param>
            <param name="session"></param>
            <returns></returns>
            <remarks>
            This was created in addition to ReadElement because ADO.NET does not allow
            for 2 IDataReaders to be open against a single IDbConnection at one time.  
            
            When a Collection is loaded it was recursively opening IDbDataReaders to resolve
            the Element for the Collection while the IDbDataReader was open that contained the
            record for the Collection.
            </remarks>		
        </member>
        <member name="P:NHibernate.Collection.AbstractCollectionPersister.ElementClass">
            <summary>
            Return the element class of an array, or null otherwise
            </summary>
        </member>
        <member name="P:NHibernate.Collection.AbstractCollectionPersister.Role">
            <summary>
            Get the name of this collection role (the fully qualified class name,
            extended by a "property path")
            </summary>
        </member>
        <member name="T:NHibernate.Collection.ArrayHolder">
            <summary>
            A persistent wrapper for an array. lazy initialization is NOT supported
            </summary>
        </member>
        <member name="T:NHibernate.Collection.PersistentCollection">
            <summary>
            Base class for persistent collections
            </summary>
            <remarks>
            <para>
            Persistent collections are treated as value objects by Hibernate.
            i.e. they have no independent existence beyond the object holding
            a reference to them. Unlike instances of entity classes, they are
            automatically deleted when unreferenced and automatically become
            persistent when held by a persistent object. Collections can be
            passed between different objects (change "roles") and this might
            cause their elements to move from one database table to another.
            </para>
            <para>
            Hibernate "wraps" a java collection in an instance of
            PersistentCollection. This mechanism is designed to support
            tracking of changes to the collection's persistent state and
            lazy instantiation of collection elements. The downside is that
            only certain abstract collection types are supported and any
            extra semantics are lost.
            </para>
            <para>
            Applications should <em>never</em> use classes in this package 
            directly, unless extending the "framework" here.
            </para>
            <para>
            Changes to <em>structure</em> of the collection are recorded by the
            collection calling back to the session. Changes to mutable
            elements (ie. composite elements) are discovered by cloning their
            state when the collection is initialized and comparing at flush
            time.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.Read">
            <summary>
            Called by any read-only method of the collection interface
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.Write">
            <summary>
            Called by any writer method of the collection interface
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.QueueAdd(System.Object)">
            <summary>
            Queue an addition
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.QueueAddAll(System.Collections.ICollection)">
            <summary>
            Queue additions
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.DelayedAddAll(System.Collections.ICollection)">
            <summary>
            After reading all existing elements from the database,
            add the queued elements to the underlying collection.
            </summary>
            <param name="coll"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.PostFlush">
            <summary>
            Clears out any Queued Additions.
            </summary>
            <remarks>
            After a Flush() the database is in synch with the in-memory
            contents of the Collection.  Since everything is in synch remove
            any Queued Additions.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.#ctor">
            <summary>
            Not called by Hibernate, but used by non-NET serialization, eg. SOAP libraries.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Not called by Hibernate, but used by non-NET serialization, eg. SOAP libraries.
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.GetValue">
            <summary>
            Return the user-visible collection (or array) instance
            </summary>
            <returns>
            By default, the NHibernate wrapper is an acceptable collection for
            the end user code to work with because it is interface compatible.
            An NHibernate List is an IList, an NHibernate Map is an IDictionary
            and those are the types user code is expecting.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.BeginRead">
            <summary>
            Called just before reading any rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.EndRead">
            <summary>
            Called after reading all rows from the <see cref="T:System.Data.IDataReader"/>
            </summary>
            <remarks>
            This should be overridden by sub collections that use temporary collections
            to store values read from the db.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.Initialize(System.Boolean)">
            <summary>
            Initialize the collection, if possible, wrapping any exceptions
            in a runtime exception
            </summary>
            <param name="writing">currently obsolete</param>
            <exception cref="T:NHibernate.LazyInitializationException">if we cannot initialize</exception>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.SetInitialized">
            <summary>
            Mark the collection as initialized.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.UnsetSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Disassociate this collection from the given session.
            </summary>
            <param name="session"></param>
            <returns>true if this was currently associated with the given session</returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.SetCurrentSession(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Associate the collection with the given session.
            </summary>
            <param name="session"></param>
            <returns>false if the collection was already associated with the session</returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.InitializeFromCache(NHibernate.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Read the state of the collection from a disassembled cached value.
            </summary>
            <param name="persister"></param>
            <param name="disassembled"></param>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.Entries">
            <summary>
            Iterate all collection entries, during update of the database
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.ReadFrom(System.Data.IDataReader,NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            Reads the elements Identifier from the reader.
            </summary>
            <param name="reader">The IDataReader that contains the value of the Identifier</param>
            <param name="role">The persister for this Collection.</param>
            <param name="owner">The owner of this Collection.</param>
            <returns>The value of the Identifier.</returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.WriteTo(System.Data.IDbCommand,NHibernate.Collection.ICollectionPersister,System.Object,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="role"></param>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="writeOrder"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.GetIndex(System.Object,System.Int32)">
            <summary>
            Get the index of the given collection entry
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.BeforeInitialize(NHibernate.Collection.ICollectionPersister)">
            <summary>
            Called before any elements are read into the collection,
            allowing appropriate initializations to occur.
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            Does the current state exactly match the snapshot?
            </summary>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.Snapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            Return a new snapshot of the current state
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.Disassemble(NHibernate.Collection.ICollectionPersister)">
            <summary>
            Disassemble the collection, ready for the cache
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.NeedsRecreate(NHibernate.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the rows for this collection
            need to be recreated in the table.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Collection.ICollectionPersister"/> for this Collection.</param>
            <returns>
            <c>false</c> by default since most collections can determine which rows need to be
            individually updated/inserted/deleted.  Currently only <see cref="T:NHibernate.Collection.Bag"/>'s for <c>many-to-many</c>
            need to be recreated.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.GetSnapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.ForceInitialization">
            <summary>
            To be called internally by the session, forcing
            immediate initalization.
            </summary>
            <remarks>
            This method is similar to <see cref="M:NHibernate.Collection.PersistentCollection.Initialize(System.Boolean)"/>, except that different exceptions are thrown.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.EntryExists(System.Object,System.Int32)">
            <summary>
            Does an element exist at this entry in the collection?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to insert this element?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            Do we need to update this element?
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.GetDeletes(NHibernate.Type.IType)">
            <summary>
            Get all the elements that need deleting
            </summary>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.IsWrapper(System.Object)">
            <summary>
            Is this the wrapper for the given underlying collection instance?
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.GetSnapshot">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.PreInsert(NHibernate.Collection.ICollectionPersister)">
            <summary>
            Called before inserting rows, to ensure that any surrogate keys are fully generated
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.AfterRowInsert(NHibernate.Collection.ICollectionPersister,System.Object,System.Int32)">
            <summary>
            Called after inserting a row, to fetch the natively generated id
            </summary>
            <param name="persister"></param>
            <param name="entry"></param>
            <param name="i"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.GetOrphans(System.Object)">
            <summary>
            Get all "orphaned" elements
            </summary>
            <param name="snapshot"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.PersistentCollection.GetEnumerator">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.Empty">
            <summary>
            Is the initialized collection empty?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.IsConnectedToSession">
            <summary>
            Is the collection currently connected to an open session?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.IsQueueAdditionEnabled">
            <summary>
            Is this collection in a state that would allow us to "queue" additions?
            </summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.IsDirectlyAccessible">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the underlying collection is directly
            accessable through code.
            </summary>
            <value>
            <c>true</c> if we are not guaranteed that the NHibernate collection wrapper
            is being used.
            </value>
            <remarks>
            This is typically <c>false</c> whenever a transient object that contains a collection is being
            associated with an ISession through <c>Save</c> or <c>SaveOrUpdate</c>.  NHibernate can't guarantee
            that it will know about all operations that would call cause NHibernate's collections to call
            <c>Read()</c> or <c>Write()</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.WasInitialized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.HasQueuedAdds">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.QueuedAddsCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.CollectionSnapshot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.Session">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.IsSynchronized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.Count">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.PersistentCollection.SyncRoot">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Collection.ArrayHolder.array">
            <summary>
            The <see cref="P:NHibernate.Collection.ArrayHolder.Array"/> that NHibernate is wrapping.
            </summary>
        </member>
        <member name="F:NHibernate.Collection.ArrayHolder.tempList">
            <summary>
            A temporary list that holds the objects while the ArrayHolder is being
            populated from the database.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.#ctor(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="array"></param>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.Snapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.GetOrphans(System.Object)">
            <summary>
            
            </summary>
            <param name="snapshot"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.#ctor(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.IsWrapper(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.Elements">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.WriteTo(System.Data.IDbCommand,NHibernate.Collection.ICollectionPersister,System.Object,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="persister"></param>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="writeOrder"></param>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.ReadFrom(System.Data.IDataReader,NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="persister"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.Entries">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.BeginRead">
            <summary>
            Before the <c>ReadFrom()</c> is called the ArrayHolder needs to setup 
            a temporary list to hold the objects.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.EndRead">
            <summary>
            Takes the contents stored in the temporary list created during <c>BeginRead()</c>
            that was populated during <c>ReadFrom()</c> and write it to the underlying 
            array.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.BeforeInitialize(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.InitializeFromCache(NHibernate.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this array holder from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the Array.</param>
            <param name="disassembled">The disassembled Array.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.Disassemble(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.GetValue">
            <summary>
            Returns the user-visible portion of the NHibernate ArrayHolder.
            </summary>
            <returns>
            The array that contains the data, not the NHibernate wrapper.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.GetDeletes(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.GetIndex(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.EntryExists(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.ArrayHolder.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Collection.ArrayHolder.Array">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ArrayHolder.Empty">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ArrayHolder.IsDirectlyAccessible">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ArrayHolder.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ArrayHolder.IsSynchronized">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.ArrayHolder.SyncRoot">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Collection.Bag">
            <summary>
            An unordered, unkeyed collection that can contain the same element
            multiple times. The .net collections API, has no <c>Bag</c>.
            Most developers seem to use <see cref="T:System.Collections.IList"/>s to represent bag semantics,
            so NHibernate follows this practice.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Bag.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="coll"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.IsWrapper(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.Entries">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.ReadFrom(System.Data.IDataReader,NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <param name="persister"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.WriteTo(System.Data.IDbCommand,NHibernate.Collection.ICollectionPersister,System.Object,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="persister"></param>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="writeOrder"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.BeforeInitialize(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.CountOccurrences(System.Object,System.Collections.IList,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="element"></param>
            <param name="list"></param>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.Snapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.GetOrphans(System.Object)">
            <summary>
            
            </summary>
            <param name="snapshot"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.Disassemble(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.InitializeFromCache(NHibernate.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this Bag from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the Bag.</param>
            <param name="disassembled">The disassembled Bag.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.Bag.NeedsRecreate(NHibernate.Collection.ICollectionPersister)">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this Bag needs to be recreated
            in the database.
            </summary>
            <param name="persister"></param>
            <returns>
            <c>false</c> if this is a <c>one-to-many</c> Bag, <c>true</c> if this is not
            a <c>one-to-many</c> Bag.  Since a Bag is an unordered, unindexed collection 
            that permits duplicates it is not possible to determine what has changed in a
            <c>many-to-many</c> so it is just recreated.
            </returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.GetDeletes(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.Insert(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.Remove(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.Contains(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Bag.IndexOf(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.Add(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.DelayedAddAll(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="coll"></param>
        </member>
        <member name="M:NHibernate.Collection.Bag.GetIndex(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Bag.EntryExists(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Collection.Bag.Empty">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Bag.IsReadOnly">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Bag.Item(System.Int32)">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Bag.IsFixedSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Bag.IsSynchronized">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Bag.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Bag.SyncRoot">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Collection.BasicCollectionPersister">
            <summary>
            Collection persister for collections of values and many-to-many associations.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.BasicCollectionPersister.GenerateDeleteString">
            <summary>
            Generate the SQL DELETE that deletes all rows
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.BasicCollectionPersister.GenerateInsertRowString">
            <summary>
            Generate the SQL INSERT that creates a new row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.BasicCollectionPersister.GenerateUpdateRowString">
            <summary>
            Generate the SQL UPDATE that updates a row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.BasicCollectionPersister.GenerateDeleteRowString">
            <summary>
            Generate the SQL DELETE that deletes a particular row
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.BasicCollectionPersister.CreateCollectionInitializer(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Create the <see cref="T:NHibernate.Loader.CollectionLoader"/>
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.BasicCollectionPersister.FromJoinFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.BasicCollectionPersister.WhereJoinFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.BasicCollectionPersister.SelectFragment(System.String,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="suffix"></param>
            <param name="includeCollectionColumns"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Collection.CollectionPropertyMapping">
            <summary>
            Summary description for CollectionPropertyMapping.
            </summary>
        </member>
        <member name="T:NHibernate.Collection.CompositeElementPropertyMapping">
            <summary>
            Summary description for CompositeElementPropertyMapping.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.AbstractPropertyMapping">
            <summary>
            Base implementation of a PropertyMapping.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.ToType(System.String)">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.ToColumns(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.AddPropertyPath(System.String,NHibernate.Type.IType,System.String[])">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="type"></param>
            <param name="columns"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.AddFormulaPropertyPath(System.String,NHibernate.Type.IType,System.String)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="type"></param>
            <param name="template"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.InitPropertyPaths(System.String,NHibernate.Type.IType,System.String[],System.String,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="type"></param>
            <param name="columns"></param>
            <param name="formulaTemplate"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.InitPropertyPaths(System.String,NHibernate.Type.IType,System.String[],NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="type"></param>
            <param name="columns"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.InitIdentifierPropertyPaths(System.String,NHibernate.Type.EntityType,System.String[],NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="etype"></param>
            <param name="columns"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.InitComponentPropertyPaths(System.String,NHibernate.Type.IAbstractComponentType,System.String[],NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="type"></param>
            <param name="columns"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractPropertyMapping.HandlePath(System.String,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="type"></param>
        </member>
        <member name="P:NHibernate.Persister.AbstractPropertyMapping.IdentifierColumnNames">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractPropertyMapping.ClassName">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractPropertyMapping.Type">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Collection.CompositeElementPropertyMapping.#ctor(System.String[],NHibernate.Type.IAbstractComponentType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="elementColumns"></param>
            <param name="compositeType"></param>
            <param name="factory"></param>
        </member>
        <member name="P:NHibernate.Collection.CompositeElementPropertyMapping.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.CompositeElementPropertyMapping.ClassName">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Collection.ElementPropertyMapping">
            <summary>
            Summary description for ElementPropertyMapping.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.ElementPropertyMapping.#ctor(System.String[],NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elementColumns"></param>
            <param name="type"></param>
        </member>
        <member name="M:NHibernate.Collection.ElementPropertyMapping.ToType(System.String)">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.ElementPropertyMapping.ToColumns(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Collection.ElementPropertyMapping.Type">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Collection.IdentifierBag">
            <summary>
            An <c>IdentiferBag</c> implements "bag" semantics more efficiently than
            a regular <see cref="T:NHibernate.Collection.Bag"/> by adding a synthetic identifier column to the
            table.
            </summary>
            <remarks>
            <para>
            The identifier is unique for all rows in the table, allowing very efficient
            updates and deletes.  The value of the identifier is never exposed to the 
            application. 
            </para>
            <para>
            <c>IdentifierBag</c>s may not be used for a many-to-one association.  Furthermore,
            there is no reason to use <c>inverse="true"</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.IdentifierBag.InitializeFromCache(NHibernate.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this Bag from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the IdentifierBag.</param>
            <param name="disassembled">The disassembled IdentifierBag.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="T:NHibernate.Collection.List">
            <summary>
            A persistent wrapper for an IList
            </summary>
        </member>
        <member name="M:NHibernate.Collection.List.Snapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.GetOrphans(System.Object)">
            <summary>
            
            </summary>
            <param name="snapshot"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.IsWrapper(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.List.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="list"></param>
        </member>
        <member name="M:NHibernate.Collection.List.BeforeInitialize(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.List.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.List.Contains(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.List.DelayedAddAll(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="coll"></param>
        </member>
        <member name="M:NHibernate.Collection.List.Add(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.Insert(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Collection.List.Remove(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Collection.List.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.List.RemoveAt(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.List.IndexOf(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.List.WriteTo(System.Data.IDbCommand,NHibernate.Collection.ICollectionPersister,System.Object,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="persister"></param>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="writeOrder"></param>
        </member>
        <member name="M:NHibernate.Collection.List.ReadFrom(System.Data.IDataReader,NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="persister"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.Entries">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.List.InitializeFromCache(NHibernate.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this List from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the List.</param>
            <param name="disassembled">The disassembled List.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.List.Disassemble(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.GetDeletes(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.GetIndex(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.List.EntryExists(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Collection.List.Count">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.List.IsEmpty">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.List.SyncRoot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.List.IsSynchronized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.List.IsFixedSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.List.IsReadOnly">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.List.Item(System.Int32)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.List.Empty">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Collection.Map">
            <summary>
            A persistent wrapper for a <see cref="T:System.Collections.IDictionary"/>. Underlying collection
            is a <see cref="T:System.Collections.Hashtable"/>.
            </summary>
        </member>
        <member name="F:NHibernate.Collection.Map.map">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Map.Snapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.GetOrphans(System.Object)">
            <summary>
            
            </summary>
            <param name="snapshot"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elementType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.IsWrapper(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Map.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Construct an uninitialized Map.
            </summary>
            <param name="session">The ISession the Map should be a part of.</param>
        </member>
        <member name="M:NHibernate.Collection.Map.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IDictionary)">
            <summary>
            Construct an initialized Map based off the values from the existing IDictionary.
            </summary>
            <param name="session">The ISession the Map should be a part of.</param>
            <param name="map">The IDictionary that contains the initial values.</param>
        </member>
        <member name="M:NHibernate.Collection.Map.BeforeInitialize(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.Map.GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Map.System#Collections#IEnumerable#GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Map.System#Collections#IDictionary#GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Map.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.Map.Add(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Collection.Map.Contains(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.Remove(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Collection.Map.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Map.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Map.WriteTo(System.Data.IDbCommand,NHibernate.Collection.ICollectionPersister,System.Object,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="persister"></param>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="writeOrder"></param>
        </member>
        <member name="M:NHibernate.Collection.Map.ReadFrom(System.Data.IDataReader,NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="persister"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.Entries">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Map.InitializeFromCache(NHibernate.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this Map from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the Map.</param>
            <param name="disassembled">The disassembled Map.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.Map.Disassemble(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.GetDeletes(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.GetIndex(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Map.EntryExists(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Collection.Map.Count">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Map.IsSynchronized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Map.IsFixedSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Map.IsReadOnly">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Map.SyncRoot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Map.Keys">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Map.Values">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Map.Item(System.Object)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Map.Empty">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Collection.OneToManyPersister">
            <summary>
            Summary description for OneToManyPersister.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.OneToManyPersister.GenerateDeleteString">
            <summary>
            Generate the SQL UPDATE that updates all the foreign keys to null
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.OneToManyPersister.GenerateInsertRowString">
            <summary>
            Generate the SQL UPDATE that updates a foreign key to a value
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.OneToManyPersister.GenerateUpdateRowString">
            <summary>
            Not needed for one-to-many association
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.OneToManyPersister.GenerateDeleteRowString">
            <summary>
            Generate the SQL UPDATE that updates a particular row's foreign
            key to null
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.OneToManyPersister.CreateCollectionInitializer(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Create the <see cref="T:NHibernate.Loader.OneToManyLoader"/>
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Collection.Set">
            <summary>
            .NET has no design equivalent for Java's Set so we are going to use the
            Iesi.Collections library. This class is internal to NHibernate and shouldn't
            be used by user code.
            </summary>
            <remarks>
            The code for the Iesi.Collections library was taken from the article
            <a href="http://www.codeproject.com/csharp/sets.asp">Add Support for "Set" Collections
            to .NET</a> that was written by JasonSmith.
            </remarks>
        </member>
        <member name="F:NHibernate.Collection.Set.internalSet">
            <summary>
            The <see cref="T:Iesi.Collections.ISet"/> that NHibernate is wrapping.
            </summary>
        </member>
        <member name="F:NHibernate.Collection.Set.tempList">
            <summary>
            A temporary list that holds the objects while the Set is being
            populated from the database.  
            </summary>
            <remarks>
            This is necessary to ensure that the object being added to the Set doesn't
            have its' <c>GetHashCode()</c> and <c>Equals()</c> methods called during the load
            process.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.Set.Snapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            Returns a Hashtable where the Key &amp; the Value are both a Copy of the
            same object.
            <see cref="M:NHibernate.Collection.PersistentCollection.Snapshot(NHibernate.Collection.ICollectionPersister)"/>
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.Set.GetOrphans(System.Object)">
            <summary>
            
            </summary>
            <param name="snapshot"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.EqualsSnapshot(NHibernate.Type.IType)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.EqualsSnapshot(NHibernate.Type.IType)"/>
            </summary>
            <param name="elementType"></param>
        </member>
        <member name="M:NHibernate.Collection.Set.IsWrapper(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            This constructor is NOT meant to be called from user code.
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Collection.Set.#ctor(NHibernate.Engine.ISessionImplementor,Iesi.Collections.ISet)">
            <summary>
            Creates a new Set initialized to the values in the Map.
            This constructor is NOT meant to be called from user code.
            </summary>
            <param name="session"></param>
            <param name="collection"></param>
            <remarks>
            Only call this constructor if you consider the map initialized.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.Set.InitializeFromCache(NHibernate.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            Initializes this Set from the cached values.
            </summary>
            <param name="persister">The CollectionPersister to use to reassemble the Set.</param>
            <param name="disassembled">The disassembled Set.</param>
            <param name="owner">The owner object.</param>
        </member>
        <member name="M:NHibernate.Collection.Set.BeforeInitialize(NHibernate.Collection.ICollectionPersister)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.BeforeInitialize(NHibernate.Collection.ICollectionPersister)"/>
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.Set.CopyTo(System.Array,System.Int32)">
            <summary>
            <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Collection.Set.Add(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.AddAll(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="coll"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Set.Contains(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.ContainsAll(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.ExclusiveOr(Iesi.Collections.ISet)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.Intersect(Iesi.Collections.ISet)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.Minus(Iesi.Collections.ISet)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.Remove(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.RemoveAll(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.RetainAll(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.Union(Iesi.Collections.ISet)">
            <summary>
            
            </summary>
            <param name="a"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Set.Clone">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Set.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Collection.Set.WriteTo(System.Data.IDbCommand,NHibernate.Collection.ICollectionPersister,System.Object,System.Int32,System.Boolean)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.WriteTo(System.Data.IDbCommand,NHibernate.Collection.ICollectionPersister,System.Object,System.Int32,System.Boolean)"/>
            </summary>
            <param name="st"></param>
            <param name="persister"></param>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="writeOrder"></param>
        </member>
        <member name="M:NHibernate.Collection.Set.ReadFrom(System.Data.IDataReader,NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.ReadFrom(System.Data.IDataReader,NHibernate.Collection.ICollectionPersister,System.Object)"/>
            </summary>
            <param name="rs"></param>
            <param name="persister"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.BeginRead">
            <summary>
            Set up the temporary List that will be used in the EndRead() 
            to fully create the set.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Set.EndRead">
            <summary>
            Takes the contents stored in the temporary list created during <c>BeginRead()</c>
            that was populated during <c>ReadFrom()</c> and write it to the underlying 
            Set.
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Set.Entries">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.Entries"/>
            </summary>
        </member>
        <member name="M:NHibernate.Collection.Set.Disassemble(NHibernate.Collection.ICollectionPersister)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.Disassemble(NHibernate.Collection.ICollectionPersister)"/>
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.Set.GetDeletes(NHibernate.Type.IType)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.GetDeletes(NHibernate.Type.IType)"/>
            </summary>
            <param name="elemType"></param>
        </member>
        <member name="M:NHibernate.Collection.Set.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.NeedsInserting(System.Object,System.Int32,NHibernate.Type.IType)"/>
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.NeedsUpdating(System.Object,System.Int32,NHibernate.Type.IType)"/>
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <param name="elemType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.GetIndex(System.Object,System.Int32)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.GetIndex(System.Object,System.Int32)"/>
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.Set.EntryExists(System.Object,System.Int32)">
            <summary>
            <see cref="M:NHibernate.Collection.PersistentCollection.EntryExists(System.Object,System.Int32)"/>
            </summary>
            <param name="entry"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Collection.Set.Count">
            <summary>
            <see cref="P:System.Collections.ICollection.Count"/>
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Set.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.ICollection.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Set.SyncRoot">
            <summary>
            <see cref="P:System.Collections.ICollection.SyncRoot"/>
            </summary>
        </member>
        <member name="P:NHibernate.Collection.Set.IsEmpty">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Collection.Set.Empty">
            <summary>
            <see cref="P:NHibernate.Collection.PersistentCollection.Empty"/>
            </summary>
        </member>
        <member name="T:NHibernate.Collection.SortedMap">
            <summary>
            A Persistent wrapper for a <c>System.Collections.IDictionary</c> that has
            sorting.
            </summary>
            <remarks>
            This class uses the SortedList as the underlying map for the SortedMap.  The SortedList
            is not really an IList at all.  It actually is a Hashtable that provides methods to get
            to a Key by its index.  Since it is sorted the indexes can change based on what is added
            to the Dictionary.  In my opinion, the index is not useful except to get the first or last
            element.
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.SortedMap.Snapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.SortedMap.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create an Uninitialized SortedMap.
            </summary>
            <param name="session">The ISession the Map should be a part of.</param>
        </member>
        <member name="M:NHibernate.Collection.SortedMap.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IComparer)">
            <summary>
            Constuct an uninitialized SortedMap that uses an IComparer to perform the sorting.
            </summary>
            <param name="session"></param>
            <param name="comparer">The IComparer to user for Sorting.</param>
        </member>
        <member name="M:NHibernate.Collection.SortedMap.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IDictionary,System.Collections.IComparer)">
            <summary>
            Construct an initialized SortedMap based off the values from the existing IDictionary.
            </summary>
            <param name="session">The ISession the SortedMap should be a part of.</param>
            <param name="map">The IDictionary that contains the initial values.</param>
            <param name="comparer">The IComparer to use for Sorting.</param>
        </member>
        <member name="M:NHibernate.Collection.SortedMap.BeforeInitialize(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
        </member>
        <member name="P:NHibernate.Collection.SortedMap.Comparer">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Collection.SortedSet">
            <summary>
            A Persistent wrapper for a <c>Iesi.Collections.ISet</c> that has
            Set logic to prevent duplicate elements.
            </summary>
            <remarks>
            This class uses the Iesi.Collections.SortedSet for the SortedSet.  
            </remarks>
        </member>
        <member name="M:NHibernate.Collection.SortedSet.Snapshot(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Collection.SortedSet.BeforeInitialize(NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Collection.SortedSet.#ctor(NHibernate.Engine.ISessionImplementor,System.Collections.IComparer)">
            <summary>
            Constuct a new empty SortedSet that uses a IComparer to perform the sorting.
            </summary>
            <param name="session"></param>
            <param name="comparer">The IComparer to user for Sorting.</param>
        </member>
        <member name="M:NHibernate.Collection.SortedSet.#ctor(NHibernate.Engine.ISessionImplementor,Iesi.Collections.ISet,System.Collections.IComparer)">
            <summary>
            Construct a new SortedSet initialized with the map values.
            </summary>
            <param name="session">The Session to be bound to.</param>
            <param name="map">The initial values.</param>
            <param name="comparer">The IComparer to use for Sorting.</param>
        </member>
        <member name="P:NHibernate.Collection.SortedSet.Comparer">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Connection.ConnectionProvider">
            <summary>
            The base class for the ConnectionProvider.
            </summary>
        </member>
        <member name="T:NHibernate.Connection.IConnectionProvider">
            <summary>
            A strategy for obtaining ADO.NET <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <remarks>
            The <c>IConnectionProvider</c> interface is not intended to be exposed to the application.
            Instead it is used internally by NHibernate to obtain <see cref="T:System.Data.IDbConnection"/>. 
            Implementors should provide a public default constructor.
            </remarks>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.Configure(System.Collections.IDictionary)">
            <summary>
            Initialize the connection provider from the given properties.
            </summary>
            <param name="settings">The connection provider settings</param>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Dispose of a used <see cref="T:System.Data.IDbConnection"/>
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.IConnectionProvider.GetConnection">
            <summary>
            Get an open <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <returns>An open <see cref="T:System.Data.IDbConnection"/>.</returns>
        </member>
        <member name="P:NHibernate.Connection.IConnectionProvider.Driver">
            <summary>
            Gets the <see cref="T:NHibernate.Driver.IDriver"/> this ConnectionProvider should use to 
            communicate with the .NET Data Provider
            </summary>
            <value>
            The <see cref="T:NHibernate.Driver.IDriver"/> to communicate with the .NET Data Provider.
            </value>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Closes the <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Configure(System.Collections.IDictionary)">
            <summary>
            Configures the ConnectionProvider with the Driver and the ConnectionString.
            </summary>
            <param name="settings">An <see cref="T:System.Collections.IDictionary"/> that contains the settings for this ConnectionProvider.</param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when a <see cref="F:NHibernate.Cfg.Environment.ConnectionString"/> could not be found 
            in the <c>settings</c> parameter or the Driver Class could not be loaded.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.ConfigureDriver(System.Collections.IDictionary)">
            <summary>
            Configures the driver for the ConnectionProvider.
            </summary>
            <param name="settings">An <see cref="T:System.Collections.IDictionary"/> that contains the settings for the Driver.</param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <see cref="F:NHibernate.Cfg.Environment.ConnectionDriver"/> could not be 
            found in the <c>settings</c> parameter or there is a problem with creating
            the <see cref="T:NHibernate.Driver.IDriver"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.GetConnection">
            <summary>
            Get an open <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <returns>An open <see cref="T:System.Data.IDbConnection"/>.</returns>
        </member>
        <member name="F:NHibernate.Connection.ConnectionProvider._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProvider.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this ConnectionProvider is being Disposed of or Finalized.</param>
            <remarks>
            <p>
            If this ConnectionProvider is being Finalized (<c>isDisposing==false</c>) then make 
            sure not to call any methods that could potentially bring this 
            ConnectionProvider back to life.
            </p>
            <p>
            If any subclasses manage resources that also need to be disposed of this method
            should be overridden, but don't forget to call it in the override.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Connection.ConnectionProvider.ConnectionString">
            <summary>
            Gets the <see cref="T:System.String"/> for the <see cref="T:System.Data.IDbConnection"/>
            to connect to the database.
            </summary>
            <value>
            The <see cref="T:System.String"/> for the <see cref="T:System.Data.IDbConnection"/>
            to connect to the database.
            </value>
        </member>
        <member name="P:NHibernate.Connection.ConnectionProvider.Driver">
            <summary>
            Gets the <see cref="T:NHibernate.Driver.IDriver"/> that can create the <see cref="T:System.Data.IDbConnection"/> object.
            </summary>
            <value>
            The <see cref="T:NHibernate.Driver.IDriver"/> that can create the <see cref="T:System.Data.IDbConnection"/>.
            </value>
        </member>
        <member name="T:NHibernate.Connection.ConnectionProviderFactory">
            <summary>
            Instanciates a connection provider given configuration properties.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.ConnectionProviderFactory.NewConnectionProvider(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Connection.DriverConnectionProvider">
            <summary>
            A ConnectionProvider that uses an IDriver to create connections.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.DriverConnectionProvider.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Connection.DriverConnectionProvider"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Connection.DriverConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Closes and Disposes of the <see cref="T:System.Data.IDbConnection"/>.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
        </member>
        <member name="M:NHibernate.Connection.DriverConnectionProvider.GetConnection">
            <summary>
            Gets a new open <see cref="T:System.Data.IDbConnection"/> through 
            the <see cref="T:NHibernate.Driver.IDriver"/>.
            </summary>
            <returns>
            An Open <see cref="T:System.Data.IDbConnection"/>.
            </returns>
            <exception cref="T:NHibernate.ADOException">
            If there is any problem creating or opening the <see cref="T:System.Data.IDbConnection"/>.
            </exception>
        </member>
        <member name="T:NHibernate.Connection.UserSuppliedConnectionProvider">
            <summary>
            An implementation of the <c>IConnectionProvider</c> that simply throws an exception when
            a connection is requested.
            </summary>
            <remarks>
            This implementation indicates that the user is expected to supply an ADO.NET connection
            </remarks>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> if this method is called
            because the user is responsible for closing <see cref="T:System.Data.IDbConnection"/>s.
            </summary>
            <param name="conn">The <see cref="T:System.Data.IDbConnection"/> to clean up.</param>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called.  User is responsible for closing
            <see cref="T:System.Data.IDbConnection"/>s.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.GetConnection">
            <summary>
            Throws an <see cref="T:System.InvalidOperationException"/> if this method is called
            because the user is responsible for creating <see cref="T:System.Data.IDbConnection"/>s.
            </summary>
            <returns>
            No value is returned because an <see cref="T:System.InvalidOperationException"/> is thrown.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called.  User is responsible for creating
            <see cref="T:System.Data.IDbConnection"/>s.
            </exception>
        </member>
        <member name="M:NHibernate.Connection.UserSuppliedConnectionProvider.Configure(System.Collections.IDictionary)">
            <summary>
            Configures the ConnectionProvider with only the Driver class.
            </summary>
            <param name="settings"></param>
            <remarks>
            All other settings of the Connection are the responsibility of the User since they configured
            NHibernate to use a Connection supplied by the User.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.DB2Dialect">
            <summary>
            An SQL dialect for DB2.
            </summary>
            <remarks>
            The DB2Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><c>true</c></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.DB2Driver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Dialect">
            <summary>
            Represents a dialect of SQL implemented by a particular RDBMS. Sublcasses
            implement NHibernate compatibility with different systems.
            </summary>
            <remarks>
            Subclasses should provide a public default constructor that <c>Register()</c>
            a set of type mappings and default Hibernate properties.
            </remarks>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.DefaultBatchSize">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.NoBatch">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.PossibleQuoteChars">
            <summary>
            Characters used for quoting sql identifiers
            </summary>
        </member>
        <member name="F:NHibernate.Dialect.Dialect.PossibleClosedQuoteChars">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.#ctor">
            <summary>
            The base constructor for Dialect.
            </summary>
            <remarks>
            Every subclass should override this and call Register() with every <see cref="T:System.Data.DbType"/> except
            <see cref="F:System.Data.DbType.Object"/>, <see cref="F:System.Data.DbType.SByte"/>, <see cref="F:System.Data.DbType.UInt16"/>, <see cref="F:System.Data.DbType.UInt32"/>, 
            <see cref="F:System.Data.DbType.UInt64"/>, <see cref="F:System.Data.DbType.VarNumeric"/>.
            
            <para>
            The Default properties for this Dialect should also be set - such as whether or not to use outer-joins
            and what the batch size should be.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetTypeName(NHibernate.SqlTypes.SqlType)">
            <summary>
            Get the name of the database type associated with the given 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>,
            </summary>
            <param name="sqlType">The SqlType</param>
            <returns>The database type name used by ddl.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetTypeName(NHibernate.SqlTypes.SqlType,System.Int32)">
            <summary>
            Get the name of the database type associated with the given
            <see cref="T:NHibernate.SqlTypes.SqlType"/>.
            </summary>
            <param name="sqlType">The SqlType </param>
            <param name="length">The length of the SqlType</param>
            <returns>The database type name used by ddl.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterFunction(System.String,NHibernate.Dialect.ISQLFunction)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="function"></param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterColumnType(System.Data.DbType,System.Int32,System.String)">
            <summary>
            Subclasses register a typename for the given type code and maximum
            column length. <c>$1</c> in the type name will be replaced by the column
            length (if appropriate)
            </summary>
            <param name="code">The typecode</param>
            <param name="capacity">Maximum length of database type</param>
            <param name="name">The database type name</param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.RegisterColumnType(System.Data.DbType,System.String)">
            <summary>
            Suclasses register a typename for the given type code. <c>$1</c> in the 
            typename will be replaced by the column length (if appropriate).
            </summary>
            <param name="code">The typecode</param>
            <param name="name">The database type name</param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetAddForeignKeyConstraintString(System.String,System.String[],System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="constraintName"></param>
            <param name="foreignKey"></param>
            <param name="referencedTable"></param>
            <param name="primaryKey"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropForeignKeyConstraintString(System.String)">
            <summary>
            The syntax used to drop a foreign key constraint from a table.
            </summary>
            <param name="constraintName">The name of the foreign key constraint to drop.</param>
            <returns>
            The SQL string to drop the foreign key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetAddPrimaryKeyConstraintString(System.String)">
            <summary>
            The syntax used to add a primary key constraint to a table
            </summary>
            <param name="constraintName"></param>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropPrimaryKeyConstraintString(System.String)">
            <summary>
            The syntax used to drop a primary key constraint from a table.
            </summary>
            <param name="constraintName">The name of the primary key constraint to drop.</param>
            <returns>
            The SQL string to drop the primary key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropIndexConstraintString(System.String)">
            <summary>
            The syntax used to drop an index constraint from a table.
            </summary>
            <param name="constraintName">The name of the index constraint to drop.</param>
            <returns>
            The SQL string to drop the primary key constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.AddIdentitySelectToInsert(NHibernate.SqlCommand.SqlString)">
            <summary>
            Generate SQL to get the identifier of an inserted row.
            If the returned value is not null, the caller will prepare a statement from it,
            set SQL parameters just as it would for insertSQL, and execute it as a query
            which is expected to return the identifier of the inserted row.
            If the returned value is null, the caller will execute insertSQL as an update
            and then execute IdentitySelectString as a query.
            The default implementation (in this class) returns <c>null</c>.
            </summary>
            <param name="insertSql">a parameterized SQL statement to insert a row into a table.</param>
            <returns>a SQL statement that has the same effect as insertSQL
            and also gets the identifier of the inserted row.
            Return <c>null</c> if this dialect doesn't support this feature.
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetSequenceNextValString(System.String)">
            <summary>
            The syntax that fetches the next value of a sequence, if sequences are supported.
            </summary>
            <param name="sequenceName">The name of the sequence</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetCreateSequenceString(System.String)">
            <summary>
            The syntax used to create a sequence, if sequences are supported
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropSequenceString(System.String)">
            <summary>
            The syntax used to drop a sequence, if sequences are supported
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDialect">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDialect(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="props"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.CreateOuterJoinFragment">
            <summary>
            Create an <c>JoinFragment</c> for this dialect
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.CreateCaseFragment">
            <summary>
            Create an <c>CaseFragment</c> for this dialect
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="hasOffset">Offset of the first row is not zero</param>
            <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
            <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="offset">Offset of the first row to be returned by the query (zero-based)</param>
            <param name="limit">Maximum number of rows to be returned by the query</param>
            <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.GetDropTableString(System.String)">
            <summary>
            Return SQL needed to drop the named table. May (and should) use
            some form of "if exists" clause, and cascade constraints.
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.IsQuoted(System.String)">
            <summary>
            Checks to see if the name has been quoted.
            </summary>
            <param name="name">The name to check if it is quoted</param>
            <returns>true if name is already quoted.</returns>
            <remarks>
            The default implementation is to compare the first character
            to Dialect.OpenQuote and the last char to Dialect.CloseQuote
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.UnQuote(System.String)">
            <summary>
            Unquotes and unescapes an already quoted name
            </summary>
            <param name="quoted">Quoted string</param>
            <returns>Unquoted string</returns>
            <remarks>
            <p>
            This method checks the string <c>quoted</c> to see if it is 
            quoted.  If the string <c>quoted</c> is already enclosed in the OpenQuote
            and CloseQuote then those chars are removed.
            </p>
            <p>
            After the OpenQuote and CloseQuote have been cleaned from the string <c>quoted</c>
            then any chars in the string <c>quoted</c> that have been escaped by doubling them
            up are changed back to a single version.
            </p>
            <p>
            The following quoted values return these results
            "quoted" = quoted
            "quote""d" = quote"d
            quote""d = quote"d 
            </p>
            <p>
            If this implementation is not sufficient for your Dialect then it needs to be overridden.
            MsSql2000Dialect is an example of where UnQuoting rules are different.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.UnQuote(System.String[])">
            <summary>
            Unquotes an array of Quoted Names.
            </summary>
            <param name="quoted">strings to Unquote</param>
            <returns>an array of unquoted strings.</returns>
            <remarks>
            This use UnQuote(string) for each string in the quoted array so
            it should not need to be overridden - only UnQuote(string) needs
            to be overridden unless this implementation is not sufficient.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.Quote(System.String)">
            <summary>
            Quotes a name.
            </summary>
            <param name="name">The string that needs to be Quoted.</param>
            <returns>A QuotedName </returns>
            <remarks>
            <p>
            This method assumes that the name is not already Quoted.  So if the name passed
            in is <c>"name</c> then it will return <c>"""name"</c>.  It escapes the first char
            - the " with "" and encloses the escaped string with OpenQuote and CloseQuote. 
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForAliasName(System.String)">
            <summary>
            Quotes a name for being used as a aliasname
            </summary>
            <remarks>Original implementation calls <see cref="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)"/></remarks>
            <param name="aliasName">Name of the alias</param>
            <returns>A Quoted name in the format of OpenQuote + aliasName + CloseQuote</returns>
            <remarks>
            <p>
            If the aliasName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the aliasName that was passed in without going through any
            Quoting process.  So if aliasName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForColumnName(System.String)">
            <summary>
            Quotes a name for being used as a columnname
            </summary>
            <remarks>Original implementation calls <see cref="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)"/></remarks>
            <param name="columnName">Name of the column</param>
            <returns>A Quoted name in the format of OpenQuote + columnName + CloseQuote</returns>
            <remarks>
            <p>
            If the columnName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the columnName that was passed in without going through any
            Quoting process.  So if columnName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForTableName(System.String)">
            <summary>
            Quotes a name for being used as a tablename
            </summary>
            <param name="tableName">Name of the table</param>
            <returns>A Quoted name in the format of OpenQuote + tableName + CloseQuote</returns>
            <remarks>
            <p>
            If the tableName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the tableName that was passed in without going through any
            Quoting process.  So if tableName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.QuoteForSchemaName(System.String)">
            <summary>
            Quotes a name for being used as a schemaname
            </summary>
            <param name="schemaName">Name of the schema</param>
            <returns>A Quoted name in the format of OpenQuote + schemaName + CloseQuote</returns>
            <remarks>
            <p>
            If the schemaName is already enclosed in the OpenQuote and CloseQuote then this 
            method will return the schemaName that was passed in without going through any
            Quoting process.  So if schemaName is passed in already Quoted make sure that 
            you have escaped all of the chars according to your DataBase's specifications.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.HasAlterTable">
            <summary>
            Does this dialect support the <c>ALTER TABLE</c> syntax?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DropConstraints">
            <summary>
            Do we need to drop constraints before dropping tables in the dialect?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.QualifyIndexName">
            <summary>
            Do we need to qualify index names with the schema name?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsForUpdate">
            <summary>
            Does this dialect support the <c>FOR UDPATE</c> syntax?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsForUpdateOf">
            <summary>
            Does this dialect support the <c>FOR UDPATE OF</c> syntax?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsForUpdateNoWait">
            <summary>
            Does this dialect support the Oracle-style <c>FOR UPDATE NOWAIT</c> syntax?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSubSelects">
            <summary>
            Does this dialect support subselects?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsUnique">
            <summary>
            Does this dialect support the <c>UNIQUE</c> column syntax?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.AddColumnString">
            <summary>
            The syntax used to add a column to a table. Note this is deprecated
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.NullColumnString">
            <summary>
            The keyword used to specify a nullable column
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIdentitySelectInInsert">
            <summary>
            Does this Dialect allow adding a Sql String at the end of the 
            INSERT statement to retrieve the new Identity value.
            </summary>
            <value>defaults to false</value>
            <remarks>
            <para>
            If the Dialect supports this then only one Command will need to be executed
            against the Database to do the Insert and get the Id.
            </para>
            <para>
            If this is overridden and returns <c>true</c> then the Dialect
            is expected to override the method <see cref="M:NHibernate.Dialect.Dialect.AddIdentitySelectToInsert(NHibernate.SqlCommand.SqlString)"/>
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIdentityColumns">
            <summary>
            Does this dialect support identity column key generation?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsSequences">
            <summary>
            Does this dialect support sequences?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentitySelectString">
            <summary>
            The syntax that returns the identity value of the last insert, if native
            key generation is supported
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentityColumnString">
            <summary>
            The keyword used to specify an identity column, if native key generation is supported
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.IdentityInsertString">
            <summary>
            The keyword used to insert a generated value into an identity column (or null)
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.NoColumnsInsertString">
            <summary>
            The keyword used to insert a row without specifying any column values
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.DefaultProperties">
            <summary>
            Retrieve a set of default Hibernate properties for this database.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CascadeConstraintsString">
            <summary>
            Completely optional cascading drop clause
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.LowercaseFunction">
            <summary>
            The name of the SQL function that transforms a string to lowercase
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>False, unless overridden.</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsVariableLimit">
            <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.BindLimitParametersInReverseOrder">
            <summary>
            Does the <c>LIMIT</c> clause specify arguments in the "reverse" order
            limit, offset instead of offset, limit?
            </summary>
            <value>False, unless overridden.</value>
            <remarks>Inheritors should return true if the correct order is limit, offset</remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.BindLimitParametersFirst">
            <summary>
            Does the <c>LIMIT</c> clause come at the start of the 
            <c>SELECT</c> statement rather than at the end?
            </summary>
            <value>false, unless overridden</value>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.UseMaxForLimit">
            <summary>
            Does the <c>LIMIT</c> clause take a "maximum" row number
            instead of a total number of returned rows?
            </summary>
            <returns>false, unless overridden</returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.OpenQuote">
            <summary>
            The opening quote for a quoted identifier.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CloseQuote">
            <summary>
            The closing quote for a quoted identifier.
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.Functions">
            <summary>
            Aggregate SQL functions as defined in general.
            </summary>
            <remarks>
            The results of this method should be integrated with the 
            specialization's data.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIfExistsBeforeTableName">
            <summary>
            Does the dialect support the syntax 'drop table if exists NAME'
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.SupportsIfExistsAfterTableName">
            <summary>
            Does the dialect support the syntax 'drop table NAME if exists'
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.MaxAnsiStringSize">
            <summary>
            The largest value that can be set in IDbDataParameter.Size for a parameter
            that contains an AnsiString.
            </summary>
            <remarks>
            <para>
            Currently the only Driver that needs to worry about setting the Param size
            is MsSql
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.MaxBinarySize">
            <summary>
            The largest value that can be set in IDbDataParameter.Size for a parameter
            that contains a DbType.Binary value.
            </summary>
            <remarks>
            <para>
            Currently the only Driver that needs to worry about setting the Param size
            is MsSql
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.MaxBinaryBlobSize">
            <summary>
            The largest value that can be set in IDbDataParameter.Size for a parameter
            that contains a DbType.Binary value that is written to a BLOB column.
            </summary>
            <remarks>
            <para>
            Currently the only Driver that needs to worry about setting the Param size
            is MsSql
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.MaxStringClobSize">
            <summary>
            The largest value that can be set in IDbDataParameter.Size for a parameter
            that contains a Unicode String value that is written to a CLOB column.
            </summary>
            <remarks>
            <para>
            Currently the only Driver that needs to worry about setting the Param size
            is MsSql.  		
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.MaxStringSize">
            <summary>
            The largest value that can be set in IDbDataParameter.Size for a parameter
            that contains an Unicode String value.
            </summary>
            <remarks>
            <para>
            Setting the value to 0 indicates that there is no Maximum Size or that it 
            does not need to be set to Prepare the IDbCommand.
            </para>
            <para>
            Currently the only Driver that needs to worry about setting the Param size
            is MsSql
            </para>
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.Dialect.CountQueryFunctionInfo">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.ISQLFunction">
            <summary>
            Provides support routines for the HQL functions as used
            in the various SQL Dialects
            
            Provides an interface for supporting various HQL functions that are
            translated to SQL. The Dialect and its sub-classes use this interface to
            provide details required for processing of the function.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.ISQLFunction.ReturnType(NHibernate.Type.IType,NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="columnType"></param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.ISQLFunction.HasArguments">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.ISQLFunction.HasParenthesesIfNoArguments">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.CountQueryFunctionInfo.ReturnType(NHibernate.Type.IType,NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="columnType"></param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CountQueryFunctionInfo.HasArguments">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.CountQueryFunctionInfo.HasParenthesesIfNoArguments">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Dialect.AvgQueryFunctionInfo">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Dialect.AvgQueryFunctionInfo.ReturnType(NHibernate.Type.IType,NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="columnType"></param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.AvgQueryFunctionInfo.HasArguments">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.Dialect.AvgQueryFunctionInfo.HasParenthesesIfNoArguments">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetSequenceNextValString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetCreateSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetDropSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.DB2Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            Add a <c>LIMIT</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="hasOffset">Offset of the first row is not zero</param>
            <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.DropConstraints">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.IdentitySelectString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.IdentityInsertString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsSequences">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.BindLimitParametersInReverseOrder">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.DB2Dialect.UseMaxForLimit">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.FirebirdDialect">
            <summary>
            Summary description for FirebirdDialect.
            </summary>
            <remarks>
            The FirebirdDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.FirebirdDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.FirebirdDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.FirebirdDialect.GetSequenceNextValString(System.String)">
            <summary>
            
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.FirebirdDialect.GetCreateSequenceString(System.String)">
            <summary>
            
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.FirebirdDialect.GetDropSequenceString(System.String)">
            <summary>
            
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.FirebirdDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.FirebirdDialect.SupportsSequences">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.GenericDialect">
            <summary>
            A generic SQL dialect which may or may not work on any actual databases
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.GenericDialect.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.GenericDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.MsSql2000Dialect">
            <summary>
            An SQL dialect compatible with Microsoft SQL Server 2000.
            </summary>
            <remarks>
            The MsSql2000Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><c>true</c></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.SqlClientDriver"/></description>
            	</item>
            	<item>
            		<term>hibernate.prepare_sql</term>
            		<description><c>false</c></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.GetDropTableString(System.String)">
            <summary>
            Generates the string to drop the table using the MsSql syntax
            <code>
            if exists (select * from dbo.sysobjects where id = object_id(N'{0}') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
            drop table {0}
            </code>
            </summary>
            <param name="tableName">The name of the table to drop.</param>
            <returns>The SQL with the <c>tableName</c> inserted.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.AddIdentitySelectToInsert(NHibernate.SqlCommand.SqlString)">
            <summary>
            Add the Identity Select string to the Insert Sql.
            </summary>
            <param name="insertSql">The SqlString that contains the INSERT sql.</param>
            <returns>A new SqlString with <c>; SELECT SCOPE_IDENTITY()</c> at the end.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Int32,System.Int32)">
            <summary>
            Add a <c>LIMIT (TOP)</c> clause to the given SQL <c>SELECT</c>
            </summary>
            <param name="querySqlString">A Query in the form of a SqlString.</param>
            <param name="limit">Maximum number of rows to be returned by the query</param>
            <param name="offset">Offset of the first row to process in the result set</param>
            <returns>A new SqlString that contains the <c>LIMIT</c> clause.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.Quote(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
            <remarks>
            MsSql does not require the OpenQuote to be escaped as long as the first char
            is an OpenQuote.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MsSql2000Dialect.UnQuote(System.String)">
            <summary>
            
            </summary>
            <param name="quoted"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.NullColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.QualifyIndexName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsForUpdate">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsIdentitySelectInInsert">
            <summary>
            MsSql allows the use of SELECT SCOPE_IDENTITY to be in the same
            Command as the INSERT
            </summary>
            <value>true</value>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.IdentitySelectString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.NoColumnsInsertString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.MaxAnsiStringSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.MaxBinaryBlobSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.MaxBinarySize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.MaxStringClobSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.MaxStringSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.CloseQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.OpenQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsLimit">
            <summary>
            Does this Dialect have some kind of <c>LIMIT</c> syntax?
            </summary>
            <value>True, we'll use the SELECT TOP nn syntax.</value>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsLimitOffset">
            <summary>
            Does this Dialect support an offset?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.SupportsVariableLimit">
            <summary>
            Can parameters be used for a statement containing a LIMIT?
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.MsSql2000Dialect.UseMaxForLimit">
            <summary>
            Does the <c>LIMIT</c> clause take a "maximum" row number
            instead of a total number of returned rows?
            </summary>
            <returns>false, unless overridden</returns>
        </member>
        <member name="T:NHibernate.Dialect.MsSql7Dialect">
            <summary>
            An SQL dialect compatible with Microsoft SQL Server 7.
            </summary>
            <remarks>
            There have been no test run with this because the NHibernate team does not
            have a machine with Sql 7 installed on it.  But there have been users using
            Ms Sql 7 with NHibernate.  As issues with Ms Sql 7 and NHibernate become known
            this Dialect will be updated.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.MsSql7Dialect.IdentitySelectString">
            <summary>
            Uses @@identity to get the Id value.
            </summary>
            <remarks>
            There is a well known problem with @@identity and triggers that insert into
            rows into other tables that also use an identity column.  The only way I know
            of to get around this problem is to upgrade your database server to Ms Sql 2000.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.MySQLDialect">
            <summary>
            A SQL dialect for MySQL
            </summary>
            <remarks>
            The MySQLDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><c>true</c></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.MySqlDataDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            
            </summary>
            <param name="querySqlString"></param>
            <param name="hasOffset"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetAddForeignKeyConstraintString(System.String,System.String[],System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="constraintName"></param>
            <param name="foreignKey"></param>
            <param name="referencedTable"></param>
            <param name="primaryKey"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropForeignKeyConstraintString(System.String)">
            <summary>
            Create the SQL string to drop a foreign key constraint.
            </summary>
            <param name="constraintName">The name of the foreign key to drop.</param>
            <returns>The SQL string to drop the foreign key constraint.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropPrimaryKeyConstraintString(System.String)">
            <summary>
            Create the SQL string to drop a primary key constraint.
            </summary>
            <param name="constraintName">The name of the primary key to drop.</param>
            <returns>The SQL string to drop the primary key constraint.</returns>
        </member>
        <member name="M:NHibernate.Dialect.MySQLDialect.GetDropIndexConstraintString(System.String)">
            <summary>
            Create the SQL string to drop an index.
            </summary>
            <param name="constraintName">The name of the index to drop.</param>
            <returns>The SQL string to drop the index constraint.</returns>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.QualifyIndexName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.IdentitySelectString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.CloseQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.OpenQuote">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.MySQLDialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.NoArgSQLFunction">
            <summary>
            Summary description for NoArgSQLFunction.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.NoArgSQLFunction.#ctor(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="returnType"></param>
        </member>
        <member name="M:NHibernate.Dialect.NoArgSQLFunction.#ctor(NHibernate.Type.IType,System.Boolean)">
            <summary>
            
            </summary>
            <param name="returnType"></param>
            <param name="hasParenthesesIfNoArguments"></param>
        </member>
        <member name="M:NHibernate.Dialect.NoArgSQLFunction.ReturnType(NHibernate.Type.IType,NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="columnType"></param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.NoArgSQLFunction.HasArguments">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.NoArgSQLFunction.HasParenthesesIfNoArguments">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.Oracle9Dialect">
            <summary>
            It's a immature version, it just work.
            An SQL dialect for Oracle 9
            </summary>
            <remarks>
            The Oracle9Dialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><c>true</c></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.OracleClientDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.GetSequenceNextValString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.GetCreateSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.GetDropSequenceString(System.String)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.Oracle9Dialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            
            </summary>
            <param name="querySqlString"></param>
            <param name="hasOffset">Offset of the first row to process in the result set is non-zero</param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.CascadeConstraintsString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.SupportsForUpdateNoWait">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.SupportsSequences">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.BindLimitParametersInReverseOrder">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.SupportsForUpdateOf">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.Oracle9Dialect.UseMaxForLimit">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.OracleDialect">
            <summary>
            An SQL dialect for Oracle, compatible with Oracle 8.
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.OracleDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.OracleDialect.CreateOuterJoinFragment">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.OracleDialect.CreateCaseFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.PostgreSQL81Dialect">
            <summary>
            An SQL dialect for PostgreSQL 8.1 and above.
            </summary>
            <remarks>
            PostgreSQL 8.1 supports <c>FOR UPDATE ... NOWAIT</c> syntax.
            See <see cref="T:NHibernate.Dialect.PostgreSQLDialect"/> for more information.
            </remarks>
        </member>
        <member name="T:NHibernate.Dialect.PostgreSQLDialect">
            <summary>
            An SQL dialect for PostgreSQL.
            </summary>
            <remarks>
            The PostgreSQLDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><c>true</c></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.NpgsqlDriver"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQLDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQLDialect.GetSequenceNextValString(System.String)">
            <summary>
            
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQLDialect.GetCreateSequenceString(System.String)">
            <summary>
            
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQLDialect.GetDropSequenceString(System.String)">
            <summary>
            
            </summary>
            <param name="sequenceName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Dialect.PostgreSQLDialect.GetLimitString(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            
            </summary>
            <param name="querySqlString"></param>
            <param name="hasOffset">Offset of the first row to process in the result set is non-zero</param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.DropConstraints">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.CascadeConstraintsString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.SupportsSequences">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.SupportsLimit">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.BindLimitParametersInReverseOrder">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.PostgreSQLDialect.SupportsForUpdateOf">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.SQLiteDialect">
            <summary>
            A SQL dialect for SQLite.
            </summary>
            <remarks>
            <p>
            Author: <a href="mailto:ib@stalker.ro"> Ioan Bizau </a>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.SQLiteDialect.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.SQLiteDialect.IdentitySelectString">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.StandardSQLFunction">
            <summary>
            Provides a standard implementation that supports the majority of the HQL
            functions that are translated to SQL.
            </summary>
            <remarks>
            The Dialect and its sub-classes use this class to provide details required
            for processing of the associated function.
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.StandardSQLFunction.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Dialect.StandardSQLFunction.#ctor(NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="typeValue"></param>
        </member>
        <member name="M:NHibernate.Dialect.StandardSQLFunction.ReturnType(NHibernate.Type.IType,NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="columnType"></param>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Dialect.StandardSQLFunction.HasArguments">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Dialect.StandardSQLFunction.HasParenthesesIfNoArguments">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Dialect.SybaseDialect">
            <summary>
            An SQL dialect compatible with Sybase.
            </summary>
            <remarks>
            <p>
            This dialect probably will not work with schema-export.  If anyone out there
            can fill in the ctor with DbTypes to Strings that would be helpful.
            </p>
            The SybaseDialect defaults the following configuration properties:
            <list type="table">
            	<listheader>
            		<term>Property</term>
            		<description>Default Value</description>
            	</listheader>
            	<item>
            		<term>hibernate.use_outer_join</term>
            		<description><c>true</c></description>
            	</item>
            	<item>
            		<term>hibernate.connection.driver_class</term>
            		<description><see cref="T:NHibernate.Driver.SybaseClientDriver"/></description>
            	</item>
            	<item>
            		<term>hibernate.prepare_sql</term>
            		<description><c>false</c></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.SybaseDialect.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Dialect.SybaseDialect.QuoteForAliasName(System.String)">
            <remarks>
            Sybase does not support quoted aliases, this function thus returns
            <c>aliasName</c> as is.
            </remarks>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.AddColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.NullColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.QualifyIndexName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.SupportsForUpdate">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.SupportsIdentityColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.IdentitySelectString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.IdentityColumnString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Dialect.SybaseDialect.NoColumnsInsertString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Dialect.TypeNames">
            <summary>
            This class maps a DbType to names.
            </summary>
            <remarks>
            Associations may be marked with a capacity. Calling the <c>Get()</c>
            method with a type and actual size n will return the associated
            name with smallest capacity >= n, if available and an unmarked
            default type otherwise.
            Eg, setting
            <code>
            	Names.Put(DbType,			"TEXT" );
            	Names.Put(DbType,	255,	"VARCHAR($1)" );
            	Names.Put(DbType,	65534,	"LONGVARCHAR($1)" );
            </code>
            will give you back the following:
            <code>
            	Names.Get(DbType)			// --> "TEXT" (default)
            	Names.Get(DbType,100)		// --> "VARCHAR(100)" (100 is in [0:255])
            	Names.Get(DbType,1000)	// --> "LONGVARCHAR(1000)" (100 is in [256:65534])
            	Names.Get(DbType,100000)	// --> "TEXT" (default)
            </code>
            On the other hand, simply putting
            <code>
            	Names.Put(DbType, "VARCHAR($1)" );
            </code>
            would result in
            <code>
            	Names.Get(DbType)			// --> "VARCHAR($1)" (will cause trouble)
            	Names.Get(DbType,100)		// --> "VARCHAR(100)" 
            	Names.Get(DbType,1000)	// --> "VARCHAR(1000)"
            	Names.Get(DbType,10000)	// --> "VARCHAR(10000)"
            </code>
            </remarks>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="placeholder">String to be replaced by actual size/length in type names</param>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Get(System.Data.DbType)">
            <summary>
            Get default type name for specified type
            </summary>
            <param name="typecode">the type key</param>
            <returns>the default type name associated with the specified key</returns>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Get(System.Data.DbType,System.Int32)">
            <summary>
            Get the type name specified type and size
            </summary>
            <param name="typecode">the type key</param>
            <param name="size">the (maximum) type size/length</param>
            <returns>
            The associated name with smallest capacity >= size if available and the
            default type name otherwise
            </returns>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Put(System.Data.DbType,System.Int32,System.String)">
            <summary>
            Set a type name for specified type key and capacity
            </summary>
            <param name="typecode">the type key</param>
            <param name="capacity">the (maximum) type size/length</param>
            <param name="value">The associated name</param>
        </member>
        <member name="M:NHibernate.Dialect.TypeNames.Put(System.Data.DbType,System.String)">
            <summary>
            
            </summary>
            <param name="typecode"></param>
            <param name="value"></param>
        </member>
        <member name="T:NHibernate.Driver.DB2Driver">
            <summary>
            A NHibernate Driver for using the IBM.Data.DB2 DataProvider.
            </summary>
        </member>
        <member name="T:NHibernate.Driver.DriverBase">
            <summary>
            Base class for the implementation of IDriver
            </summary>
        </member>
        <member name="T:NHibernate.Driver.IDriver">
            <summary>
            A strategy for describing how NHibernate should interact with the different .NET Data
            Providers.
            </summary>
            <remarks>
            <para>
            The <c>IDriver</c> interface is not intended to be exposed to the application.
            Instead it is used internally by Hibernate to obtain connection objects, command objects, and
            to format an IDbCommand's CommandText. Implementors should provide a public default constructor.
            </para>
            <para>
            This is the interface to implement, or you can inherit from <see cref="T:NHibernate.Driver.DriverBase"/> 
            if you have a .NET DataProvider that NHibernate does not have built in support for.
            </para>
            <para>
            For example, there is an Assembly for the ByteFX.Data MySql DataProvider.  
            It is part of the <c>NHibernate.Driver</c> namespace and that is where your
            DataProvider should be placed.  The assembly should start with the name <c>NHibernate.Driver</c>,
            however it does not have to.  The MySql DataProvider is in an assembly called <c>NHibernate.Driver.ByteFX.dll</c>.
            For someone to use it all that needs to be done is in the configuration file for NHibernate this should be
            there.
            </para>
            <code>
            key="hibernate.connection.driver_class"          
            value="FullyQualifiedClassName, AssemblyName" 
            </code>
            <para>
            This is the standard .NET way to load a class from an external assembly.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.IDriver.CreateConnection">
            <summary>
            Creates an uninitialized IDbConnection object for the specific Driver
            </summary>
        </member>
        <member name="M:NHibernate.Driver.IDriver.CreateCommand">
            <summary>
            Creates an empty IDbCommand object for the specific Driver
            </summary>
            <remarks>
            The reason for having this method is that Interfaces in ADO.NET require 
            the use of a IDbCommand.CreateCommand - when we are making the IDbCommand
            objects we might not have a particular connection to create the commands
            from.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.IDriver.FormatNameForSql(System.String)">
            <summary>
            Change the parameterName into the correct format IDbCommand.CommandText
            for the ConnectionProvider
            </summary>
            <param name="parameterName">The unformatted name of the parameter</param>
            <returns>A parameter formatted for an IDbCommand.CommandText</returns>
        </member>
        <member name="M:NHibernate.Driver.IDriver.FormatNameForSql(System.String,System.String)">
            <summary>
            Change the parameterName into the correct format IDbCommand.CommandText
            for the ConnectionProvider
            </summary>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="parameterName">The unformatted name of the parameter</param>
            <returns>A parameter formatted for an IDbCommand.CommandText</returns>
        </member>
        <member name="M:NHibernate.Driver.IDriver.FormatNameForParameter(System.String)">
            <summary>
            Changes the parameterName into the correct format for an IDbParameter
            for the Driver.
            </summary>
            <remarks>
            For SqlServerConnectionProvider it will change <c>id</c> to <c>@id</c>
            </remarks>
            <param name="parameterName">The unformatted name of the parameter</param>
            <returns>A parameter formatted for an IDbParameter.</returns>
        </member>
        <member name="M:NHibernate.Driver.IDriver.FormatNameForParameter(System.String,System.String)">
            <summary>
            Changes the parameterName into the correct format for an IDbParameter
            for the Driver.
            </summary>
            <remarks>
            For SqlServerConnectionProvider it will change <c>id</c> to <c>@id</c>
            </remarks>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="parameterName">The unformatted name of the parameter</param>
            <returns>A parameter formatted for an IDbParameter.</returns>
        </member>
        <member name="M:NHibernate.Driver.IDriver.GenerateCommand(NHibernate.Dialect.Dialect,NHibernate.SqlCommand.SqlString)">
            <summary>
            Generates an IDbCommand from the SqlString according to the requirements of the DataProvider.
            </summary>
            <param name="dialect">The Dialect to help build the IDbCommand</param>
            <param name="sqlString">The SqlString that contains the sql and parameters.</param>
            <returns>An IDbCommand with the CommandText and Parameters fully set.</returns>
        </member>
        <member name="M:NHibernate.Driver.IDriver.GenerateCommand(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates an IDbCommand from the string containing sql according to the requirements 
            of the DataProvider.
            </summary>
            <param name="dialect">The Dialect to help build the IDbCommand</param>
            <param name="sqlString">The string that contains the sql that has NO parameters.</param>
            <returns>An IDbCommand with the CommandText fully set.</returns>
            <remarks>This can not be used to build an IDbCommand that needs to contain Parameters.</remarks>
        </member>
        <member name="P:NHibernate.Driver.IDriver.ConnectionType">
            <summary>
            The Type used to create an IDbConnection
            </summary>
        </member>
        <member name="P:NHibernate.Driver.IDriver.CommandType">
            <summary>
            The Type used to create an IDbCommand
            </summary>
        </member>
        <member name="P:NHibernate.Driver.IDriver.UseNamedPrefixInSql">
            <summary>
            Does this Driver require the use of a Named Prefix in the SQL statement.  
            </summary>
            <remarks>
            For example, SqlClient requires <c>select * from simple where simple_id = @simple_id</c>
            If this is false, like with the OleDb provider, then it is assumed that  
            the <c>?</c> can be a placeholder for the parameter in the SQL statement.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.IDriver.UseNamedPrefixInParameter">
            <summary>
            Does this Driver require the use of the Named Prefix when trying
            to reference the Parameter in the Command's Parameter collection.  
            </summary>
            <remarks>
            This is really only useful when the UseNamedPrefixInSql == true.  When this is true the
            code will look like:
            <code>IDbParameter param = cmd.Parameters["@paramName"]</code>
            if this is false the code will be 
            <code>IDbParameter param = cmd.Parameters["paramName"]</code>.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.IDriver.NamedPrefix">
            <summary>
            The Named Prefix for parameters.  
            </summary>
            <remarks>
            Sql Server uses <c>"@"</c> and Oracle uses <c>":"</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.IDriver.SupportsMultipleOpenReaders">
            <summary>
            Does this Driver support having more than 1 open IDataReader with
            the same IDbConnection.
            </summary>
            <remarks>
            <para>
            A value of <c>false</c> indicates that an exception would be thrown if NHibernate
            attempted to have 2 IDataReaders open using the same IDbConnection.  NHibernate
            (since this version is a close to straight port of Hibernate) relies on the 
            ability to recursively open 2 IDataReaders.  If the Driver does not support it
            then NHibernate will read the values from the IDataReader into an <see cref="T:NHibernate.Driver.NDataReader"/>.
            </para>
            <para>
            A value of <c>true</c> will result in greater performance because an IDataReader can be used
            instead of the <see cref="T:NHibernate.Driver.NDataReader"/>.  So if the Driver supports it then make sure
            it is set to <c>true</c>.
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.IDriver.SupportsPreparingCommands">
            <summary>
            Does this Driver support IDbCommand.Prepare().
            </summary>
            <remarks>
            <para>
            A value of <c>false</c> indicates that an exception would be thrown or the 
            company that produces the Driver we are wrapping does not recommend using
            IDbCommand.Prepare().
            </para>
            <para>
            A value of <c>true</c> indicates that calling IDbCommand.Prepare() will function
            fine on this Driver.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.DriverBase.GenerateParameter(System.Data.IDbCommand,System.String,NHibernate.SqlCommand.Parameter,NHibernate.Dialect.Dialect)">
            <summary>
            Generates an IDbDataParameter for the IDbCommand.  It does not add the IDbDataParameter to the IDbCommand's
            Parameter collection.
            </summary>
            <param name="command">The IDbCommand to use to create the IDbDataParameter.</param>
            <param name="name">The name to set for IDbDataParameter.Name</param>
            <param name="parameter">The Parameter to convert to an IDbDataParameter.</param>
            <param name="dialect">The Dialect to use for Default lengths if needed.</param>
            <returns>An IDbDataParameter ready to be added to an IDbCommand.</returns>
            <remarks>
            Drivers that require Size or Precision/Scale to be set before the IDbCommand is prepared should 
            override this method and use the info contained in the Parameter to set those value.  By default
            those values are not set, only the DbType and ParameterName are set.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.ReflectionBasedDriver.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.ReflectionBasedDriver"/> with
            type names that are loaded from the specified assembly.
            </summary>
            <param name="driverAssemblyName">Assembly to load the types from.</param>
            <param name="connectionTypeName">Connection type name.</param>
            <param name="commandTypeName">Command type name.</param>
        </member>
        <member name="M:NHibernate.Driver.DB2Driver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.DB2Driver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>IBM.Data.DB2</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.FirebirdDriver">
            <summary>
            A NHibernate Driver for using the FirebirdSql.Data.Firebird DataProvider.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.FirebirdDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.FirebirdDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>FirebirdSql.Data.Firebird</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.MySqlDataDriver">
            <summary>
            The MySqlDataDriver Driver provides a database driver for MySql.
            </summary>
            <remarks>
            <p>
            In order to use this Driver you must have the assembly <c>MySql.Data.dll</c> available for 
            NHibernate to load it.  The assembly <c>ICSharpCode.SharpZipLib.dll</c> is also required by
            the assembly <c>MySql.Data.dll</c>.
            </p>
            <p>
            Please check the products website 
            <a href="http://www.mysql.com/products/connector/net/">http://www.mysql.com/products/connector/net/</a>
            for any updates and or documentation.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.MySqlDataDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.MySqlDataDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>MySql.Data assembly</c> can not be loaded.
            </exception>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.UseNamedPrefixInSql">
            <summary>
            MySql.Data uses named parameters in the sql.
            </summary>
            <value><c>true</c> - MySql uses <c>?</c> in the sql.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.NamedPrefix">
            <summary>
            MySql.Data use the <c>?</c> to locate parameters in sql.
            </summary>
            <value><c>?</c> is used to locate parameters in sql.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.SupportsMultipleOpenReaders">
            <summary>
            The MySql.Data driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
            <value><c>false</c> - it is not supported.</value>
        </member>
        <member name="P:NHibernate.Driver.MySqlDataDriver.SupportsPreparingCommands">
            <summary>
            MySql.Data does not support preparing of commands.
            </summary>
            <value><c>false</c> - it is not supported.</value>
            <remarks>
            With the Gamma MySql.Data provider it is throwing an exception with the 
            message "Expected End of data packet" when a select command is prepared.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.NDataReader">
            <summary>
            Some Data Providers (ie - SqlClient) do not support Multiple Active Result Sets (MARS).
            NHibernate relies on being able to create MARS to read Components and entities inside
            of Collections.
            </summary>
            <remarks>
            This is a completely off-line DataReader - the underlying IDataReader that was used to create
            this has been closed and no connections to the Db exists.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Creates a NDataReader from a <see cref="T:System.Data.IDataReader"/>
            </summary>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to get the records from the Database.</param>
            <param name="isMidstream"><c>true</c> if we are loading the <see cref="T:System.Data.IDataReader"/> in the middle of reading it.</param>
            <remarks>
            NHibernate attempts to not have to read the contents of an <see cref="T:System.Data.IDataReader"/> into memory until it absolutely
            has to.  What that means is that it might have processed some records from the <see cref="T:System.Data.IDataReader"/> and will
            pick up the <see cref="T:System.Data.IDataReader"/> midstream so that the underlying <see cref="T:System.Data.IDataReader"/> can be closed 
            so a new one can be opened.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.ClearCache">
            <summary>
            Sets the values that can be cached back to null and sets the 
            index of the cached column to -1
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NextResult">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Close">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Read">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <remarks>
            There are not any unmanaged resources or any disposable managed 
            resources that this class is holding onto.  It is in here
            to comply with the <see cref="T:System.Data.IDataReader"/> interface.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt32(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetValue(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.IsDBNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferOffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetByte(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDecimal(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetValues(System.Object[])">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt64(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDouble(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetBoolean(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetGuid(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDateTime(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetFloat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetData(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferOffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetString(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetChar(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.GetInt16(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.RecordsAffected">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.IsClosed">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Depth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Item(System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.Item(System.Int32)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.FieldCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NDataReader.NResult">
            <summary>
            Stores a Result from a DataReader in memory.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Initializes a new instance of the NResult class.
            </summary>
            <param name="reader">The IDataReader to populate the Result with.</param>
            <param name="isMidstream">
            <c>true</c> if the <see cref="T:System.Data.IDataReader"/> is already positioned on the record
            to start reading from.
            </param>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetFieldCount">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="colName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValue(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="colIndex"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValue(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="colName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NDataReader.NResult.GetValues(System.Int32,System.Object[])">
            <summary>
            
            </summary>
            <param name="rowIndex"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NDataReader.NResult.RowCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NHybridDataReader">
            <summary>
            An implementation of <see cref="T:System.Data.IDataReader"/> that will work with either an 
            <see cref="T:System.Data.IDataReader"/> returned by Execute or with an <see cref="T:System.Data.IDataReader"/>
            whose contents have been read into a <see cref="T:NHibernate.Driver.NDataReader"/>.
            </summary>
            <remarks>
            <para>
            This allows NHibernate to use the underlying <see cref="T:System.Data.IDataReader"/> for as long as
            possible without the need to read everything into the <see cref="T:NHibernate.Driver.NDataReader"/>.
            </para>
            <para>
            The consumer of the <see cref="T:System.Data.IDataReader"/> returned from <see cref="T:NHibernate.Engine.IBatcher"/> does
            not need to know the underlying reader and can use it the same even if it switches from an
            <see cref="T:System.Data.IDataReader"/> to <see cref="T:NHibernate.Driver.NDataReader"/> in the middle of its use.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.#ctor(System.Data.IDataReader)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.NHybridDataReader"/> class.
            </summary>
            <param name="reader">The underlying IDataReader to use.</param>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.#ctor(System.Data.IDataReader,System.Boolean)">
            <summary>
            Initializes a new instance of the NHybridDataReader class.
            </summary>
            <param name="reader">The underlying IDataReader to use.</param>
            <param name="inMemory"><c>true</c> if the contents of the IDataReader should be read into memory right away.</param>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.ReadIntoMemory">
            <summary>
            Reads all of the contents into memory because another <see cref="T:System.Data.IDataReader"/>
            needs to be opened.
            </summary>
            <remarks>
            This will result in a no op if the reader is closed or is already in memory.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.NextResult">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Close">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Read">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetSchemaTable">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Driver.NHybridDataReader._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this NHybridDataReader is being Disposed of or Finalized.</param>
            <remarks>
            If this NHybridDataReader is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this NHybridDataReader back to life.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt32(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetValue(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.IsDBNull(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetBytes(System.Int32,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldOffset"></param>
            <param name="buffer"></param>
            <param name="bufferoffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetByte(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetFieldType(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDecimal(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetValues(System.Object[])">
            <summary>
            
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt64(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDouble(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetBoolean(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetGuid(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDateTime(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetOrdinal(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetDataTypeName(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetFloat(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetData(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetChars(System.Int32,System.Int64,System.Char[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="fieldoffset"></param>
            <param name="buffer"></param>
            <param name="bufferoffset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetString(System.Int32)">
            <summary>
             
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetChar(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Driver.NHybridDataReader.GetInt16(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.IsMidstream">
            <summary>
            Gets if the object is in the middle of reading a Result.
            </summary>
            <value><c>true</c> if NextResult and Read have been called on the <see cref="T:System.Data.IDataReader"/>.</value>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.RecordsAffected">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.IsClosed">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.Depth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.Item(System.String)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.System#Data#IDataRecord#Item(System.Int32)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.NHybridDataReader.FieldCount">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.NpgsqlDriver">
            <summary>
            The PostgreSQL data provider provides a database driver for PostgreSQL.
            <p>
            Author: <a href="mailto:oliver@weichhold.com">Oliver Weichhold</a>
            </p>
            </summary>
            <remarks>
            <p>
            In order to use this Driver you must have the Npgsql.dll Assembly available for 
            NHibernate to load it.
            </p>
            <p>
            Please check the products website 
            <a href="http://www.postgresql.org/">http://www.postgresql.org/</a>
            for any updates and or documentation.
            </p>
            <p>
            The homepage for the .NET DataProvider is: 
            <a href="http://gborg.postgresql.org/project/npgsql/projdisplay.php">http://gborg.postgresql.org/project/npgsql/projdisplay.php</a>. 
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.NpgsqlDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.NpgsqlDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Npgsql</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.OdbcDriver">
            <summary>
            A NHibernate Driver for using the Odbc DataProvider
            </summary>
            <remarks>
            Always look for a native .NET DataProvider before using the Odbc DataProvider.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.OdbcDriver.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.OdbcDriver.CreateConnection">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.OdbcDriver.CreateCommand">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OdbcDriver.CommandType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OdbcDriver.ConnectionType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OdbcDriver.UseNamedPrefixInSql">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OdbcDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OdbcDriver.NamedPrefix">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.OleDbDriver">
            <summary>
            A NHibernate Driver for using the OleDb DataProvider
            </summary>
            <remarks>
            Always look for a native .NET DataProvider before using the OleDb DataProvider.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.OleDbDriver.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.OleDbDriver.CreateConnection">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Driver.OleDbDriver.CreateCommand">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OleDbDriver.CommandType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OleDbDriver.ConnectionType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OleDbDriver.UseNamedPrefixInSql">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OleDbDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OleDbDriver.NamedPrefix">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OleDbDriver.SupportsMultipleOpenReaders">
            <summary>
            OLE DB provider does not support multiple open data readers
            </summary>
        </member>
        <member name="T:NHibernate.Driver.OracleClientDriver">
            <summary>
            A NHibernate Driver for using the Oracle DataProvider.
            </summary>
        </member>
        <member name="T:NHibernate.Driver.OracleDataClientDriver">
            <summary>
            A NHibernate Driver for using the Oracle.DataAccess DataProvider
            </summary>
            <remarks>
            Code was contributed by <a href="http://sourceforge.net/users/jemcalgary/">James Mills</a>
            on the NHibernate forums in this 
            <a href="http://sourceforge.net/forum/message.php?msg_id=2952662">post</a>.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.OracleDataClientDriver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.OracleDataClientDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>Oracle.DataAccess</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="M:NHibernate.Driver.OracleDataClientDriver.GenerateParameter(System.Data.IDbCommand,System.String,NHibernate.SqlCommand.Parameter,NHibernate.Dialect.Dialect)">
            <summary>
            Generates an IDbDataParameter for the IDbCommand.  It does not add the IDbDataParameter to the IDbCommand's
            Parameter collection.
            </summary>
            <param name="command">The IDbCommand to use to create the IDbDataParameter.</param>
            <param name="name">The name to set for IDbDataParameter.Name</param>
            <param name="parameter">The Parameter to convert to an IDbDataParameter.</param>
            <param name="dialect">The Dialect to use for Default lengths if needed.</param>
            <returns>An IDbDataParameter ready to be added to an IDbCommand.</returns>
            <remarks>
            This adds logic to ensure that a DbType.Boolean parameter is not created since
            ODP.NET doesn't support it.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.UseNamedPrefixInSql">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.OracleDataClientDriver.NamedPrefix">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Driver.SqlClientDriver">
            <summary>
            A NHibernate Driver for using the SqlClient DataProvider
            </summary>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SqlClientDriver"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.CreateConnection">
            <summary>
            Creates an uninitialized <see cref="T:System.Data.IDbConnection"/> object for 
            the SqlClientDriver.
            </summary>
            <value>An unitialized <see cref="T:System.Data.SqlClient.SqlConnection"/> object.</value>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.CreateCommand">
            <summary>
            Creates an uninitialized <see cref="T:System.Data.IDbCommand"/> object for 
            the SqlClientDriver.
            </summary>
            <value>An unitialized <see cref="T:System.Data.SqlClient.SqlCommand"/> object.</value>
        </member>
        <member name="M:NHibernate.Driver.SqlClientDriver.GenerateParameter(System.Data.IDbCommand,System.String,NHibernate.SqlCommand.Parameter,NHibernate.Dialect.Dialect)">
            <summary>
            Generates an IDbDataParameter that has values for the Size or Precision/Scale Properties set.
            </summary>
            <param name="command">The IDbCommand to use to create the IDbDataParameter.</param>
            <param name="name">The name to set for IDbDataParameter.Name</param>
            <param name="parameter">The Parameter to convert to an IDbDataParameter.</param>
            <param name="dialect">The Dialect to use for Default lengths if needed.</param>
            <returns>An IDbDataParameter ready to be added to an IDbCommand.</returns>
            <remarks>
            In order to prepare an IDbCommand against an MsSql database all variable length values need
            to be set.
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.CommandType">
            <summary>
            Gets the <see cref="T:System.Type"/> from the System.Data assembly
            that implements <see cref="T:System.Data.IDbCommand"/>
            </summary>
            <value>The <see cref="T:System.Data.SqlClient.SqlCommand"/> type.</value>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.ConnectionType">
            <summary>
            Gets the <see cref="T:System.Type"/> from the System.Data assembly
            that implements <see cref="T:System.Data.IDbConnection"/>
            </summary>
            <value>The <see cref="T:System.Data.SqlClient.SqlConnection"/> type.</value>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.UseNamedPrefixInSql">
            <summary>
            MsSql requires the use of a Named Prefix in the SQL statement.  
            </summary>
            <remarks>
            <c>true</c> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.UseNamedPrefixInParameter">
            <summary>
            MsSql requires the use of a Named Prefix in the Parameter.  
            </summary>
            <remarks>
            <c>true</c> because MsSql uses "<c>@</c>".
            </remarks>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.NamedPrefix">
            <summary>
            The Named Prefix for parameters.  
            </summary>
            <value>
            Sql Server uses <c>"@"</c>.
            </value>
        </member>
        <member name="P:NHibernate.Driver.SqlClientDriver.SupportsMultipleOpenReaders">
            <summary>
            The SqlClient driver does NOT support more than 1 open IDataReader
            with only 1 IDbConnection.
            </summary>
            <value><c>false</c> - it is not supported.</value>
            <remarks>
            Ms Sql 2000 (and 7) throws an Exception when multiple DataReaders are 
            attempted to be Opened.  When Yukon comes out a new Driver will be 
            created for Yukon because it is supposed to support it.
            </remarks>
        </member>
        <member name="T:NHibernate.Driver.SQLiteDriver">
            <summary>
            NHibernate driver for the SQLite.NET data provider.
            <p>
            Author: <a href="mailto:ib@stalker.ro"> Ioan Bizau </a>
            </p>
            </summary>
            <remarks>
            <p>
            In order to use this Driver you must have the SQLite.NET.dll Assembly available for NHibernate to load it.
            You must also have the SQLite.dll and SQLite3.dll libraries.
            </p>
            <p>
            Please check <a href="http://www.sqlite.org/"> http://www.sqlite.org/ </a> for more information regarding SQLite.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.SQLiteDriver.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Driver.SQLiteDriver"/>.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the <c>SQLite.NET</c> assembly can not be loaded.
            </exception>
        </member>
        <member name="T:NHibernate.Driver.SybaseClientDriver">
            <summary>
            The SybaseClientDriver Driver provides a database driver for Sybase.
            </summary>
            <remarks>
            It has been reported to work with the <see cref="T:NHibernate.Dialect.MsSql2000Dialect"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Driver.SybaseClientDriver.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Driver.SybaseClientDriver"/> class.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the Sybase.Data.AseClient assembly can not be loaded.
            </exception>
        </member>
        <member name="P:NHibernate.Driver.SybaseClientDriver.UseNamedPrefixInSql">
            <summary>
            Sybase.Data.AseClient uses named parameters in the sql.
            </summary>
            <value><c>true</c> - Sybase uses <c>@</c> in the sql.</value>
        </member>
        <member name="P:NHibernate.Driver.SybaseClientDriver.UseNamedPrefixInParameter">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Driver.SybaseClientDriver.NamedPrefix">
            <summary>
            Sybase.Data.AseClient use the <c>@</c> to locate parameters in sql.
            </summary>
            <value><c>@</c> is used to locate parameters in sql.</value>
        </member>
        <member name="T:NHibernate.Engine.CascadePoint">
            <summary>
            The types of children to cascade to
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeAfterInsertBeforeDelete">
            <summary>
            A cascade point that occurs just after the insertion of the parent
            entity and just before deletion
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeBeforeInsertAfterDelete">
            <summary>
            A cascade point that occurs just before the insertion of the parent entity
            and just after deletion
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeAfterInsertBeforeDeleteViaCollection">
            <summary>
            A cascade point that occurs just after the insertion of the parent entity
            and just before deletion, inside a collection
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeOnUpdate">
            <summary>
            A cascade point that occurs just after the update of the parent entity
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeOnEvict">
            <summary>
            A cascade point that occurs just after eviction of the parent entity from the
            session cache
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeOnLock">
            <summary>
            A cascade point that occurs just after locking a transient parent entity into the session cache
            </summary>
        </member>
        <member name="F:NHibernate.Engine.CascadePoint.CascadeOnCopy">
            <summary>
            A cascade point that occurs just after copying from a transient parent entity into the object in the session cache
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Cascades">
            <summary>
            Summary description for Cascades.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.Cascade(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType,NHibernate.Engine.Cascades.CascadingAction,NHibernate.Engine.Cascades.CascadeStyle,NHibernate.Engine.CascadePoint,System.Object)">
            <summary>
            Cascade an action to the child or children
            </summary>
            <param name="session"></param>
            <param name="child"></param>
            <param name="type"></param>
            <param name="action"></param>
            <param name="style"></param>
            <param name="cascadeTo"></param>
            <param name="anything"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.Cascade(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.IClassPersister,System.Object,NHibernate.Engine.Cascades.CascadingAction,NHibernate.Engine.CascadePoint)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <param name="parent"></param>
            <param name="action"></param>
            <param name="cascadeTo"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.Cascade(NHibernate.Engine.ISessionImplementor,NHibernate.Persister.IClassPersister,System.Object,NHibernate.Engine.Cascades.CascadingAction,NHibernate.Engine.CascadePoint,System.Object)">
            <summary>
            Cascade an action from the parent object to all its children.
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <param name="parent"></param>
            <param name="action"></param>
            <param name="cascadeTo"></param>
            <param name="anything"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadeCollection(NHibernate.Engine.Cascades.CascadingAction,NHibernate.Engine.Cascades.CascadeStyle,NHibernate.Type.PersistentCollectionType,NHibernate.Type.IType,System.Object,NHibernate.Engine.CascadePoint,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Cascade to the collection elements
            </summary>
            <param name="action"></param>
            <param name="style"></param>
            <param name="collectionType"></param>
            <param name="elemType"></param>
            <param name="child"></param>
            <param name="cascadeVia"></param>
            <param name="session"></param>
            <param name="anything"></param>
        </member>
        <member name="T:NHibernate.Engine.Cascades.CascadingAction">
            <summary>
            A session action that may be cascaded from parent entity to its children
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadingAction.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadingAction.Cascade(NHibernate.Engine.ISessionImplementor,System.Object,System.Object)">
            <summary>
            Cascade the action to the child object
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadingAction.CascadableChildrenCollection(NHibernate.Type.PersistentCollectionType,System.Object)">
            <summary>
            The children to whom we should cascade.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadingAction.DeleteOrphans">
            <summary>
            Do we need to handle orphan delete for this action?
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionDelete">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionLock">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionEvict">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionSaveUpdate">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionCopy">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadingAction.ActionReplicate">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Engine.Cascades.CascadeStyle">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadeStyle.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.CascadeStyle.DoCascade(NHibernate.Engine.Cascades.CascadingAction)">
            <summary>
            Should the given action be cascaded?
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleAllDeleteOrphan">
            <summary>
            Save / Delete / Update / Evict / Lock / Replicate + delete orphans
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleAll">
            <summary>
            Save / Delete / Update / Evict / Lock / Replicate
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleSaveUpdate">
            <summary>
            Save / Update / Lock / Replicate
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleOnlyDelete">
            <summary>
            Delete
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleDeleteOrphan">
            <summary>
            Delete + delete orphans
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.CascadeStyle.StyleNone">
            <summary>
            No Cascades
            </summary>
        </member>
        <member name="P:NHibernate.Engine.Cascades.CascadeStyle.HasOrphanDelete">
            <summary>
            Do we delete orphans automatically?
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Cascades.IdentifierValue">
            <summary>
            A strategy for determining if an identifier value is an identifier of a new 
            transient instance or a previously persistent transient instance. The strategy
            is determined by the <c>Unsaved-Value</c> attribute in the mapping file.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.IdentifierValue.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.IdentifierValue.#ctor(System.Object)">
            <summary>
            Assume the transient instance is newly instantiated if its identifier is null or
            equal to <c>Value</c>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.IdentifierValue.IsUnsaved(System.Object)">
            <summary>
            Does the given identifier belong to a new instance
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.IdentifierValue.SaveAny">
            <summary>
            Always assume the transient instance is newly instantiated
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.IdentifierValue.SaveNone">
            <summary>
            Never assume that transient instance is newly instantiated
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.IdentifierValue.SaveNull">
            <summary>
            Assume the transient instance is newly instantiated if the identifier
            is null.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Cascades.VersionValue">
            <summary>
            A strategy for determining if a version value is an version of
            a new transient instance or a previously persistent transient instance.
            The strategy is determined by the <c>Unsaved-Value</c> attribute in the mapping file.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.VersionValue.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Cascades.VersionValue.#ctor(System.Object)">
            <summary>
            Assume the transient instance is newly instantiated if its version is null or
            equal to <c>Value</c>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Engine.Cascades.VersionValue.IsUnsaved(System.Object)">
            <summary>
            Does the given identifier belong to a new instance
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.VersionValue.VersionSaveNull">
            <summary>
            Assume the transient instance is newly instantiated if the version
            is null, otherwise assume it is a detached instance.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.VersionValue.VersionUndefined">
            <summary>
            Assume the transient instance is newly instantiated if the version
            is null, otherwise defer to the identifier unsaved-value.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.Cascades.VersionValue.VersionNegative">
            <summary>
            Assume the transient instance is newly instantiated if the identifier
            is null.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.IBatcher">
            <summary>
            Manages <see cref="T:System.Data.IDbCommand"/>s and <see cref="T:System.Data.IDataReader"/>s 
            for an <see cref="T:NHibernate.ISession"/>. 
            </summary>
            <remarks>
            <p>
            Abstracts ADO.NET batching to maintain the illusion that a single logical batch 
            exists for the whole session, even when batching is disabled.
            Provides transparent <c>IDbCommand</c> caching.
            </p>
            <p>
            This will be useful once ADO.NET gets support for batching.  Until that point
            no code exists that will do batching, but this will provide a good point to do
            error checking and making sure the correct number of rows were affected.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareQueryCommand(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            Get an <see cref="T:System.Data.IDbCommand"/> for using in loading / querying.
            </summary>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <param name="scrollable">TODO: not sure how to use this yet</param>
            <returns>
            An <see cref="T:System.Data.IDbCommand"/> that is ready to be executed.
            </returns>
            <remarks>
            <p>
            If not explicitly released by <c>CloseQueryStatement()</c>, it will be 
            released when the session is closed or disconnected.
            </p>
            <p>
            This does NOT add anything to the batch - it only creates the IDbCommand and 
            does NOT cause the batch to execute...
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CloseQueryCommand(System.Data.IDbCommand,System.Data.IDataReader)">
            <summary>
            Closes the <see cref="T:System.Data.IDbCommand"/> &amp; the <see cref="T:System.Data.IDataReader"/> that was
            opened with the method <c>PrepareQueryCommand</c>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to close.</param>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to close.</param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareCommand(NHibernate.SqlCommand.SqlString)">
            <summary>
            Get a non-batchable an <see cref="T:System.Data.IDbCommand"/> to use for inserting / deleting / updating.
            Must be explicitly released by <c>CloseCommand()</c>
            </summary>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <returns>
            An <see cref="T:System.Data.IDbCommand"/> that is ready to have the parameter values set
            and then executed.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CloseCommand(System.Data.IDbCommand,System.Data.IDataReader)">
            <summary>
            Close a <see cref="T:System.Data.IDbCommand"/> opened using <c>PrepareCommand()</c>
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to ensure is closed.</param>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to ensure is closed.</param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.PrepareBatchCommand(NHibernate.SqlCommand.SqlString)">
            <summary>
            Get a batchable <see cref="T:System.Data.IDbCommand"/> to use for inserting / deleting / updating
            (might be called many times before a single call to <c>ExecuteBatch()</c>
            </summary>
            <remarks>
            After setting parameters, call <c>AddToBatch()</c> - do not execute the statement
            explicitly.
            </remarks>
            <param name="sql">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to convert to an <see cref="T:System.Data.IDbCommand"/>.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.AddToBatch(System.Int32)">
            <summary>
            Add an insert / delete / update to the current batch (might be called multiple times
            for a single <c>PrepareBatchStatement()</c>)
            </summary>
            <param name="expectedRowCount">The number of rows that should be affected when the query is run.</param>
            <remarks>
            A negative number in expectedRowCount means that you don't know how many rows to 
            expect.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteBatch">
            <summary>
            Execute the batch
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CloseCommands">
            <summary>
            Close any query statements that were left lying around
            </summary>
            <remarks>
            Use this method instead of <c>Dispose</c> if the <see cref="T:NHibernate.Engine.IBatcher"/>
            can be used again.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteReader(System.Data.IDbCommand)">
            <summary>
            Gets an <see cref="T:System.Data.IDataReader"/> by calling ExecuteReader on the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to execute to get the <see cref="T:System.Data.IDataReader"/>.</param>
            <returns>The <see cref="T:System.Data.IDataReader"/> from the <see cref="T:System.Data.IDbCommand"/>.</returns>
            <remarks>
            The Batcher is responsible for ensuring that all of the Drivers rules for how many open
            <see cref="T:System.Data.IDataReader"/>s it can have are followed.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.ExecuteNonQuery(System.Data.IDbCommand)">
            <summary>
            Executes the <see cref="T:System.Data.IDbCommand"/>. 
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to execute.</param>
            <returns>The number of rows affected.</returns>
            <remarks>
            The Batcher is responsible for ensuring that all of the Drivers rules for how many open
            <see cref="T:System.Data.IDataReader"/>s it can have are followed.
            </remarks>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.AbortBatch(System.Exception)">
            <summary>
            Must be called when an exception occurs.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.CancelLastQuery">
            <summary>
            Cancel the current query statement
            </summary>
        </member>
        <member name="M:NHibernate.Engine.IBatcher.Generate(NHibernate.SqlCommand.SqlString)">
            <summary>
            Generates an <see cref="T:System.Data.IDbCommand"/> from a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <param name="sqlString">The <see cref="T:NHibernate.SqlCommand.SqlString"/> to use to generate an <see cref="T:System.Data.IDbCommand"/>.</param>
            <returns>An <see cref="T:System.Data.IDbCommand"/> that is not attached to a Connection or Transaction.</returns>
            <remarks>
            A wrapper for calling the <c>IDriver.GenerateCommand</c> that adds logging.
            </remarks>
        </member>
        <member name="T:NHibernate.Engine.ICollectionSnapshot">
            <summary>
            Defines a complete "snapshot" of a particular collection.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ICollectionSnapshot.SetDirty">
            <summary>
            Marks the <see cref="T:NHibernate.Engine.ICollectionSnapshot"/> as being dirty.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.Key">
            <summary>
            Gets the identifier of the Entity that owns this Collection.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.Role">
            <summary>
            Gets the role that identifies this Collection.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.Snapshot">
            <summary>
            Gets the snapshot copy of the Collection's elements.
            </summary>
            <remarks>
            In most cases this is the same collection type as the one being snapshotted. 
            ie - the snapshot of an IList will return an IList.
            </remarks>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.Dirty">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if some action has been performed on the
            actual collection instance that has modified it.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ICollectionSnapshot.WasDereferenced">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the collection was at one time
            associated with an Entity and then later dereferenced during a Flush().
            </summary>
        </member>
        <member name="T:NHibernate.Engine.ISessionFactoryImplementor">
            <summary>
            Defines the internal contract between the <c>ISessionFactory</c> and other parts of NHibernate
            such as implementors of <c>IType</c>.
            </summary>
        </member>
        <member name="T:NHibernate.ISessionFactory">
            <summary>
            Creates <c>ISession</c>s.
            </summary>
            <remarks>
            <para>
            Usually an application has a single <c>SessionFactory</c>. Threads servicing client requests
            obtain <c>ISession</c>s from the factory. Implementors must be threadsafe.
            </para>
            <para>
            <c>ISessionFactory</c>s are immutable. The behaviour of a <c>SessionFactory</c>
            is controlled by properties supplied at configuration time.
            These properties are defined on <c>Environment</c>
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection)">
            <summary>
            Open a <c>ISession</c> on the given connection
            </summary>
            <param name="conn">A connection provided by the application</param>
            <returns>A session</returns>
            <remarks>
            Note that the second-level cache will be disabled if you
            supply a ADO.NET connection. NHibernate will not be able to track
            any statements you might have executed in the same transaction.
            Consider implementing your own <see cref="T:NHibernate.Connection.IConnectionProvider"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(NHibernate.IInterceptor)">
            <summary>
            Create database connection and open a <c>ISession</c> on it, specifying an interceptor
            </summary>
            <param name="interceptor">A session-scoped interceptor</param>
            <returns>A session</returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession(System.Data.IDbConnection,NHibernate.IInterceptor)">
            <summary>
            Open a <c>ISession</c> on the given connection, specifying an interceptor
            </summary>
            <param name="conn">A connection provided by the application</param>
            <param name="interceptor">A session-scoped interceptor</param>
            <returns>A session</returns>
            <remarks>
            Note that the second-level cache will be disabled if you
            supply a ADO.NET connection. NHibernate will not be able to track
            any statements you might have executed in the same transaction.
            Consider implementing your own <see cref="T:NHibernate.Connection.IConnectionProvider"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenSession">
            <summary>
            Create a database connection and open a <c>ISession</c> on it
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.OpenDatabinder">
            <summary>
            Create a new databinder.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetClassMetadata(System.Type)">
            <summary>
            Get the <c>ClassMetadata</c> associated with the given entity class
            </summary>
            <param name="persistentType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetCollectionMetadata(System.String)">
            <summary>
            Get the <c>CollectionMetadata</c> associated with the named collection role
            </summary>
            <param name="roleName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetAllClassMetadata">
            <summary>
            Get all <c>ClassMetadata</c> as a <c>IDictionary</c> from <c>Type</c>
            to metadata object
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.GetAllCollectionMetadata">
            <summary>
            Get all <c>CollectionMetadata</c> as a <c>IDictionary</c> from role name
            to metadata object
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISessionFactory.Close">
            <summary>
            Destroy this <c>SessionFactory</c> and release all resources 
            connection pools, etc). It is the responsibility of the application
            to ensure that there are no open <c>Session</c>s before calling
            <c>close()</c>. 
            </summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.Evict(System.Type)">
            <summary>
            Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="persistentClass"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.Evict(System.Type,System.Object)">
            <summary>
            Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="persistentClass"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictCollection(System.String)">
            <summary>
            Evict all entries from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="roleName"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictCollection(System.String,System.Object)">
            <summary>
            Evict an entry from the process-level cache.  This method occurs outside
            of any transaction; it performs an immediate "hard" remove, so does not respect
            any transaction isolation semantics of the usage strategy.  Use with care.
            </summary>
            <param name="roleName"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictQueries">
            <summary>
            Evict any query result sets cached in the default query cache region.
            </summary>
        </member>
        <member name="M:NHibernate.ISessionFactory.EvictQueries(System.String)">
            <summary>
            Evict any query result sets cached in the named query cache region.
            </summary>
            <param name="cacheRegion"></param>
        </member>
        <member name="P:NHibernate.ISessionFactory.ConnectionProvider">
            <summary>
            Get the <see cref="T:NHibernate.Connection.IConnectionProvider"/> used.
            </summary>
        </member>
        <member name="P:NHibernate.ISessionFactory.Dialect">
            <summary>
            Get the SQL <c>Dialect</c>
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetPersister(System.Type)">
            <summary>
            Get the persister for a class
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetPersister(System.String)">
            <summary>
            Get the persister for the named class
            </summary>
            <param name="className">The name of the class that is persisted.</param>
            <returns>The <see cref="T:NHibernate.Persister.IClassPersister"/> for the class.</returns>
            <exception cref="T:NHibernate.MappingException">If no <see cref="T:NHibernate.Persister.IClassPersister"/> can be found.</exception>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetPersister(System.String,System.Boolean)">
            <summary>
            Get the persister for the named class
            </summary>
            <param name="className">The name of the class that is persisted.</param>
            <param name="throwIfNotFound">Whether to throw an exception if the class is not found,
            or just return <c>null</c></param>
            <returns>The <see cref="T:NHibernate.Persister.IClassPersister"/> for the class.</returns>
            <exception cref="T:NHibernate.MappingException">If no <see cref="T:NHibernate.Persister.IClassPersister"/> can be found
            and throwIfNotFound is true.</exception>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetCollectionPersister(System.String)">
            <summary>
            Get the persister object for a collection role
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetReturnTypes(System.String)">
            <summary>
            Get the return types of a query
            </summary>
            <param name="queryString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetImplementors(System.Type)">
            <summary>
            Get the names of all persistent classes that implement/extend the given interface/class
            </summary>
            <param name="clazz"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetImportedClassName(System.String)">
            <summary>
            Get a class name, using query language imports
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.GetQueryCache(System.String)">
            <summary>
            Get a particular named query cache, or the default cache
            </summary>
            <param name="regionName">the name of the cache region, or null for the default
            query cache</param>
            <returns>the existing cache, or a newly created cache if none by that
            region name</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.OpenConnection">
            <summary>
            Obtain an ADO.NET connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionFactoryImplementor.CloseConnection(System.Data.IDbConnection)">
            <summary>
            Release an ADO.NET connection
            </summary>
            <param name="conn"></param>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsOuterJoinedFetchEnabled">
            <summary>
            Is outerjoin fetching enabled?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsScrollableResultSetsEnabled">
            <summary>
            Are scrollable <c>ResultSet</c>s supported?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsGetGeneratedKeysEnabled">
            <summary>
            Is <c>PreparedStatement.getGeneratedKeys</c> supported (Java-specific?)
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.DefaultSchema">
            <summary>
            Get the database schema specified in <c>hibernate.default_schema</c>
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.BatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.FetchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.MaximumFetchDepth">
            <summary>
            Maximum depth of outer join fetching
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsShowSqlEnabled">
            <summary>
            Are we logging SQL to the console?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.QueryCache">
            <summary>
            Get the default query cache
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.IsQueryCacheEnabled">
            <summary>
            Is query caching enabled?
            </summary>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.Isolation">
            <summary>
            Gets the IsolationLevel an IDbTransaction should be set to.
            </summary>
            <remarks>
            This is only applicable to manually controlled NHibernate Transactions.
            </remarks>
        </member>
        <member name="P:NHibernate.Engine.ISessionFactoryImplementor.PrepareSql">
            <summary>
            Gets a boolean indicating if the sql statement should be prepared.  The value
            is read from <c>hibernate.prepare_sql</c>.
            </summary>
        </member>
        <member name="T:NHibernate.Engine.ISessionImplementor">
            <summary>
            Defines the internal contract between the <c>Session</c> and other parts of Hibernate
            such as implementors of <c>Type</c> or <c>ClassPersister</c>
            </summary>
        </member>
        <member name="T:NHibernate.ISession">
            <summary>
            The main runtime interface between a Java application and Hibernate. This is the central
            API class abstracting the notion of a persistence service.
            </summary>
            <remarks>
            <para>
            The lifecycle of a <c>ISession</c> is bounded by the beginning and end of a logical
            transaction. (Long transactions might span several database transactions.)
            </para>
            <para>
            The main function of the <c>ISession</c> is to offer create, find and delete operations
            for instances of mapped entity classes. Instances may exist in one of two states:
            <list>
            	<item>transient: not associated with any <c>ISession</c></item>
            	<item>persistent: associated with a <c>ISession</c></item>
            </list>
            </para>
            <para>
            Transient instances may be made persistent by calling <c>Save()</c>, <c>Insert()</c>,
            or <c>Update()</c>. Persistent instances may be made transient by calling <c>Delete()</c>.
            Any instance returned by a <c>Find()</c>, <c>Iterate()</c>, <c>Load()</c>, or <c>Create</c>
            method is persistent.
            </para>
            <para>
            <c>Save()</c> results in an SQL <c>INSERT</c>, <c>Delete()</c>
            in an SQL <c>DELETE</c> and <c>Update()</c> in an SQL <c>UPDATE</c>. Changes to
            <em>persistent</em> instances are deteced at flush time and also result in an SQL
            <c>UPDATE</c>.
            </para>
            <para>
            It is not intended that implementors be threadsafe. Instead each thread/transaction should obtain
            its own instance from an <c>ISessionFactory</c>.
            </para>
            <para>
            A <c>ISession</c> instance is serializable if its persistent classes are serializable
            </para>
            <para>
            A typical transaction should use the following idiom:
            	<code>
            		ISession sess = factory.OpenSession();
            		ITransaction tx;
            		try {
            			tx = sess.BeginTransaction();
            			//do some work
            			...
            			tx.Commit();
            		} catch (Exception e) {
            			if (tx != null) tx.Rollback();
            			throw;
            		} finally {
            			sess.Close();
            		}
            	</code>
            </para>
            <para>
            If the <c>ISession</c> throws an exception, the transaction must be rolled back and the session
            discarded. The internal state of the <c>ISession</c> might not be consistent with the database
            after the exception occurs.
            </para>
            <seealso cref="T:NHibernate.ISessionFactory"/>
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Flush">
            <summary>
            Force the <c>ISession</c> to flush.
            </summary>
            <remarks>
            Must be called at the end of a unit of work, before commiting the transaction and closing
            the session (<c>Transaction.Commit()</c> calls this method). <i>Flushing</i> if the process
            of synchronising the underlying persistent store with persistable state held in memory.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Disconnect">
            <summary>
            Disconnect the <c>ISession</c> from the current ADO.NET connection.
            </summary>
            <remarks>
            If the connection was obtained by Hibernate, close it or return it to the connection
            pool. Otherwise return it to the application. This is used by applications which require
            long transactions.
            </remarks>
            <returns>The connection provided by the application or <c>null</c></returns>
        </member>
        <member name="M:NHibernate.ISession.Reconnect">
            <summary>
            Obtain a new ADO.NET connection.
            </summary>
            <remarks>
            This is used by applications which require long transactions
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.Reconnect(System.Data.IDbConnection)">
            <summary>
            Reconnect to the given ADO.NET connection.
            </summary>
            <remarks>This is used by applications which require long transactions</remarks>
            <param name="connection">An ADO.NET connection</param>
        </member>
        <member name="M:NHibernate.ISession.Close">
            <summary>
            End the <c>ISession</c> by disconnecting from the ADO.NET connection and cleaning up.
            </summary>
            <remarks>
            It is not strickly necessary to <c>Close()</c> the <c>ISession</c> but you must
            at least <c>Disconnect()</c> it.
            </remarks>
            <returns>The connection provided by the application or <c>null</c></returns>
        </member>
        <member name="M:NHibernate.ISession.CancelQuery">
            <summary>
            Cancel execution of the current query.
            </summary>
            <remarks>
            May be called from one thread to stop execution of a query in another thread.
            Use with care!
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.IsDirty">
            <summary>
            Does this <c>ISession</c> contain any changes which must be
            synchronized with the database? Would any SQL be executed if
            we flushed this session?
            </summary>
        </member>
        <member name="M:NHibernate.ISession.GetIdentifier(System.Object)">
            <summary>
            Return the identifier of an entity instance cached by the <c>ISession</c>
            </summary>
            <remarks>
            Throws an exception if the instance is transient or associated with a different
            <c>ISession</c>
            </remarks>
            <param name="obj">a persistent instance</param>
            <returns>the identifier</returns>
        </member>
        <member name="M:NHibernate.ISession.Contains(System.Object)">
            <summary>
            Is this instance associated with this Session?
            </summary>
            <param name="obj">an instance of a persistent class</param>
            <returns>true if the given instance is associated with this Session</returns>
        </member>
        <member name="M:NHibernate.ISession.Evict(System.Object)">
            <summary>
            Remove this instance from the session cache.
            </summary>
            <remarks>
            Changes to the instance will not be synchronized with the database.
            This operation cascades to associated instances if the association is mapped
            with <c>cascade="all"</c> or <c>cascade="all-delete-orphan"</c>.
            </remarks>
            <param name="obj">a persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            obtaining the specified lock mode.
            </summary>
            <param name="theType">A persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <param name="lockMode">The lock level</param>
            <returns>the persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Type,System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier,
            assuming that the instance exists.
            </summary>
            <remarks>
            You should not use this method to determine if an instance exists (use <see cref="M:NHibernate.ISession.Find(System.String)"/>
            instead). Use this only to retrieve an instance that you assume exists, where non-existence
            would be an actual error.
            </remarks>
            <param name="theType">A persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
            <returns>The persistent instance or proxy</returns>
        </member>
        <member name="M:NHibernate.ISession.Load(System.Object,System.Object)">
            <summary>
            Read the persistent state associated with the given identifier into the given transient 
            instance.
            </summary>
            <param name="obj">An "empty" instance of the persistent class</param>
            <param name="id">A valid identifier of an existing persistent instance of the class</param>
        </member>
        <member name="M:NHibernate.ISession.Replicate(System.Object,NHibernate.ReplicationMode)">
            <summary>
            Persist all reachable transient objects, reusing the current identifier 
            values. Note that this will not trigger the Interceptor of the Session.
            </summary>
            <param name="obj"></param>
            <param name="replicationMode"></param>
        </member>
        <member name="M:NHibernate.ISession.Save(System.Object)">
            <summary>
            Persist the given transient instance, first assigning a generated identifier.
            </summary>
            <remarks>
            Save will use the current value of the identifier property if the <c>Assigned</c>
            generator is used.
            </remarks>
            <param name="obj">A transient instance of a persistent class</param>
            <returns>The generated identifier</returns>
        </member>
        <member name="M:NHibernate.ISession.Save(System.Object,System.Object)">
            <summary>
            Persist the given transient instance, using the given identifier.
            </summary>
            <param name="obj">A transient instance of a persistent class</param>
            <param name="id">An unused valid identifier</param>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdate(System.Object)">
            <summary>
            Either <c>Save()</c> or <c>Update()</c> the given instance, depending upon the value of
            its identifier property.
            </summary>
            <remarks>
            By default the instance is always saved. This behaviour may be adjusted by specifying
            an <c>unsaved-value</c> attribute of the identifier property mapping
            </remarks>
            <param name="obj">A transient instance containing new or updated state</param>
        </member>
        <member name="M:NHibernate.ISession.Update(System.Object)">
            <summary>
            Update the persistent instance with the identifier of the given transient instance.
            </summary>
            <remarks>
            If there is a persistent instance with the same identifier, an exception is thrown. If
            the given transient instance has a <c>null</c> identifier, an exception will be thrown.
            </remarks>
            <param name="obj">A transient instance containing updated state</param>
        </member>
        <member name="M:NHibernate.ISession.Update(System.Object,System.Object)">
            <summary>
            Update the persistent state associated with the given identifier.
            </summary>
            <remarks>
            An exception is thrown if there is a persistent instance with the same identifier
            in the current session.
            </remarks>
            <param name="obj">A transient instance containing updated state</param>
            <param name="id">Identifier of persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdateCopy(System.Object)">
            <summary>
            Copy the state of the given object onto the persistent object with the same
            identifier. If there is no persistent instance currently associated with 
            the session, it will be loaded. Return the persistent instance. If the 
            given instance is unsaved or does not exist in the database, save it and 
            return it as a newly persistent instance. Otherwise, the given instance
            does not become associated with the session.
            </summary>
            <param name="obj">a transient instance with state to be copied</param>
            <returns>an updated persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.SaveOrUpdateCopy(System.Object,System.Object)">
            <summary>
            Copy the state of the given object onto the persistent object with the 
            given identifier. If there is no persistent instance currently associated 
            with the session, it will be loaded. Return the persistent instance. If
            there is no database row with the given identifier, save the given instance
            and return it as a newly persistent instance. Otherwise, the given instance
            does not become associated with the session.
            </summary>
            <param name="obj">a persistent or transient instance with state to be copied</param>
            <param name="id">the identifier of the instance to copy to</param>
            <returns>an updated persistent instance</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.Object)">
            <summary>
            Remove a persistent instance from the datastore.
            </summary>
            <remarks>
            The argument may be an instance associated wit hthe receiving <c>ISession</c> or a
            transient instance with an identifier associated with existing persistent state.
            </remarks>
            <param name="obj">The instance to be removed</param>
        </member>
        <member name="M:NHibernate.ISession.Find(System.String)">
            <summary>
            Execute a query
            </summary>
            <param name="query">A query expressed in Hibernate's query language</param>
            <returns>A distinct list of instances</returns>
            <remarks>See <see cref="M:NHibernate.IQuery.List"/> for implications of <c>cache</c> usage.</remarks>
        </member>
        <member name="M:NHibernate.ISession.Find(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Execute a query, binding a value to a "?" parameter in the query string.
            </summary>
            <param name="query">The query string</param>
            <param name="value">A value to be bound to a "?" placeholder</param>
            <param name="type">The Hibernate type of the value</param>
            <returns>A distinct list of instances</returns>
            <remarks>See <see cref="M:NHibernate.IQuery.List"/> for implications of <c>cache</c> usage.</remarks>
        </member>
        <member name="M:NHibernate.ISession.Find(System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Execute a query, binding an array of values to a "?" parameters in the query string.
            </summary>
            <param name="query">The query string</param>
            <param name="values">An array of values to be bound to the "?" placeholders</param>
            <param name="types">An array of Hibernate types of the values</param>
            <returns>A distinct list of instances</returns>
            <remarks>See <see cref="M:NHibernate.IQuery.List"/> for implications of <c>cache</c> usage.</remarks>
        </member>
        <member name="M:NHibernate.ISession.Enumerable(System.String)">
            <summary>
            Execute a query and return the results in an interator.
            </summary>
            <remarks>
            <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
            <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>Find()</c>.
            </para>
            </remarks>
            <param name="query">The query string</param>
            <returns>An enumerator</returns>
        </member>
        <member name="M:NHibernate.ISession.Enumerable(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Execute a query and return the results in an interator, 
            binding a value to a "?" parameter in the query string.
            </summary>
            <remarks>
            <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
            <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>Find()</c>.
            </para>
            </remarks>
            <param name="query">The query string</param>
            <param name="value">A value to be written to a "?" placeholder in the query string</param>
            <param name="type">The hibernate type of the value</param>
            <returns>An enumerator</returns>
        </member>
        <member name="M:NHibernate.ISession.Enumerable(System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Execute a query and return the results in an interator, 
            binding the values to "?"s parameters in the query string.
            </summary>
            <remarks>
            <para>
            If the query has multiple return values, values will be returned in an array of 
            type <c>object[]</c>.
            </para>
            <para>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only. So <c>Enumerator()</c> is usually a less efficient way to retrieve
            object than <c>Find()</c>.
            </para>
            </remarks>
            <param name="query">The query string</param>
            <param name="values">A list of values to be written to "?" placeholders in the query</param>
            <param name="types">A list of hibernate types of the values</param>
            <returns>An enumerator</returns>
        </member>
        <member name="M:NHibernate.ISession.Filter(System.Object,System.String)">
            <summary>
            Apply a filter to a persistent collection.
            </summary>
            <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
            <param name="collection">A persistent collection to filter</param>
            <param name="filter">A filter query string</param>
            <returns>The resulting collection</returns>
        </member>
        <member name="M:NHibernate.ISession.Filter(System.Object,System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Apply a filter to a persistent collection, binding the given parameter to a "?" placeholder
            </summary>
            <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
            <param name="collection">A persistent collection to filter</param>
            <param name="filter">A filter query string</param>
            <param name="value">A value to be written to a "?" placeholder in the query</param>
            <param name="type">The hibernate type of value</param>
            <returns>A collection</returns>
        </member>
        <member name="M:NHibernate.ISession.Filter(System.Object,System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Apply a filter to a persistent collection, binding the given parameters to "?" placeholders.
            </summary>
            <remarks>
            A filter is a Hibernate query that may refer to <c>this</c>, the collection element.
            Filters allow efficient access to very large lazy collections. (Executing the filter
            does not initialize the collection.)
            </remarks>
            <param name="collection">A persistent collection to filter</param>
            <param name="filter">A filter query string</param>
            <param name="values">The values to be written to "?" placeholders in the query</param>
            <param name="types">The hibernate types of the values</param>
            <returns>A collection</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String)">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <returns>Returns the number of objects deleted.</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <param name="value">A value to be written to a "?" placeholer in the query</param>
            <param name="type">The hibernate type of value.</param>
            <returns>The number of instances deleted</returns>
        </member>
        <member name="M:NHibernate.ISession.Delete(System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Delete all objects returned by the query.
            </summary>
            <param name="query">The query string</param>
            <param name="values">A list of values to be written to "?" placeholders in the query</param>
            <param name="types">A list of Hibernate types of the values</param>
            <returns>The number of instances deleted</returns>
        </member>
        <member name="M:NHibernate.ISession.Lock(System.Object,NHibernate.LockMode)">
            <summary>
            Obtain the specified lock level upon the given object.
            </summary>
            <param name="obj">A persistent instance</param>
            <param name="lockMode">The lock level</param>
        </member>
        <member name="M:NHibernate.ISession.Refresh(System.Object)">
            <summary>
            Re-read the state of the given instance from the underlying database.
            </summary>
            <remarks>
            <para>
            It is inadvisable to use this to implement long-running sessions that span many
            business tasks. This method is, however, useful in certain special circumstances.
            </para>
            <para>
            For example,
            <list>
            	<item>Where a database trigger alters the object state upon insert or update</item>
            	<item>After executing direct SQL (eg. a mass update) in the same session</item>
            	<item>After inserting a <c>Blob</c> or <c>Clob</c></item>
            </list>
            </para>
            </remarks>
            <param name="obj">A persistent instance</param>
        </member>
        <member name="M:NHibernate.ISession.Refresh(System.Object,NHibernate.LockMode)">
            <summary>
            Re-read the state of the given instance from the underlying database, with
            the given <c>LockMode</c>.
            </summary>
            <remarks>
            It is inadvisable to use this to implement long-running sessions that span many
            business tasks. This method is, however, useful in certain special circumstances.
            </remarks>
            <param name="obj">a persistent or transient instance</param>
            <param name="lockMode">the lock mode to use</param>
        </member>
        <member name="M:NHibernate.ISession.GetCurrentLockMode(System.Object)">
            <summary>
            Determine the current lock mode of the given object
            </summary>
            <param name="obj">A persistent instance</param>
            <returns>The current lock mode</returns>
        </member>
        <member name="M:NHibernate.ISession.BeginTransaction">
            <summary>
            Begin a unit of work and return the associated <c>ITransaction</c> object.
            </summary>
            <remarks>
            If a new underlying transaction is required, begin the transaction. Otherwise
            continue the new work in the context of the existing underlying transaction.
            The class of the returned <c>Trasnsaction</c> object is determined by the property
            <c>hibernate.transaction_factory</c>
            </remarks>
            <returns>A transaction instance</returns>
        </member>
        <member name="M:NHibernate.ISession.BeginTransaction(System.Data.IsolationLevel)">
            <summary>
            Begin a transaction with the specified <c>isolationLevel</c>
            </summary>
            <param name="isolationLevel">Isolation level for the new transaction</param>
            <returns>A transaction instance having the specified isolation level</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateCriteria(System.Type)">
            <summary>
            Creates a new <c>Criteria</c> for the entity class.
            </summary>
            <param name="persistentClass">The class to Query</param>
            <returns>An ICriteria object</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateQuery(System.String)">
            <summary>
            Create a new instance of <c>Query</c> for the given query string
            </summary>
            <param name="queryString">A hibernate query string</param>
            <returns>The query</returns>
        </member>
        <member name="M:NHibernate.ISession.CreateFilter(System.Object,System.String)">
            <summary>
            Create a new instance of <c>Query</c> for the given collection and filter string
            </summary>
            <param name="collection">A persistent collection</param>
            <param name="queryString">A hibernate query</param>
            <returns>A query</returns>
        </member>
        <member name="M:NHibernate.ISession.GetNamedQuery(System.String)">
            <summary>
            Obtain an instance of <see cref="T:NHibernate.IQuery"/> for a named query string defined in the
            mapping file.
            </summary>
            <param name="queryName">The name of a query defined externally.</param>
            <returns>An <see cref="T:NHibernate.IQuery"/> fro a named query string.</returns>
            <remarks>
            The query can be either in <c>hql</c> or <c>sql</c> format.
            </remarks>
        </member>
        <member name="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String,System.Type)">
            <summary>
            Create a new instance of <c>IQuery</c> for the given SQL string.
            </summary>
            <param name="sql">a query expressed in SQL</param>
            <param name="returnAlias">a table alias that appears inside <c>{}</c> in the SQL string</param>
            <param name="returnClass">the returned persistent class</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISession.CreateSQLQuery(System.String,System.String[],System.Type[])">
            <summary>
            Create a new instance of <see cref="T:NHibernate.IQuery"/> for the given SQL string.
            </summary>
            <param name="sql">a query expressed in SQL</param>
            <param name="returnAliases">an array of table aliases that appear inside <c>{}</c> in the SQL string</param>
            <param name="returnClasses">the returned persistent classes</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ISession.Clear">
            <summary>
            Completely clear the session. Evict all loaded instances and cancel all pending
            saves, updates and deletions. Do not close open enumerables or instances of
            <c>ScrollableResults</c>.
            </summary>
        </member>
        <member name="M:NHibernate.ISession.Get(System.Type,System.Object)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier, or null
            if there is no such persistent instance. (If the instance, or a proxy for the instance, is
            already associated with the session, return that instance or proxy.)
            </summary>
            <param name="clazz">a persistent class</param>
            <param name="id">an identifier</param>
            <returns>a persistent instance or null</returns>
        </member>
        <member name="M:NHibernate.ISession.Get(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Return the persistent instance of the given entity class with the given identifier, or null
            if there is no such persistent instance. Obtain the specified lock mode if the instance
            exists.
            </summary>
            <param name="clazz">a persistent class</param>
            <param name="id">an identifier</param>
            <param name="lockMode">the lock mode</param>
            <returns>a persistent instance or null</returns>
        </member>
        <member name="P:NHibernate.ISession.FlushMode">
            <summary>
            Determines at which points Hibernate automatically flushes the session.
            </summary>
            <remarks>
            For a readonly session, it is reasonable to set the flush mode to <c>FlushMode.Never</c>
            at the start of the session (in order to achieve some extra performance).
            </remarks>
        </member>
        <member name="P:NHibernate.ISession.SessionFactory">
            <summary>
            Get the <see cref="T:NHibernate.ISessionFactory"/> that created this instance.
            </summary>
        </member>
        <member name="P:NHibernate.ISession.Connection">
            <summary>
            Gets the ADO.NET connection.
            </summary>
            <remarks>
            Applications are responsible for calling commit/rollback upon the connection before
            closing the <c>ISession</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.ISession.IsOpen">
            <summary>
            Is the <c>ISession</c> still open?
            </summary>
        </member>
        <member name="P:NHibernate.ISession.IsConnected">
            <summary>
            Is the <c>ISession</c> currently connected?
            </summary>
        </member>
        <member name="P:NHibernate.ISession.Transaction">
            <summary>
            Get the current Unit of Work and return the associated <c>ITransaction</c> object.
            </summary>
            <exception cref="T:NHibernate.HibernateException">There was no Active IDbTransaction for this Session</exception>
            TODO: DESIGNQUESTION: We might have it return null to indicate there is no Transaction for this Session
            instead of throwing an Exception because that would allow other methods to just do null checks instead 
            of error checking...
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetLoadedCollectionKey(NHibernate.Collection.PersistentCollection)">
            <summary>
            Get the pre-flush identifier of the collection
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetSnapshot(NHibernate.Collection.PersistentCollection)">
            <summary>
            Get the snapshot of the pre-flush collection state
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetArrayHolder(System.Object)">
            <summary>
            Get the <c>PersistentCollection</c> object for an array
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AddArrayHolder(NHibernate.Collection.ArrayHolder)">
            <summary>
            Register a <c>PersistentCollection</c> object for an array
            </summary>
            <param name="holder"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InitializeCollection(NHibernate.Collection.PersistentCollection,System.Boolean)">
            <summary>
            Initialize the collection (if not already initialized)
            </summary>
            <param name="coolection"></param>
            <param name="writing"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.IsInverseCollection(NHibernate.Collection.PersistentCollection)">
            <summary>
            Is this the "inverse" end of a bidirectional association?
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetLoadingCollection(NHibernate.Collection.ICollectionPersister,System.Object,System.Object)">
            <summary>
            new in h2.1 and no javadoc
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="resultSetId"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.EndLoadingCollections(NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            new in h2.1 and no javadoc
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AfterLoad">
            <summary>
            new in h2.1 and no javadoc
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.BeforeLoad">
            <summary>
            new in h2.1 and no javadoc
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InitializeNonLazyCollections">
            <summary>
            new in h2.1 and no javadoc
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetCollection(System.String,System.Object,System.Object)">
            <summary>
            Gets the NHibernate collection wrapper from the ISession.
            </summary>
            <param name="role"></param>
            <param name="id"></param>
            <param name="owner"></param>
            <returns>
            A NHibernate wrapped collection.
            </returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InternalLoad(System.Type,System.Object)">
            <summary>
            Load an instance without checking if it was deleted. If it does not exist, throw an exception.
            This method may create a new proxy or return an existing proxy.
            </summary>
            <param name="persistentClass">The <see cref="T:System.Type"/> to load.</param>
            <param name="id">The identifier of the object in the database.</param>
            <returns>
            A proxy of the object or an instance of the object if the <c>persistentClass</c> does not have a proxy.
            </returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">No object could be found with that <c>id</c>.</exception>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InternalLoadOneToOne(System.Type,System.Object)">
            <summary>
            Load an instance without checking if it was deleted. If it does not exist, 
            return <c>null</c>. Do not create a proxy (but do return any existing proxy).
            </summary>
            <param name="persistentClass"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ImmediateLoad(System.Type,System.Object)">
            <summary>
            Load an instance immediately. Do not return a proxy.
            </summary>
            <param name="persistentClass"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.LoadByUniqueKey(System.Type,System.String,System.Object)">
            <summary>
            Load an instance by a unique key that is not the primary key.
            </summary>
            <param name="persistentClass"></param>
            <param name="uniqueKeyPropertyName"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.PostInsert(System.Object)">
            <summary>
            After actually inserting a row, record the fact that the instance exists on the database
            (needed for identity-column key generation)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.PostDelete(System.Object)">
            <summary>
            After actually deleting a row, record the fact that the instance no longer exists on the
            database (needed for identity-column key generation)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.PostUpdate(System.Object,System.Object[],System.Object)">
            <summary>
            After actually updating a row, record the fact that the database state has been updated.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> instance that was saved.</param>
            <param name="updatedState">A updated snapshot of the values in the object.</param>
            <param name="nextVersion">The new version to assign to the <c>obj</c>.</param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Find(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a <c>Find()</c> query
            </summary>
            <param name="query"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Enumerable(System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute an <c>Iterate()</c> query
            </summary>
            <param name="query"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Filter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Execute a filter
            </summary>
            <param name="collection"></param>
            <param name="filter"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.EnumerableFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            Collection from a filter
            </summary>
            <param name="collection"></param>
            <param name="filter"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetPersister(System.Object)">
            <summary>
            Get the <c>IClassPersister</c> for an object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AddUninitializedEntity(NHibernate.Engine.Key,System.Object,NHibernate.LockMode)">
            <summary>
            Add an uninitialized instance of an entity class, as a placeholder to ensure object identity.
            Must be called before <c>PostHydrate()</c>
            </summary>
            <param name="key"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.PostHydrate(NHibernate.Persister.IClassPersister,System.Object,System.Object[],System.Object,NHibernate.LockMode)">
            <summary>
            Register the "hydrated" state of an entity instance, after the first step of 2-phase loading
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="values"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.InitializeEntity(System.Object)">
            <summary>
            Perform the second step of 2-phase load (ie. fully initialize the entity instance)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntity(NHibernate.Engine.Key)">
            <summary>
            Get the entity instance associated with the given <c>Key</c>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ProxyFor(NHibernate.Persister.IClassPersister,NHibernate.Engine.Key,System.Object)">
            <summary>
            Return the existing proxy associated with the given <c>Key</c>, or the second
            argument (the entity associated with the key) if no proxy exists.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> to see if it should be Proxied.</param>
            <param name="key">The <see cref="T:NHibernate.Engine.Key"/> that identifies the entity.</param>
            <param name="impl"></param>
            <returns>Returns a the Proxy for the class or the parameter impl.</returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ProxyFor(System.Object)">
            <summary>
            Return the existing proxy associated with the given object. (Slower than the form above)
            </summary>
            <param name="impl"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AfterTransactionCompletion(System.Boolean)">
            <summary>
            Notify the session that the transaction completed, so we no longer own the old locks.
            (Also we shold release cache softlocks). May be called multiple times during the transaction
            completion process.
            </summary>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityIdentifier(System.Object)">
            <summary>
            Return the identifier of the persistent object, or null if transient
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetEntityIdentifierIfNotUnsaved(System.Object)">
            <summary>
            Return the identifer of the persistent or transient object, or throw
            an exception if the instance is "unsaved"
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.IsSaved(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Instantiate(System.Type,System.Object)">
            <summary>
            Instantiate the entity class, initializing with the given identifier
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.SetLockMode(System.Object,NHibernate.LockMode)">
            <summary>
            Set the lock mode of the entity to the given lock mode
            </summary>
            <param name="entity"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetVersion(System.Object)">
            <summary>
            Get the current version of the entity
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetLockMode(System.Object)">
            <summary>
            Get the lock mode of the entity
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetOrphans(NHibernate.Collection.PersistentCollection)">
            <summary>
            Get the collection orphans (entities which were removed from
            the collection
            </summary>
            <param name="coll"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetCollectionBatch(NHibernate.Collection.ICollectionPersister,System.Object,System.Int32)">
            <summary>
            Get a batch of uninitialized collection keys for this role
            </summary>
            <param name="collectionPersister"></param>
            <param name="id"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetClassBatch(System.Type,System.Object,System.Int32)">
            <summary>
            Get a batch of unloaded identifiers for this class
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.ScheduleBatchLoad(System.Type,System.Object)">
            <summary>
            Register the entity as batch loadable, if enabled
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.FindBySQL(System.String,System.String[],System.Type[],NHibernate.Engine.QueryParameters,System.Collections.ICollection)">
            <summary>
            Execute an SQL Query
            </summary>
            <param name="sqlQuery"></param>
            <param name="aliases"></param>
            <param name="classes"></param>
            <param name="queryParameters"></param>
            <param name="querySpaces"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.AddNonExist(NHibernate.Engine.Key)">
            <summary>
            new in 2.1 no javadoc
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.Copy(System.Object,System.Collections.IDictionary)">
            <summary>
            new in 2.1 no javadoc
            </summary>
            <param name="obj"></param>
            <param name="copiedAlready"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.ISessionImplementor.GetCollectionOwner(System.Object,NHibernate.Collection.ICollectionPersister)">
            <summary>
            new in 2.1 no javadoc
            </summary>
            <param name="key"></param>
            <param name="collectionPersister"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Timestamp">
            <summary>
            System time before the start of the transaction
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Factory">
            <summary>
            Get the creating SessionFactoryImplementor
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Engine.ISessionImplementor.Batcher">
            <summary>
            Get the prepared statement <c>Batcher</c> for this session
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Key">
            <summary>
            A globally unique identifier of an instance, consisting of the user-visible identifier
            and the identifier space (eg. tablename)
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Key.#ctor(System.Object,NHibernate.Persister.IClassPersister)">
            <summary>
            Construct a unique identifier for an entity class instace
            </summary>
            <param name="id"></param>
            <param name="p"></param>
        </member>
        <member name="M:NHibernate.Engine.Key.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Engine.Key.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.Key.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Engine.Key.Identifier">
            <summary>
            The user-visible identifier
            </summary>
        </member>
        <member name="P:NHibernate.Engine.Key.MappedClass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Engine.Key.IsBatchLoadable">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Engine.QueryParameters">
            <summary>
            Container for data that is used during the NHibernate query/load process. 
            </summary>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.#ctor(NHibernate.Type.IType[],System.Object[])">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Engine.QueryParameters"/> class.
            </summary>
            <param name="positionalParameterTypes">An array of <see cref="T:NHibernate.Type.IType"/> objects for the parameters.</param>
            <param name="positionalParameterValues">An array of <see cref="T:System.Object"/> objects for the parameters.</param>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.#ctor(NHibernate.Type.IType[],System.Object[],System.Collections.IDictionary,NHibernate.Engine.RowSelection)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Engine.QueryParameters"/> class.
            </summary>
            <param name="positionalParameterTypes">An array of <see cref="T:NHibernate.Type.IType"/> objects for the parameters.</param>
            <param name="positionalParameterValues">An array of <see cref="T:System.Object"/> objects for the parameters.</param>
            <param name="lockModes">An <see cref="T:System.Collections.IDictionary"/> that is hql alias keyed to a LockMode value.</param>
            <param name="rowSelection"></param>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.#ctor(NHibernate.Type.IType[],System.Object[],System.Collections.IDictionary,System.Collections.IDictionary,NHibernate.Engine.RowSelection,System.Boolean,System.String,System.Boolean)">
            <summary>
            Initializes an instance of the <see cref="T:NHibernate.Engine.QueryParameters"/> class.
            </summary>
            <param name="positionalParameterTypes">An array of <see cref="T:NHibernate.Type.IType"/> objects for the parameters.</param>
            <param name="positionalParameterValues">An array of <see cref="T:System.Object"/> objects for the parameters.</param>
            <param name="namedParameters">An <see cref="T:System.Collections.IDictionary"/> that is <c>parameter name</c> keyed to a <see cref="T:NHibernate.Engine.TypedValue"/> value.</param>
            <param name="lockModes">An <see cref="T:System.Collections.IDictionary"/> that is <c>hql alias</c> keyed to a LockMode value.</param>
            <param name="rowSelection"></param>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.LogParameters(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.QueryParameters.ValidateParameters">
            <summary>
            Ensure the Types and Values are the same length.
            </summary>
            <exception cref="T:NHibernate.QueryException">
            If the Lengths of <see cref="P:NHibernate.Engine.QueryParameters.PositionalParameterTypes"/> and 
            <see cref="P:NHibernate.Engine.QueryParameters.PositionalParameterValues"/> are not equal.
            </exception>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.HasRowSelection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.NamedParameters">
            <summary>
            Gets or sets an <see cref="T:System.Collections.IDictionary"/> that contains the named 
            parameter as the key and the <see cref="T:NHibernate.Engine.TypedValue"/> as the value.
            </summary>
            <value>An <see cref="T:System.Collections.IDictionary"/> of named parameters.</value>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.PositionalParameterTypes">
            <summary>
            Gets or sets an array of <see cref="T:NHibernate.Type.IType"/> objects that is stored at the index 
            of the Parameter.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.PositionalParameterValues">
            <summary>
            Gets or sets an array of <see cref="T:System.Object"/> objects that is stored at the index 
            of the Parameter.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.RowSelection">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Engine.QueryParameters.RowSelection"/> for the Query.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.QueryParameters.LockModes">
            <summary>
            Gets or sets an <see cref="T:System.Collections.IDictionary"/> that contains the alias name of the
            object from hql as the key and the <see cref="T:NHibernate.LockMode"/> as the value.
            </summary>
            <value>An <see cref="T:System.Collections.IDictionary"/> of lock modes.</value>
        </member>
        <member name="T:NHibernate.Engine.RowSelection">
            <summary>
            Information to determine how to run an IDbCommand and what
            records to return from the IDataReader.
            </summary>
        </member>
        <member name="F:NHibernate.Engine.RowSelection.NoValue">
            <summary>
            Indicates that the no value has been set on the Property.
            </summary>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.FirstRow">
            <summary>
            Gets or Sets the Index of the First Row to Select
            </summary>
            <value>The Index of the First Rows to Select</value>
            <remarks>Defaults to 0 unless specifically set.</remarks>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.MaxRows">
            <summary>
            Gets or Sets the Maximum Number of Rows to Select
            </summary>
            <value>The Maximum Number of Rows to Select</value>
            <remarks>Defaults to NoValue unless specifically set.</remarks>
        </member>
        <member name="P:NHibernate.Engine.RowSelection.Timeout">
            <summary>
            Gets or Sets the Timeout of the Query
            </summary>
            <value>The Query Timeout</value>
            <remarks>Defaults to NoValue unless specifically set.</remarks>
        </member>
        <member name="T:NHibernate.Engine.TypedValue">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.TypedValue.#ctor(NHibernate.Type.IType,System.Object)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="value"></param>
        </member>
        <member name="P:NHibernate.Engine.TypedValue.Value">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Engine.TypedValue.Type">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Engine.UnsavedValueFactory.GetUnsavedIdentifierValue(System.String,NHibernate.Property.IGetter,NHibernate.Type.IType,System.Reflection.ConstructorInfo)">
            <summary>
            Return an IdentifierValue for the specified unsaved-value. If none is specified,
            guess the unsaved value by instantiating a test instance of the class and
            reading it's id property, or if that is not possible, using the java default
            value for the type
            </summary>
        </member>
        <member name="T:NHibernate.Engine.Versioning">
            <summary>
            Utility methods for managing versions and timestamps
            </summary>
        </member>
        <member name="M:NHibernate.Engine.Versioning.Increment(System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Increment the given version number
            </summary>
            <param name="version">The value of the current version.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <returns>Returns the next value for the version.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.Seed(NHibernate.Type.IVersionType)">
            <summary>
            Create an initial version number
            </summary>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <returns>A seed value to initialize the versioned property with.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.SeedVersion(System.Object[],System.Int32,NHibernate.Type.IVersionType,System.Boolean)">
            <summary>
            Seed the given instance state snapshot with an initial version number
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="versionProperty">The index of the version property in the <c>fields</c> parameter.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <param name="force">Force the version to initialize</param>
            <returns><c>true</c> if the version property needs to be seeded with an initial value.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.GetVersion(System.Object[],System.Int32,NHibernate.Type.IVersionType)">
            <summary>
            Gets the value of the version.
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="versionProperty">The index of the version property in the <c>fields</c> parameter.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
            <returns>The value of the version.</returns>
        </member>
        <member name="M:NHibernate.Engine.Versioning.SetVersion(System.Object[],System.Object,System.Int32,NHibernate.Type.IVersionType)">
            <summary>
            Sets the value of the version.
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="version">The value the version should be set to in the <c>fields</c> parameter.</param>
            <param name="versionProperty">The index of the version property in the <c>fields</c> parameter.</param>
            <param name="versionType">The <see cref="T:NHibernate.Type.IVersionType"/> of the versioned property.</param>
        </member>
        <member name="M:NHibernate.Engine.Versioning.SetVersion(System.Object[],System.Object,NHibernate.Persister.IClassPersister)">
            <summary>
            Set the version number of the given instance state snapshot
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="version">The value the version should be set to in the <c>fields</c> parameter.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for persisting the values of the <c>fields</c> parameter.</param>
        </member>
        <member name="M:NHibernate.Engine.Versioning.GetVersion(System.Object[],NHibernate.Persister.IClassPersister)">
            <summary>
            Get the version number of the given instance state snapshot
            </summary>
            <param name="fields">An array of objects that contains a snapshot of a persistent object.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for persisting the values of the <c>fields</c> parameter.</param>
            <returns>
            The value of the version contained in the <c>fields</c> parameter or null if the
            Entity is not versioned.
            </returns>
        </member>
        <member name="M:NHibernate.Exceptions.ADOExceptionHelper.Convert(System.Exception,System.String)">
            <summary>
            Converts the given SQLException into NHibernate's ADOException hierarchy, as well as performing
            appropriate logging.
            </summary>
            <!--<param name="converter">The converter to use.</param>-->
            <param name="sqlException">The exception to convert.</param>
            <param name="message">An optional error message.</param>
            <returns>The converted ADOException.</returns>
        </member>
        <member name="T:NHibernate.Expression.AbstractCriterion">
            <summary>
            Base class for <see cref="T:NHibernate.Expression.ICriterion"/> implementations.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.ICriterion">
            <summary>
            An object-oriented representation of a query criterion that may be used as a constraint
            in a <see cref="T:NHibernate.ICriteria"/> query.
            </summary>
            <remarks>
            Built-in criterion types are provided by the <c>Expression</c> factory class.
            This interface might be implemented by application classes but, more commonly, application 
            criterion types would extend <c>AbstractCriterion</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.ICriterion.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            Render a SqlString fragment for the expression.
            </summary>
            <param name="sessionFactory">The ISessionFactory that contains the mapping for the Type.</param>
            <param name="persistentClass">The Class the Expression is being built for.</param>
            <param name="alias">The alias to use for the table.</param>
            <param name="aliasClasses"></param>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="M:NHibernate.Expression.ICriterion.GetTypedValues(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.Collections.IDictionary)">
            <summary>
            Return typed values for all parameters in the rendered SQL fragment
            </summary>
            <param name="sessionFactory">The ISessionFactory that contains the mapping for the Type.</param>
            <param name="persistentClass">The Class the Expression is being built for.</param>
            <returns>An array of TypedValues for the Expression.</returns>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.ToString">
            <summary>
            Gets a string representation of the <see cref="T:NHibernate.Expression.AbstractCriterion"/>.  
            </summary>
            <returns>
            A String that shows the contents of the <see cref="T:NHibernate.Expression.AbstractCriterion"/>.
            </returns>
            <remarks>
            This is not a well formed Sql fragment.  It is useful for logging what the <see cref="T:NHibernate.Expression.AbstractCriterion"/>
            looks like.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.GetType(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            Get the a typed value for the given property value.
            </summary>
            <param name="factory"></param>
            <param name="persistentClass"></param>
            <param name="property"></param>
            <param name="aliasClasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.GetTypedValue(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Object,System.Collections.IDictionary)">
            <summary>
            Get the <see cref="T:NHibernate.Engine.TypedValue"/> for the given property value.
            </summary>
            <param name="factory"></param>
            <param name="persistentClass"></param>
            <param name="property"></param>
            <param name="value"></param>
            <param name="aliasClasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            Render a SqlString for the expression.
            </summary>
            <param name="factory">The ISessionFactory that contains the mapping for the Type.</param>
            <param name="persistentClass">The Class the Expression is being built for.</param>
            <param name="alias">The alias to use for the table.</param>
            <param name="aliasClasses"></param>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="M:NHibernate.Expression.AbstractCriterion.GetTypedValues(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.Collections.IDictionary)">
            <summary>
            Return typed values for all parameters in the rendered SQL fragment
            </summary>
            <param name="sessionFactory">The ISessionFactory that contains the mapping for the Type.</param>
            <param name="persistentClass">The Class the Expression is being built for.</param>
            <param name="aliasClasses"></param>
            <returns>An array of TypedValues for the Expression.</returns>
        </member>
        <member name="T:NHibernate.Expression.AndExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.LogicalExpression"/> that combines two <see cref="T:NHibernate.Expression.ICriterion"/>s 
            with an <c>and</c> between them.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.LogicalExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that combines two <see cref="T:NHibernate.Expression.ICriterion"/>s 
            with a operator (either "<c>and</c>" or "<c>or</c>") between them.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LogicalExpression.#ctor(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.LogicalExpression"/> class that
            combines two other <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use in the Left Hand Side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use in the Right Hand Side.</param>
        </member>
        <member name="M:NHibernate.Expression.LogicalExpression.GetTypedValues(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.Collections.IDictionary)">
            <summary>
            Combines the <see cref="T:NHibernate.Engine.TypedValue"/> for the Left Hand Side and the 
            Right Hand Side of the Expression into one array.
            </summary>
            <param name="sessionFactory">The ISessionFactory to get the Persistence information from.</param>
            <param name="persistentClass">The Type we are constructing the Expression for.</param>
            <returns>An arry of <see cref="T:NHibernate.Engine.TypedValue"/>s.</returns>
        </member>
        <member name="M:NHibernate.Expression.LogicalExpression.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            Converts the LogicalExpression to a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <param name="factory">The ISessionFactory to use to build the SqlString.</param>
            <param name="persistentClass">The Type we are constructing the Expression for.</param>
            <param name="alias">The alias to use when referencing the table.</param>
            <returns>A well formed SqlString for the Where clause.</returns>
            <remarks>The SqlString will be enclosed by <c>(</c> and <c>)</c>.</remarks>
        </member>
        <member name="M:NHibernate.Expression.LogicalExpression.ToString">
            <summary>
            Gets a string representation of the LogicalExpression.  
            </summary>
            <returns>
            The String contains the LeftHandSide.ToString() and the RightHandSide.ToString()
            joined by the Op.
            </returns>
            <remarks>
            This is not a well formed Sql fragment.  It is useful for logging what Expressions
            are being combined.
            </remarks>
        </member>
        <member name="P:NHibernate.Expression.LogicalExpression.LeftHandSide">
            <summary>
            Gets the <see cref="T:NHibernate.Expression.ICriterion"/> that will be on the Left Hand Side of the Op.
            </summary>
        </member>
        <member name="P:NHibernate.Expression.LogicalExpression.RightHandSide">
            <summary>
            Gets the <see cref="T:NHibernate.Expression.ICriterion"/> that will be on the Right Hand Side of the Op.
            </summary>
        </member>
        <member name="P:NHibernate.Expression.LogicalExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Expression.Expression"/>s.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.AndExpression.#ctor(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.AndExpression"/> class
            that combines two <see cref="T:NHibernate.Expression.ICriterion"/>.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use as the left hand side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.AndExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <value>The string "<c>and</c>"</value>
        </member>
        <member name="T:NHibernate.Expression.BetweenExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents a "between" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.BetweenExpression.#ctor(System.String,System.Object,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.BetweenExpression"/> class for
            the named Property.
            </summary>
            <param name="propertyName">The name of the Property of the Class.</param>
            <param name="lo">The low value for the BetweenExpression.</param>
            <param name="hi">The high value for the BetweenExpression.</param>
        </member>
        <member name="M:NHibernate.Expression.BetweenExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.Conjunction">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that Junctions together multiple 
            <see cref="T:NHibernate.Expression.ICriterion"/>s with an <c>and</c>
            </summary>
        </member>
        <member name="T:NHibernate.Expression.Junction">
            <summary>
            A sequence of logical <see cref="T:NHibernate.Expression.ICriterion"/>s combined by some associative
            logical operator.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Junction.Add(NHibernate.Expression.ICriterion)">
            <summary>
            Adds an <see cref="T:NHibernate.Expression.ICriterion"/> to the list of <see cref="T:NHibernate.Expression.ICriterion"/>s
            to junction together.
            </summary>
            <param name="criterion">The <see cref="T:NHibernate.Expression.ICriterion"/> to add.</param>
            <returns>
            This <see cref="T:NHibernate.Expression.Junction"/> instance.
            </returns>
        </member>
        <member name="P:NHibernate.Expression.Junction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
        </member>
        <member name="P:NHibernate.Expression.Conjunction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <value>The string "<c> and </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.Disjunction">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that Junctions together multiple 
            <see cref="T:NHibernate.Expression.ICriterion"/>s with an <c>or</c>
            </summary>
        </member>
        <member name="P:NHibernate.Expression.Disjunction.Op">
            <summary>
            Get the Sql operator to put between multiple <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <value>The string "<c> or </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.EqExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "equal" constraint.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.SimpleExpression">
            <summary>
            The base class for an <see cref="T:NHibernate.Expression.ICriterion"/> that compares a single Property
            to a value.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.SimpleExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.SimpleExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Expression.SimpleExpression.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            Converts the SimpleExpression to a <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </summary>
            <param name="factory">The ISessionFactory that contains the mapping for the Type.</param>
            <param name="persistentClass">The Class the Expression is being built for.</param>
            <param name="alias">The alias to use for the table.</param>
            <returns>A SqlString that contains a valid Sql fragment.</returns>
        </member>
        <member name="M:NHibernate.Expression.SimpleExpression.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Expression.SimpleExpression.PropertyName">
            <summary>
            Gets the named Property for the Expression.
            </summary>
            <value>A string that is the name of the Property.</value>
        </member>
        <member name="P:NHibernate.Expression.SimpleExpression.Value">
            <summary>
            Gets the Value for the Expression.
            </summary>
            <value>An object that is the value for the Expression.</value>
        </member>
        <member name="P:NHibernate.Expression.SimpleExpression.Op">
            <summary>
            Get the Sql operator to use for the specific 
            subclass of <see cref="T:NHibernate.Expression.SimpleExpression"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.EqExpression.#ctor(System.String,System.Object,System.Boolean)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.EqExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <param name="ignoreCase">Use case-insensitive comparison</param>
        </member>
        <member name="M:NHibernate.Expression.EqExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.EqExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.EqExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.EqExpression"/>.
            </summary>
            <value>The string "<c> = </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.EqPropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "equal" constraint 
            between two properties.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.PropertyExpression">
            <summary>
            Superclass for an <see cref="T:NHibernate.Expression.ICriterion"/> that represents a
            constraint between two properties (with SQL binary operators).
            </summary>
        </member>
        <member name="M:NHibernate.Expression.PropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.PropertyExpression"/> class 
            that compares two mapped properties.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="M:NHibernate.Expression.PropertyExpression.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="factory"></param>
            <param name="persistentClass"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.PropertyExpression.GetTypedValues(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="sessionFactory"></param>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.PropertyExpression.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Expression.PropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the property expression.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.EqPropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.EqPropertyExpression"/> class
            that compares two mapped properties using an "equal" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.EqPropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.EqPropertyExpression"/>.
            </summary>
            <value>The string "<c> = </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.Example">
            <summary>
            Support for <c>Query By Example</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Example.SetPropertySelector(NHibernate.Expression.Example.IPropertySelector)">
            <summary>
            Set the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Expression.Example"/>.
            </summary>
            <param name="selector">The <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> to determine which properties to include.</param>
            <returns>This <see cref="T:NHibernate.Expression.Example"/> instance.</returns>
            <remarks>
            This should be used when a custom <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> has
            been implemented.  Otherwise use the methods <see cref="M:NHibernate.Expression.Example.ExcludeNulls"/> 
            or <see cref="M:NHibernate.Expression.Example.ExcludeNone"/> to set the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/>
            to the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/>s built into NHibernate.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.Example.ExcludeZeroes">
            <summary>
            Set the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Expression.Example"/>
            to exclude zero-valued properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Example.ExcludeNone">
            <summary>
            Set the <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> for this <see cref="T:NHibernate.Expression.Example"/>
            to exclude no properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Example.EnableLike(NHibernate.Expression.MatchMode)">
            <summary>
            Use the "like" operator for all string-valued properties with
            the specified <see cref="T:NHibernate.Expression.MatchMode"/>.
            </summary>
            <param name="matchMode">
            The <see cref="T:NHibernate.Expression.MatchMode"/> to convert the string to the pattern
            for the <c>like</c> comparison.
            </param>
        </member>
        <member name="M:NHibernate.Expression.Example.EnableLike">
            <summary>
            Use the "like" operator for all string-valued properties.
            </summary>
            <remarks>
            The default <see cref="T:NHibernate.Expression.MatchMode"/> is <see cref="F:NHibernate.Expression.MatchMode.Exact">MatchMode.Exact</see>.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.Example.ExcludeProperty(System.String)">
            <summary>
            Exclude a particular named property
            </summary>
            <param name="name">The name of the property to exclude.</param>
        </member>
        <member name="M:NHibernate.Expression.Example.Create(System.Object)">
            <summary>
            Create a new instance, which includes all non-null properties 
            by default
            </summary>
            <param name="entity"></param>
            <returns>A new instance of <see cref="T:NHibernate.Expression.Example"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Example.#ctor(System.Object,NHibernate.Expression.Example.IPropertySelector)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.Example"/> class for a particular
            entity.
            </summary>
            <param name="entity">The <see cref="T:System.Object"/> that the Example is being built from.</param>
            <param name="selector">The <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> the Example should use.</param>
        </member>
        <member name="M:NHibernate.Expression.Example.IsPropertyIncluded(System.Object,System.String,NHibernate.Type.IType)">
            <summary>
            Determines if the property should be included in the Query.
            </summary>
            <param name="value">The value of the property.</param>
            <param name="name">The name of the property.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the property.</param>
            <returns>
            <c>true</c> if the Property should be included, <c>false</c> if
            the Property should not be a part of the Query.
            </returns>
        </member>
        <member name="M:NHibernate.Expression.Example.AddPropertyTypedValue(System.Object,NHibernate.Type.IType,System.Collections.IList)">
            <summary>
            Adds a <see cref="T:NHibernate.Engine.TypedValue"/> based on the <c>value</c> 
            and <c>type</c> parameters to the <see cref="T:System.Collections.IList"/> in the
            <c>list</c> parameter.
            </summary>
            <param name="value">The value of the Property.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the Property.</param>
            <param name="list">The <see cref="T:System.Collections.IList"/> to add the <see cref="T:NHibernate.Engine.TypedValue"/> to.</param>
            <remarks>
            This method will add <see cref="T:NHibernate.Engine.TypedValue"/> objects to the <c>list</c> parameter.
            </remarks>
        </member>
        <member name="T:NHibernate.Expression.Example.IPropertySelector">
            <summary>
            A strategy for choosing property values for inclusion in the query criteria
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Example.IPropertySelector.Include(System.Object,System.String,NHibernate.Type.IType)">
            <summary>
            Determine if the Property should be included.
            </summary>
            <param name="propertyValue">The value of the property that is being checked for inclusion.</param>
            <param name="propertyName">The name of the property that is being checked for inclusion.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> of the property.</param>
            <returns>
            <c>true</c> if the Property should be included in the Query, 
            <c>false</c> otherwise.
            </returns>
        </member>
        <member name="T:NHibernate.Expression.Example.AllPropertySelector">
            <summary>
            Implementation of <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> that includes all
            properties regardless of value.
            </summary>
        </member>
        <member name="T:NHibernate.Expression.Example.NotNullOrEmptyStringPropertySelector">
            <summary>
            Implementation of <see cref="T:NHibernate.Expression.Example.IPropertySelector"/> that includes the
            properties that are not <c>null</c> and do not have an <see cref="F:System.String.Empty"/>
            returned by <c>propertyValue.ToString()</c>.
            </summary>
            <remarks>
            This selector is not present in H2.1. It may be useful if nullable types
            are used for some properties.
            </remarks>
        </member>
        <member name="T:NHibernate.Expression.Expression">
            <summary>
            The <c>Expression</c> namespace may be used by applications as a framework for building 
            new kinds of <see cref="T:NHibernate.Expression.ICriterion"/>. However, it is intended that most applications will 
            simply use the built-in criterion types via the static factory methods of this class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Expression.Eq(System.String,System.Object)">
            <summary>
            Apply an "equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>An <see cref="T:NHibernate.Expression.EqExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Like(System.String,System.Object)">
            <summary>
            Apply a "like" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.LikeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.InsensitiveLike(System.String,System.Object)">
            <summary>
            A case-insensitive "like", similar to Postgres "ilike" operator
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>An <see cref="T:NHibernate.Expression.InsensitiveLikeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Gt(System.String,System.Object)">
            <summary>
            Apply a "greater than" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.GtExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Lt(System.String,System.Object)">
            <summary>
            Apply a "less than" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.LtExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Le(System.String,System.Object)">
            <summary>
            Apply a "less than or equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.LeExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Ge(System.String,System.Object)">
            <summary>
            Apply a "greater than or equal" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.GtExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Between(System.String,System.Object,System.Object)">
            <summary>
            Apply a "between" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="lo">The low value for the Property.</param>
            <param name="hi">The high value for the Property.</param>
            <returns>A <see cref="T:NHibernate.Expression.BetweenExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.In(System.String,System.Object[])">
            <summary>
            Apply an "in" constraint to the named property 
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="values">An array of values.</param>
            <returns>An <see cref="T:NHibernate.Expression.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.In(System.String,System.Collections.ICollection)">
            <summary>
            Apply an "in" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="values">An ICollection of values.</param>
            <returns>An <see cref="T:NHibernate.Expression.InExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.IsNull(System.String)">
            <summary>
            Apply an "is null" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Expression.NullExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.EqProperty(System.String,System.String)">
            <summary>
            Apply an "equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.EqPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.LtProperty(System.String,System.String)">
            <summary>
            Apply a "less than" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.LtPropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.LeProperty(System.String,System.String)">
            <summary>
            Apply a "less than or equal" constraint to two properties
            </summary>
            <param name="propertyName">The lhs Property Name</param>
            <param name="otherPropertyName">The rhs Property Name</param>
            <returns>A <see cref="T:NHibernate.Expression.LePropertyExpression"/> .</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.IsNotNull(System.String)">
            <summary>
            Apply an "is not null" constraint to the named property
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <returns>A <see cref="T:NHibernate.Expression.NotNullExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.And(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Return the conjuction of two expressions
            </summary>
            <param name="lhs">The Expression to use as the Left Hand Side.</param>
            <param name="rhs">The Expression to use as the Right Hand Side.</param>
            <returns>An <see cref="T:NHibernate.Expression.AndExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Or(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Return the disjuction of two expressions
            </summary>
            <param name="lhs">The Expression to use as the Left Hand Side.</param>
            <param name="rhs">The Expression to use as the Right Hand Side.</param>
            <returns>An <see cref="T:NHibernate.Expression.OrExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Not(NHibernate.Expression.ICriterion)">
            <summary>
            Return the negation of an expression
            </summary>
            <param name="expression">The Expression to negate.</param>
            <returns>A <see cref="T:NHibernate.Expression.NotExpression"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(NHibernate.SqlCommand.SqlString,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Apply a constraint expressed in SQL, with the given SQL parameters
            </summary>
            <param name="sql"></param>
            <param name="values"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(NHibernate.SqlCommand.SqlString,System.Object,NHibernate.Type.IType)">
            <summary>
            Apply a constraint expressed in SQL, with the given SQL parameter
            </summary>
            <param name="sql"></param>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(NHibernate.SqlCommand.SqlString)">
            <summary>
            Apply a constraint expressed in SQL
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Sql(System.String)">
            <summary>
            Apply a constraint expressed in SQL
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Expression.Conjunction">
            <summary>
            Group expressions together in a single conjunction (A and B and C...)
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Expression.Disjunction">
            <summary>
            Group expressions together in a single disjunction (A or B or C...)
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Expression.AllEq(System.Collections.IDictionary)">
            <summary>
            Apply an "equals" constraint to each property in the key set of a IDictionary
            </summary>
            <param name="propertyNameValues">a dictionary from property names to values</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Expression.GeExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "greater than or equal" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.GeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.GeExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.GeExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.GeExpression"/>.
            </summary>
            <value>The string "<c> &gt;= </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.GtExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "greater than" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.GtExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.GtExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.GtExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.GtExpression"/>.
            </summary>
            <value>The string "<c> &gt; </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.InExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that constrains the property 
            to a specified list of values.
            </summary>
            <remarks>
            InExpression - should only be used with a Single Value column - no multicolumn properties...
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.InExpression.#ctor(System.String,System.Object[])">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Expression.InExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.InsensitiveLikeExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "like" constraint
            that is <b>not</b> case sensitive.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.InsensitiveLikeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.InsensitiveLikeExpression"/> 
            class for a named Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="M:NHibernate.Expression.InsensitiveLikeExpression.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="factory"></param>
            <param name="persistentClass"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.InsensitiveLikeExpression.GetTypedValues(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="sessionFactory"></param>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.InsensitiveLikeExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.LeExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "less than or equal" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.LeExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.LeExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LeExpression"/>.
            </summary>
            <value>The string "<c> &lt;= </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.LePropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "less than or equal" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LePropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.LePropertyExpression"/> class
            that compares two mapped properties using an "less than or equal" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.LePropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LePropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt;= </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.LikeExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "like" constraint.
            </summary>
            <remarks>
            The case sensitivity depends on the database settings for string 
            comparisons.  Use <see cref="T:NHibernate.Expression.InsensitiveLikeExpression"/> if the
            string comparison should not be case sensitive.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.LikeExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.LikeExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.LikeExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LikeExpression"/>.
            </summary>
            <value>The string "<c> like </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.LtExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "less than" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LtExpression.#ctor(System.String,System.Object)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.LtExpression"/> class for a named
            Property and its value.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
            <param name="value">The value for the Property.</param>
        </member>
        <member name="P:NHibernate.Expression.LtExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LtExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.LtPropertyExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents an "less than" constraint 
            between two properties.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.LtPropertyExpression.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Expression.LtPropertyExpression"/> class
            that compares two mapped properties using an "less than" constraint.
            </summary>
            <param name="lhsPropertyName">The name of the Property to use as the left hand side.</param>
            <param name="rhsPropertyName">The name of the Property to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.LtPropertyExpression.Op">
            <summary>
            Get the Sql operator to use for the <see cref="T:NHibernate.Expression.LtPropertyExpression"/>.
            </summary>
            <value>The string "<c> &lt; </c>"</value>
        </member>
        <member name="T:NHibernate.Expression.MatchMode">
            <summary>
            Represents an strategy for matching strings using "like".
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.#ctor(System.Int32,System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode"/> class.
            </summary>
            <param name="intCode">The code that identifies the match mode.</param>
            <param name="name">The friendly name of the match mode.</param>
            <remarks>
            The parameter <c>intCode</c> is used as the key of <see cref="T:System.Collections.IDictionary"/>
            to store instances and to ensure only instance of a particular <see cref="T:NHibernate.Expression.MatchMode"/>
            is created.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.ToString">
            <summary>
            The string representation of the <see cref="T:NHibernate.Expression.MatchMode"/>.
            </summary>
            <returns>The friendly name used to describe the <see cref="T:NHibernate.Expression.MatchMode"/>.</returns>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.ToMatchString(System.String)">
            <summary>
            Convert the pattern, by appending/prepending "%"
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>
            A <see cref="T:System.String"/> that contains a "%" in the appropriate place
            for the Match Strategy.
            </returns>
        </member>
        <member name="F:NHibernate.Expression.MatchMode.Exact">
            <summary>
            Match the entire string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Expression.MatchMode.Start">
            <summary>
            Match the start of the string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Expression.MatchMode.End">
            <summary>
            Match the end of the string to the pattern
            </summary>
        </member>
        <member name="F:NHibernate.Expression.MatchMode.Anywhere">
            <summary>
            Match the pattern anywhere in the string
            </summary>
        </member>
        <member name="T:NHibernate.Expression.MatchMode.ExactMatchMode">
            <summary>
            The <see cref="T:NHibernate.Expression.MatchMode"/> that matches the entire string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.ExactMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode.ExactMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.ExactMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Exact MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> exactly the same as it was passed in.</returns>
        </member>
        <member name="T:NHibernate.Expression.MatchMode.StartMatchMode">
            <summary>
            The <see cref="T:NHibernate.Expression.MatchMode"/> that matches the start of the string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.StartMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode.StartMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.StartMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Start MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the end.</returns>
        </member>
        <member name="T:NHibernate.Expression.MatchMode.EndMatchMode">
            <summary>
            The <see cref="T:NHibernate.Expression.MatchMode"/> that matches the end of the string to the pattern.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.EndMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode.EndMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.EndMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the End MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the beginning.</returns>
        </member>
        <member name="T:NHibernate.Expression.MatchMode.AnywhereMatchMode">
            <summary>
            The <see cref="T:NHibernate.Expression.MatchMode"/> that exactly matches the string
            by appending "<c>%</c>" to the beginning and end.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.AnywhereMatchMode.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.MatchMode.AnywhereMatchMode"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.MatchMode.AnywhereMatchMode.ToMatchString(System.String)">
            <summary>
            Converts the string to the Exact MatchMode.
            </summary>
            <param name="pattern">The string to convert to the appropriate match pattern.</param>
            <returns>The <c>pattern</c> with a "<c>%</c>" appended at the beginning and the end.</returns>
        </member>
        <member name="T:NHibernate.Expression.NotExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that negates another <see cref="T:NHibernate.Expression.ICriterion"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.NotExpression.#ctor(NHibernate.Expression.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.NotExpression"/> class for an
            <see cref="T:NHibernate.Expression.ICriterion"/>
            </summary>
            <param name="criterion">The <see cref="T:NHibernate.Expression.ICriterion"/> to negate.</param>
        </member>
        <member name="M:NHibernate.Expression.NotExpression.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="factory"></param>
            <param name="persistentClass"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.NotExpression.GetTypedValues(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="sessionFactory"></param>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.NotExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.NotNullExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents "not null" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.NotNullExpression.#ctor(System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.NotNullExpression"/> class for a named
            Property that should not be null.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
        </member>
        <member name="T:NHibernate.Expression.NullExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that represents "null" constraint.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.NullExpression.#ctor(System.String)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.NotNullExpression"/> class for a named
            Property that should be null.
            </summary>
            <param name="propertyName">The name of the Property in the class.</param>
        </member>
        <member name="M:NHibernate.Expression.NullExpression.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="factory"></param>
            <param name="persistentClass"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.NullExpression.GetTypedValues(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="sessionFactory"></param>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.NullExpression.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Expression.Order">
            <summary>
            Represents an order imposed upon a <see cref="T:NHibernate.ICriteria"/>
            result set.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.Order.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor for Order.
            </summary>
            <param name="propertyName"></param>
            <param name="ascending"></param>
        </member>
        <member name="M:NHibernate.Expression.Order.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String)">
            <summary>
            Render the SQL fragment
            </summary>
            <param name="sessionFactory"></param>
            <param name="persistentClass"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Order.Asc(System.String)">
            <summary>
            Ascending order
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.Order.Desc(System.String)">
            <summary>
            Descending order
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Expression.OrExpression">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that combines two <see cref="T:NHibernate.Expression.ICriterion"/>s with an 
            <c>"or"</c> between them.
            </summary>
        </member>
        <member name="M:NHibernate.Expression.OrExpression.#ctor(NHibernate.Expression.ICriterion,NHibernate.Expression.ICriterion)">
            <summary>
            Initialize a new instance of the <see cref="T:NHibernate.Expression.OrExpression"/> class for 
            two <see cref="T:NHibernate.Expression.ICriterion"/>s.
            </summary>
            <param name="lhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use as the left hand side.</param>
            <param name="rhs">The <see cref="T:NHibernate.Expression.ICriterion"/> to use as the right hand side.</param>
        </member>
        <member name="P:NHibernate.Expression.OrExpression.Op">
            <summary>
            Get the Sql operator to put between the two <see cref="T:NHibernate.Expression.Expression"/>s.
            </summary>
            <value>Returns "<c>or</c>"</value>
        </member>
        <member name="T:NHibernate.Expression.SQLCriterion">
            <summary>
            An <see cref="T:NHibernate.Expression.ICriterion"/> that creates a SQLExpression.
            The string {alias} will be replaced by the alias of the root entity.
            </summary>
            <remarks>
            This allows for database specific Expressions at the cost of needing to 
            write a correct <see cref="T:NHibernate.SqlCommand.SqlString"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Expression.SQLCriterion.ToSqlString(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="factory"></param>
            <param name="persistentClass"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.SQLCriterion.GetTypedValues(NHibernate.Engine.ISessionFactoryImplementor,System.Type,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="sessionFactory"></param>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Expression.SQLCriterion.ToString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.ClauseParser">
            <summary> 
            Parses the hibernate query into its constituent clauses.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.IParser">
            <summary> 
            A parser is a state machine that accepts a string of tokens,
            bounded by start() and end() and modifies a QueryTranslator. Parsers
            are NOT intended to be threadsafe. They SHOULD be reuseable
            for more than one token stream.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.IParser.Token(System.String,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.IParser.Start(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.IParser.End(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="T:NHibernate.Hql.FilterTranslator">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.QueryTranslator">
            <summary> 
            An instance of <c>QueryTranslator</c> translates a Hibernate query string to SQL.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.Loader">
            <summary>
            Abstract superclass of object loading (and querying) strategies.
            </summary>
            <remarks>
            <p>
            This class implements useful common functionality that concrete loaders would delegate to.
            It is not intended that this functionality would be directly accessed by client code (Hence,
            all methods of this class are declared <c>protected</c> or <c>private</c>.) This class relies heavily upon the
            <see cref="T:NHibernate.Persister.ILoadable"/> interface, which is the contract between this class and 
            <see cref="T:NHibernate.Persister.IClassPersister"/>s that may be loaded by it.
            </p>
            <p>
            The present implementation is able to load any number of columns of entities and at most 
            one collection role per query.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetLockModes(System.Collections.IDictionary)">
            <summary>
            What lock mode does this load entities with?
            </summary>
            <param name="lockModes">A Collection of lock modes specified dynamically via the Query Interface</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.ApplyLocks(NHibernate.SqlCommand.SqlString,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Append <c>FOR UPDATE OF</c> clause, if necessary. This
            empty superclass implementation merely returns its first
            argument.
            </summary>
            <param name="sql"></param>
            <param name="lockModes"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.UpgradeLocks">
            <summary>
            Does this Query return objects that might be already cached by 
            the session, whose lock mode may need upgrading.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.DoQueryAndInitializeNonLazyCollections(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,System.Object,System.Object,System.Object[],System.Boolean)">
            <summary>
            Execute an SQL query and attempt to instantiate instances of the class mapped by the given
            persister from each row of the <c>DataReader</c>. If an object is supplied, will attempt to
            initialize that object. If a collection is supplied, attempt to initialize that collection.
            </summary>
            <param name="session"></param>
            <param name="queryParameters"></param>
            <param name="optionalObject"></param>
            <param name="optionalId"></param>
            <param name="optionalCollectionKeys"></param>
            <param name="returnProxies"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetResultColumnOrRow(System.Object[],System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the actual object that is returned in the user-visible result list.
            </summary>
            <param name="row"></param>
            <param name="rs"></param>
            <param name="session"></param>
            <returns></returns>
            <remarks>
            This empty implementation merely returns its first argument. This is
            overridden by some subclasses.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.ReadCollectionElement(System.Object,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read one collection element from the current row of the ADO.NET result set
            </summary>
            <param name="optionalOwner"></param>
            <param name="optionalKey"></param>
            <param name="rs"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.HandleEmptyCollections(System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            If this is a collection initializer, we need to tell the session that a collection
            is being initilized, to account for the possibility of the collection having
            no elements (hence no rows in the result set).
            </summary>
            <param name="keys"></param>
            <param name="resultSetId"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetKeyFromResultSet(System.Int32,NHibernate.Persister.ILoadable,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Read a row of <c>Key</c>s from the <c>IDataReader</c> into the given array.
            </summary>
            <remarks>
            Warning: this method is side-effecty. If an <c>id</c> is given, don't bother going
            to the <c>IDataReader</c>
            </remarks>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="rs"></param>
            <param name="session"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.CheckVersion(System.Int32,NHibernate.Persister.ILoadable,System.Object,System.Object,System.Data.IDataReader,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Check the version of the object in the <c>IDataReader</c> against
            the object version in the session cache, throwing an exception
            if the vesrion numbers are different.
            </summary>
            <param name="i"></param>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="version"></param>
            <param name="rs"></param>
            <param name="session"></param>
            <exception cref="T:NHibernate.StaleObjectStateException"></exception>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetRow(System.Data.IDataReader,NHibernate.Persister.ILoadable[],System.String[],NHibernate.Engine.Key[],System.Object,NHibernate.Engine.Key,NHibernate.LockMode[],System.Collections.IList,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Resolve any ids for currently loaded objects, duplications within the <c>IDataReader</c>,
            etc. Instanciate empty objects to be initialized from the <c>IDataReader</c>. Return an
            array of objects (a row of results) and an array of booleans (by side-effect) that determine
            wheter the corresponding object should be initialized
            </summary>
            <param name="rs"></param>
            <param name="persisters"></param>
            <param name="suffixes"></param>
            <param name="keys"></param>
            <param name="optionalObject"></param>
            <param name="optionalObjectKey"></param>
            <param name="session"></param>
            <param name="hydratedObjects"></param>
            <param name="lockModes"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.InstanceAlreadyLoaded(System.Data.IDataReader,System.Int32,NHibernate.Persister.ILoadable,System.String,NHibernate.Engine.Key,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            The entity instance is already in the session cache
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.InstanceNotYetLoaded(System.Data.IDataReader,System.Int32,NHibernate.Persister.ILoadable,System.String,NHibernate.Engine.Key,NHibernate.LockMode,NHibernate.Engine.Key,System.Object,System.Collections.IList,NHibernate.Engine.ISessionImplementor)">
            <summary>
            The entity instance is not in the session cache
            </summary>
            <param name="dr"></param>
            <param name="i"></param>
            <param name="persister"></param>
            <param name="suffix"></param>
            <param name="key"></param>
            <param name="lockMode"></param>
            <param name="optionalObjectKey"></param>
            <param name="optionalObject"></param>
            <param name="hydratedObjects"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadFromResultSet(System.Data.IDataReader,System.Int32,System.Object,NHibernate.Engine.Key,System.String,NHibernate.LockMode,NHibernate.Persister.ILoadable,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Hydrate the state of an object from the SQL <c>IDataReader</c>, into
            an array of "hydrated" values (do not resolve associations yet),
            and pass the hydrated state to the session.
            </summary>
            <param name="rs"></param>
            <param name="i"></param>
            <param name="obj"></param>
            <param name="key"></param>
            <param name="suffix"></param>
            <param name="lockMode"></param>
            <param name="rootPersister"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetInstanceClass(System.Data.IDataReader,System.Int32,NHibernate.Persister.ILoadable,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine the concrete class of an instance for the <c>IDataReader</c>
            </summary>
            <param name="rs"></param>
            <param name="i"></param>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.Hydrate(System.Data.IDataReader,System.Object,System.Object,NHibernate.Persister.ILoadable,NHibernate.Engine.ISessionImplementor,System.String[][])">
            <summary>
            Unmarshall the fields of a persistent instance from a result set,
            without resolving associations or collections
            </summary>
            <param name="rs"></param>
            <param name="id"></param>
            <param name="obj"></param>
            <param name="persister"></param>
            <param name="session"></param>
            <param name="suffixedPropertyColumns"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.Advance(System.Data.IDataReader,NHibernate.Engine.RowSelection)">
            <summary>
            Advance the cursor to the first required row of the <c>IDataReader</c>
            </summary>
            <param name="rs"></param>
            <param name="selection"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.UseLimit(NHibernate.Engine.RowSelection,NHibernate.Dialect.Dialect)">
            <summary>
            Should we pre-process the SQL string, adding a dialect-specific
            LIMIT clause.
            </summary>
            <param name="selection"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.BindPositionalParameters(System.Data.IDbCommand,NHibernate.Engine.QueryParameters,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind positional parameter values to the <c>IDbCommand</c>
            (these are parameters specified by ?).
            </summary>
            <param name="st"></param>
            <param name="queryParameters"></param>
            <param name="start"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.PrepareQueryCommand(NHibernate.SqlCommand.SqlString,NHibernate.Engine.QueryParameters,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Obtain an <c>IDbCommand</c> with all parameters pre-bound. Bind positional parameters,
            named parameters, and limit parameters.
            </summary>
            <remarks>
            Creates an IDbCommand object and populates it with the values necessary to execute it against the 
            database to Load an Entity.
            </remarks>
            <param name="sqlString">The SqlString to convert into a prepared IDbCommand.</param>
            <param name="parameters">The <see cref="T:NHibernate.Engine.QueryParameters"/> to use for the IDbCommand.</param>
            <param name="scroll">TODO: find out where this is used...</param>
            <param name="session">The SessionImpl this Command is being prepared in.</param>
            <returns>An IDbCommand that is ready to be executed.</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetMaxOrLimit(NHibernate.Dialect.Dialect,NHibernate.Engine.RowSelection)">
            <summary>
            Some dialect-specific LIMIT clauses require the maximum last row number,
            others require the maximum returned row count.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.BindLimitParameters(System.Data.IDbCommand,System.Int32,NHibernate.Engine.RowSelection,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind parameters needed by the dialect-specific LIMIT clause
            </summary>
            <returns>The number of parameters bound</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.SetMaxRows(System.Data.IDbCommand,NHibernate.Engine.RowSelection)">
            <summary>
            Limits the number of rows returned by the Sql query if necessary.
            </summary>
            <param name="st">The IDbCommand to limit.</param>
            <param name="selection">The RowSelection that contains the MaxResults info.</param>
            <remarks>TODO: This does not apply to ADO.NET at all</remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.GetResultSet(System.Data.IDbCommand,NHibernate.Engine.RowSelection,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Fetch a <c>IDbCommand</c>, call <c>SetMaxRows</c> and then execute it,
            advance to the first result and return an SQL <c>IDataReader</c>
            </summary>
            <param name="st">The <see cref="T:System.Data.IDbCommand"/> to execute.</param>
            <param name="selection">The <see cref="T:NHibernate.Engine.RowSelection"/> to apply to the <see cref="T:System.Data.IDbCommand"/> and <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="session">The <see cref="T:NHibernate.ISession"/> to load in.</param>
            <returns>An IDataReader advanced to the first record in RowSelection.</returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.BindNamedParameters(System.Data.IDbCommand,System.Collections.IDictionary,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind named parameters to the <c>IDbCommand</c>
            </summary>
            <param name="st">The <see cref="T:System.Data.IDbCommand"/> that contains the parameters.</param>
            <param name="namedParams">The named parameters (key) and the values to set.</param>
            <param name="session">The <see cref="T:NHibernate.ISession"/> this Loader is using.</param>
            <param name="start"></param>
            <remarks>
            This has an empty implementation on this superclass and should be implemented by
            sublcasses (queries) which allow named parameters.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadEntity(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType[],System.Object,System.Object)">
            <summary>
            Called by subclasses that load entities.
            </summary>
            <param name="session"></param>
            <param name="values"></param>
            <param name="types"></param>
            <param name="optionalObject"></param>
            <param name="optionalID"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadEntity(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType,System.Object,System.Object)">
            <summary>
            Called by subclasses that load entities
            </summary>
            <param name="session"></param>
            <param name="id"></param>
            <param name="identifierType"></param>
            <param name="optionalObject"></param>
            <param name="optionalIdentifier"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadEntityBatch(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType,System.Object,System.Object)">
            <summary>
            Called by subclasses that batch load entities
            </summary>
            <param name="session"></param>
            <param name="ids"></param>
            <param name="idType"></param>
            <param name="optionalObject"></param>
            <param name="optionalID"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollection(NHibernate.Engine.ISessionImplementor,System.Object,NHibernate.Type.IType)">
            <summary>
            Called by subclasses that load collections
            </summary>
            <param name="session"></param>
            <param name="id"></param>
            <param name="type"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollectionBatch(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType)">
            <summary>
            Called by subclasses that batch initialize collections
            </summary>
            <param name="session"></param>
            <param name="ids"></param>
            <param name="type"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.LoadCollection(NHibernate.Engine.ISessionImplementor,System.Object[],NHibernate.Type.IType[])">
            <summary>
            Called by subclasses that initialize collections
            </summary>
            <param name="session"></param>
            <param name="ids"></param>
            <param name="types"></param>
        </member>
        <member name="M:NHibernate.Loader.Loader.List(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters,Iesi.Collections.ISet,NHibernate.Type.IType[])">
            <summary>
            Return the query results, using the query cache, called
            by subclasses that implement cacheable queries
            </summary>
            <param name="session"></param>
            <param name="queryParameters"></param>
            <param name="querySpaces"></param>
            <param name="resultTypes"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.DoList(NHibernate.Engine.ISessionImplementor,NHibernate.Engine.QueryParameters)">
            <summary>
            Actually execute a query, ignoring the query cache
            </summary>
            <param name="session"></param>
            <param name="queryParameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.PostInstantiate">
            <summary>
            Calculate and cache select-clause suffixes. Must be
            called by subclasses after instantiation.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.Loader.GenerateSuffixes(System.Int32)">
            <summary>
            Utility method that generate 0_, 1_ suffixes. Subclasses don't
            necessarily need to use this algorithm, but it is intended that
            they will in most cases.
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.Loader.GenerateAlias(System.String,System.Int32)">
            <summary>
            Generate a nice alias for the given class name or collection role
            name and unique integer. Subclasses do <em>not</em> have to use
            aliases of this form.
            </summary>
            <param name="description"></param>
            <param name="unique"></param>
            <returns>an alias of the form <c>foo1_</c></returns>
        </member>
        <member name="P:NHibernate.Loader.Loader.SqlString">
            <summary>
            The SqlString to be called; implemented by all subclasses
            </summary>
            <remarks>
            <p>
            The <c>setter</c> was added so that class inheriting from Loader could write a 
            value using the Property instead of directly to the field.
            </p>
            <p>
            The scope is <c>internal</c> because the <see cref="T:NHibernate.Hql.WhereParser"/> needs to
            be able to <c>get</c> the SqlString of the <see cref="T:NHibernate.Hql.QueryTranslator"/> when
            it is parsing a subquery.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Loader.Loader.Persisters">
            <summary>
            An array of persisters of entity classes contained in each row of results;
            implemented by all subclasses
            </summary>
            <remarks>
            <p>
            The <c>setter</c> was added so that classes inheriting from Loader could write a 
            value using the Property instead of directly to the field.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Loader.Loader.Suffixes">
            <summary>
            The suffix identifies a particular column of results in the SQL <c>IDataReader</c>;
            implemented by all subclasses
            </summary>
            <remarks>
            <p>
            The <c>setter</c> was added so that classes inheriting from Loader could write a 
            value using the Property instead of directly to the field.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Loader.Loader.Owners">
            <summary>
            An array of indexes of the entity that owns a one-to-one association
            to the entity at the given index (-1 if there is no "owner")
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.CollectionPersister">
            <summary>
            An (optional) persister for a collection to be initialized; only collection loaders
            return a non-null value
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.CollectionOwner">
            <summary>
            Get the index of the entity that owns the collection, or -1
            if there is no owner in the query results (i.e. in the case of a 
            collection initializer) or no collection.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.Loader.IsSingleRowLoader">
            <summary>
            Return false is this loader is a batch entity loader
            </summary>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.#ctor(System.String)">
            <summary> 
            Construct a query translator
            </summary>
            <param name="queryString"></param>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.Compile(NHibernate.Hql.QueryTranslator)">
            <summary>
            Compile a subquery
            </summary>
            <param name="superquery"></param>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.Compile(NHibernate.Engine.ISessionFactoryImplementor,System.Collections.IDictionary,System.Boolean)">
            <summary>
            Compile a "normal" query. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
            <param name="factory"></param>
            <param name="replacements"></param>
            <param name="scalar"></param>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.Compile">
            <summary> 
            Compile the query (generate the SQL).
            </summary>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.RenderScalarSelect">
            <summary> 
            WARNING: side-effecty
            </summary>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.AddFromAssociation(System.String,System.String)">
            <remarks>Used for collection filters</remarks>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.GetImportedClass(System.String)">
            <summary>
            Gets the Type for the name that might be an Imported Class.
            </summary>
            <param name="name">The name that might be an ImportedClass.</param>
            <returns>A <see cref="T:System.Type"/> if <c>name</c> is an Imported Class, <c>null</c> otherwise.</returns>
        </member>
        <member name="M:NHibernate.Hql.QueryTranslator.GetImportedClass(System.String,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Gets the Type for the name that might be an Imported Class.
            </summary>
            <param name="name">The name that might be an ImportedClass.</param>
            <param name="factory">The <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> that contains the Imported Classes.</param>
            <returns>A <see cref="T:System.Type"/> if <c>name</c> is an Imported Class, <c>null</c> otherwise.</returns>
        </member>
        <member name="F:NHibernate.Hql.QueryTranslator.isSqlStringPopulated">
            <summary>
            Indicates if the SqlString has been fully populated - it goes
            through a 2 phase process.  The first part is the parsing of the
            hql and it puts in placeholders for the parameters, the second phase 
            puts in the actual types for the parameters using QueryParameters
            passed to query methods.  The completion of the second phase is
            when <c>isSqlStringPopulated==true</c>.
            </summary>
        </member>
        <member name="P:NHibernate.Hql.QueryTranslator.Persisters">
            <summary>
            Persisters for the return values of a <c>Find</c> style query
            </summary>
            <remarks>
            The <c>Persisters</c> stored by QueryTranslator have to be <see cref="T:NHibernate.Persister.IQueryable"/>.  The
            <c>setter</c> will attempt to cast the <c>ILoadable</c> array passed in into an 
            <c>IQueryable</c> array.
            </remarks>
        </member>
        <member name="P:NHibernate.Hql.QueryTranslator.ReturnTypes">
             <summary>
            Types of the return values of an <c>Enumerate()</c> style query.
            Return an array of <see cref="T:NHibernate.Type.IType"/>s.
             </summary>
        </member>
        <member name="P:NHibernate.Hql.QueryTranslator.SqlString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.QueryTranslator.IsShallowQuery">
            <summary>
            Is this query called by Scroll() or Iterate()?
            </summary>
            <value>true if it is, false if it is called by find() or list()</value>
        </member>
        <member name="P:NHibernate.Hql.QueryTranslator.IsSubquery">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.QueryTranslator.Owners">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.FilterTranslator.#ctor(System.String)">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Hql.FilterTranslator.Compile(System.String,NHibernate.Engine.ISessionFactoryImplementor,System.Collections.IDictionary,System.Boolean)">
            <summary>
            Compile a filter. This method may be called multiple
            times. Subsequent invocations are no-ops.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.FromParser">
            <summary> 
            Parses the from clause of a hibernate query, looking for tables and
            aliases for the SQL query.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.FromParser.#cctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.FromPathExpressionParser">
            <summary>
            FromPathExpressionParser
            </summary>
        </member>
        <member name="T:NHibernate.Hql.PathExpressionParser">
            <summary> 
            Parses an expression of the form foo.bar.baz and builds up an expression
            involving two less table joins than there are path components.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.DereferenceEntity(System.String,NHibernate.Type.EntityType,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <param name="propertyType"></param>
            <param name="q"></param>
            <remarks>NOTE: we avoid joining to the next table if the named property is just the foreign key value</remarks>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.CurrentColumns">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.Start(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.End(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.LastCollectionElement">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.SetExpectingCollectionIndex">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.GetCollectionSubquery">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.AddAssociation(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.AddFromAssociation(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.AddFromCollection(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.PathExpressionParser.Fetch(NHibernate.Hql.QueryTranslator,System.String)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="entityName"></param>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.PropertyType">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.LastCollectionElementIndexValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.IsExpectingCollectionIndex">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.WhereJoin">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.WhereColumn">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.WhereColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.WhereColumnType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.IsCollectionValued">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.CollectionName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.CollectionRole">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.CollectionOwnerName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.CurrentName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.PathExpressionParser.CurrentProperty">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.PathExpressionParser.CollectionElement">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.PathExpressionParser.CollectionElement.Type">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.PathExpressionParser.CollectionElement.IsOneToMany">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.PathExpressionParser.CollectionElement.Alias">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.PathExpressionParser.CollectionElement.ElementColumns">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.PathExpressionParser.CollectionElement.Join">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Hql.PathExpressionParser.CollectionElement.IndexValue">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.FromPathExpressionParser.End(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.FromPathExpressionParser.SetExpectingCollectionIndex">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.GroupByParser">
            <summary> 
            Parses the GROUP BY clause of an aggregate query
            </summary>
        </member>
        <member name="M:NHibernate.Hql.GroupByParser.#ctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.HavingParser">
            <summary> 
            Parses the having clause of a hibernate query and translates it to an
            SQL having clause.
            </summary>
        </member>
        <member name="T:NHibernate.Hql.WhereParser">
            <summary> Parses the where clause of a hibernate query and translates it to an
            SQL where clause.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.WhereParser.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Hql.WhereParser.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.WhereParser.Token(System.String,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.WhereParser.Start(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.WhereParser.End(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.WhereParser.AppendToken(NHibernate.Hql.QueryTranslator,System.String)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="token"></param>
        </member>
        <member name="M:NHibernate.Hql.WhereParser.AppendToken(NHibernate.Hql.QueryTranslator,NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="token"></param>
        </member>
        <member name="M:NHibernate.Hql.HavingParser.AppendToken(NHibernate.Hql.QueryTranslator,System.String)">
            <summary>
            
            </summary>
            <param name="q"></param>
            <param name="token"></param>
        </member>
        <member name="T:NHibernate.Hql.OrderByParser">
            <summary> 
            Parses the ORDER BY clause of a query
            </summary>
        </member>
        <member name="M:NHibernate.Hql.OrderByParser.Token(System.String,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="T:NHibernate.Hql.ParserHelper">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Hql.PreprocessingParser">
            <summary>HQL lexical analyzer (not really a parser)</summary>
        </member>
        <member name="M:NHibernate.Hql.PreprocessingParser.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.PreprocessingParser.#ctor(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="replacements"></param>
        </member>
        <member name="M:NHibernate.Hql.PreprocessingParser.Token(System.String,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.PreprocessingParser.Start(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.PreprocessingParser.End(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="T:NHibernate.Hql.SelectParser">
            <summary>
            Parsers the select clause of a hibernate query, looking
            for a table (well, really class) alias.
            </summary>
        </member>
        <member name="M:NHibernate.Hql.SelectParser.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.SelectParser.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.SelectParser.Token(System.String,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="token"></param>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.SelectParser.AggregateHasArgs(System.String,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="funcToken"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.SelectParser.AggregateFuncNoArgsHasParenthesis(System.String,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="funcToken"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.SelectParser.AggregateType(System.Collections.ArrayList,NHibernate.Type.IType,NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="funcTokenList"></param>
            <param name="type"></param>
            <param name="q"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Hql.SelectParser.Start(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.SelectParser.End(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="T:NHibernate.Hql.SelectPathExpressionParser">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Hql.SelectPathExpressionParser.End(NHibernate.Hql.QueryTranslator)">
            <summary>
            
            </summary>
            <param name="q"></param>
        </member>
        <member name="M:NHibernate.Hql.SelectPathExpressionParser.SetExpectingCollectionIndex">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Hql.SelectPathExpressionParser.SelectName">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Id.Assigned">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns the current identifier
            assigned to an instance.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="assigned" /&gt;</code>
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IIdentifierGenerator">
            <summary>
            The general contract between a class that generates unique
            identifiers and the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <remarks>
            <para>
            It is not intended that this interface ever be exposed to the 
            application.  It <b>is</b> intended that users implement this interface
            to provide custom identifier generation strategies.
            </para>
            <para>
            Implementors should provide a public default constructor.
            </para>
            <para>
            Implementations that accept configuration parameters should also
            implement <see cref="T:NHibernate.Id.IConfigurable"/>.
            </para>
            <para>
            Implementors <b>must</b> be threadsafe.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IIdentifierGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new identifier
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier</returns>
        </member>
        <member name="F:NHibernate.Id.Assigned.Instance">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Id.Assigned.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generates a new identifier by getting the value of the identifier
            for the <c>obj</c> parameter.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The value that was assigned to the mapped <c>id</c>'s property.</returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            Thrown when a <see cref="T:NHibernate.Collection.PersistentCollection"/> is passed in as the <c>obj</c> or
            if the identifier of <c>obj</c> is null.
            </exception>
        </member>
        <member name="T:NHibernate.Id.CounterGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a <c>Int64</c> constructed from the system
            time and a counter value. Not safe for use in a clustser!
            </summary>
        </member>
        <member name="M:NHibernate.Id.CounterGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="cache"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Id.CounterGenerator.Count">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Id.ForeignGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that uses the value of 
            the id property of an associated object
            </summary>
            <remarks>
            <para>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="foreign"&gt;
            	&lt;param name="property"&gt;AssociatedObject&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </para>
            The mapping parameter <c>property</c> is required.
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IConfigurable">
            <summary>
            An <c>IdentiferGenerator</c> that supports "configuration".
            </summary>
        </member>
        <member name="M:NHibernate.Id.IConfigurable.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configure this instance, given the values of parameters
            specified by the user as <c>&lt;param&gt;</c> elements.
            This method is called just once, followed by instantiation.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.ForeignGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generates an identifer from the value of a Property. 
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>
            The identifier value from the associated object or  
            <see cref="F:NHibernate.Id.IdentifierGeneratorFactory.ShortCircuitIndicator"/> if the <c>session</c>
            already contains <c>obj</c>.
            </returns>
        </member>
        <member name="M:NHibernate.Id.ForeignGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the ForeignGenerator by reading the value of <c>property</c> 
            from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
            <exception cref="T:NHibernate.MappingException">
            Thrown if the key <c>property</c> is not found in the <c>parms</c> parameter.
            </exception>
        </member>
        <member name="T:NHibernate.Id.GuidCombGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <see cref="T:System.Guid"/> values 
            using a strategy suggested Jimmy Nilsson's 
            <a href="http://www.informit.com/articles/article.asp?p=25862">article</a>
            on <a href="http://www.informit.com">informit.com</a>. 
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="guid.comb" /&gt;</code>
            </p>
            <p>
            The <c>comb</c> algorithm is designed to make the use of GUIDs as Primary Keys, Foreign Keys, 
            and Indexes nearly as efficient as ints.
            </p>
            <p>
            This code was contributed by Donald Mull.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.GuidCombGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.Guid"/> using the comb algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Guid"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.GuidCombGenerator.GenerateComb">
            <summary>
            Generate a new <see cref="T:System.Guid"/> using the comb algorithm.
            </summary>
        </member>
        <member name="T:NHibernate.Id.GuidGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <see cref="T:System.Guid"/> values 
            using <see cref="M:System.Guid.NewGuid">Guid.NewGuid()</see>. 
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="guid" /&gt;</code>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.GuidGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.Guid"/> for the identifier.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Guid"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.IdentifierGenerationException">
            <summary>
            Thrown by <see cref="T:NHibernate.Id.IIdentifierGenerator"/> implementation class when ID generation fails
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="e">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Id.IdentifierGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Id.IdentifierGenerationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Id.IdentifierGeneratorFactory">
            <summary>
            Factory methods for <c>IdentifierGenerator</c> framework.
            </summary>
            <remarks>
            <p>The built in strategies for identifier generation in NHibernate are:</p>
            <list type="table">
            	<listheader>
            		<term>strategy</term>
            		<description>Implementation of strategy</description>
            	</listheader>
            	<item>
            		<term>assigned</term>
            		<description><see cref="T:NHibernate.Id.Assigned"/></description>
            	</item>
            	<item>
            		<term>foreign</term>
            		<description><see cref="T:NHibernate.Id.ForeignGenerator"/></description>
            	</item>
            	<item>
            		<term>guid</term>
            		<description><see cref="T:NHibernate.Id.GuidGenerator"/></description>
            	</item>
            	<item>
            		<term>guid.comb</term>
            		<description><see cref="T:NHibernate.Id.GuidCombGenerator"/></description>
            	</item>
            	<item>
            		<term>hilo</term>
            		<description><see cref="T:NHibernate.Id.TableHiLoGenerator"/></description>
            	</item>
            	<item>
            		<term>identity</term>
            		<description><see cref="T:NHibernate.Id.IdentityGenerator"/></description>
            	</item>
            	<item>
            		<term>native</term>
            		<description>
            			Chooses between <see cref="T:NHibernate.Id.IdentityGenerator"/>, <see cref="T:NHibernate.Id.SequenceGenerator"/>
            			, and <see cref="T:NHibernate.Id.TableHiLoGenerator"/> based on the 
            			<see cref="T:NHibernate.Dialect.Dialect"/>'s capabilities.
            		</description>
            	</item>
            	<item>
            		<term>seqhilo</term>
            		<description><see cref="T:NHibernate.Id.SequenceHiLoGenerator"/></description>
            	</item>
            	<item>
            		<term>sequence</term>
            		<description><see cref="T:NHibernate.Id.SequenceGenerator"/></description>
            	</item>
            	<item>
            		<term>uuid.hex</term>
            		<description><see cref="T:NHibernate.Id.UUIDHexGenerator"/></description>
            	</item>
            	<item>
            		<term>uuid.string</term>
            		<description><see cref="T:NHibernate.Id.UUIDStringGenerator"/></description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.Get(System.Data.IDataReader,System.Type)">
            <summary>
            Gets the value of the identifier from the <see cref="T:System.Data.IDataReader"/> and
            ensures it is the correct <see cref="T:System.Type"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> to read the identifier value from.</param>
            <param name="clazz">The <see cref="T:System.Type"/> the value should be converted to.</param>
            <returns>
            The value for the identifier.
            </returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            Thrown if there is any problem getting the value from the <see cref="T:System.Data.IDataReader"/>
            or with converting it to the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.idgenerators">
            <summary>
            An <see cref="T:System.Collections.Hashtable"/> where the <c>key</c> is the strategy and 
            the <c>value</c> is the <see cref="T:System.Type"/> for the strategy.
            </summary>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.ShortCircuitIndicator">
            <summary>
            When this is returned by <c>Generate()</c> it indicates that the object
            has already been saved.
            </summary>
            <value>
            <see cref="F:System.String.Empty">String.Empty</see>
            </value>
        </member>
        <member name="F:NHibernate.Id.IdentifierGeneratorFactory.IdentityColumnIndicator">
            <summary>
            When this is return
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.#cctor">
            <summary>
            Initializes the static fields in <see cref="T:NHibernate.Id.IdentifierGeneratorFactory"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.Create(System.String,NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Creates an <see cref="T:NHibernate.Id.IIdentifierGenerator"/> from the named strategy.
            </summary>
            <param name="strategy">
            The name of the generator to create.  This can be one of the NHibernate abbreviations (ie - <c>native</c>, 
            <c>sequence</c>, <c>guid.comb</c>, etc...), a full class name if the Type is in the NHibernate assembly, or
            a full type name if the strategy is in an external assembly.
            </param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> that the retured identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of <c>&lt;param&gt;</c> values from the mapping.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
            <returns>
            An instantiated and configured <see cref="T:NHibernate.Id.IIdentifierGenerator"/>.
            </returns>
            <exception cref="T:NHibernate.MappingException">
            Thrown if there are any exceptions while creating the <see cref="T:NHibernate.Id.IIdentifierGenerator"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Id.IdentifierGeneratorFactory.CreateNumber(System.Int64,System.Type)">
            <summary>
            Create the correct boxed <see cref="T:System.Type"/> for the identifier.
            </summary>
            <param name="value">The value of the new identifier.</param>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <returns>
            The identifier value converted to the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.Id.IdentifierGenerationException">
            The <c>type</c> parameter must be an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>,
            or <see cref="T:System.Int64"/>.
            </exception>
        </member>
        <member name="T:NHibernate.Id.IdentityGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that indicates to the <see cref="T:NHibernate.ISession"/> that identity
            (ie. identity/autoincrement column) key generation should be used.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="identity" /&gt;</code> 
            or if the database natively supports identity columns 
            <code>&lt;generator class="native" /&gt;</code>
            </p>
            <p>
            This indicates to NHibernate that the database generates the id when
            the entity is inserted.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.IdentityGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            The IdentityGenerator for autoincrement/identity key generation.
            
            </summary>
            <param name="s">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity the id is being generated for.</param>
            <returns>
            <c>IdentityColumnIndicator</c> Indicates to the Session that identity (i.e. identity/autoincrement column)
            key generation should be used.
            </returns>
        </member>
        <member name="T:NHibernate.Id.IncrementGenerator">
            <summary>
            An <c>IIdentifierGenerator</c> that returns a <c>Int64</c>, constructed by
            counting from the maximum primary key value at startup. Not safe for use in a
            cluster!
            </summary>
            <remarks>
            <para>
            java author Gavin King, .NET port Mark Holden
            </para>
            <para>
            Mapping parameters supported, but not usually needed: table, column.
            </para>
            </remarks>
        </member>
        <member name="T:NHibernate.Id.IPersistentIdentifierGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that requires creation of database objects
            All <see cref="T:NHibernate.Id.IPersistentIdentifierGenerator"/>s that also implement 
            An <see cref="T:NHibernate.Id.IConfigurable"/>  have access to a special mapping parameter: schema
            </summary>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the underlying database objects
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the sql to create the 
            necessary database objects.
            </returns>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects.
            </returns>
        </member>
        <member name="M:NHibernate.Id.IPersistentIdentifierGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects.
            </summary>
            <returns>
            A key unique to the underlying database objects.
            </returns>
            <remarks>
            Prevents us from trying to create/remove them multiple times
            </remarks>
        </member>
        <member name="F:NHibernate.Id.IncrementGenerator.Column">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Id.IncrementGenerator.Table">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Id.IncrementGenerator.Schema">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="parms"></param>
            <param name="d"></param>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Id.IncrementGenerator.GeneratorKey">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Id.SequenceGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that generates <c>Int64</c> values using an 
            oracle-style sequence. A higher performance algorithm is 
            <see cref="T:NHibernate.Id.SequenceHiLoGenerator"/>.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="sequence"&gt;
            	&lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>sequence</c> parameter is required while the <c>schema</c> is optional.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.SequenceGenerator.Sequence">
            <summary>
            The name of the sequence parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.SequenceGenerator.Schema">
            <summary>
            The name of the schema parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the SequenceGenerator by reading the value of <c>sequence</c> and
            <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by using a database sequence.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the database objects for a SequenceGenerator.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the Dialect specific sql to 
            create the necessary database objects for the SequenceGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects for a SequenceGenerator.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects for the SequenceGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.SequenceGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects for a SequenceGenerator.
            </summary>
            <returns>
            The configured sequence name.
            </returns>
        </member>
        <member name="T:NHibernate.Id.SequenceHiLoGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that combines a hi/lo algorithm with an underlying
            oracle-style sequence that generates hi values.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="seqhilo"&gt;
            	&lt;param name="sequence"&gt;uid_sequence&lt;/param&gt;
            	&lt;param name="max_lo"&gt;max_lo_value&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>sequence</c> parameter is required, the <c>max_lo</c> and <c>schema</c> are optional.
            </p>
            <p>
            The user may specify a <c>max_lo</c> value to determine how often new hi values are
            fetched. If sequences are not avaliable, <c>TableHiLoGenerator</c> might be an
            alternative.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.SequenceHiLoGenerator.MaxLo">
            <summary>
            The name of the maximum low value parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.SequenceHiLoGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the SequenceHiLoGenerator by reading the value of <c>sequence</c>, <c>max_lo</c>, 
            and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.SequenceHiLoGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate an <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by using a database sequence.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.TableGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that uses a database table to store the last
            generated value.
            </summary>
            <remarks>
            <p>
            It is not intended that applications use this strategy directly. However,
            it may be used to build other (efficient) strategies. The return type is
            <c>System.Int32</c>
            </p>
            <p>
            The hi value MUST be fetched in a seperate transaction to the <c>ISession</c>
            transaction so the generator must be able to obtain a new connection and commit it.
            Hence this implementation may not be used when the user is supplying connections.
            </p>
            <p>
            The mapping parameters <c>table</c> and <c>column</c> are required.
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.Column">
            <summary>
            The name of the column parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.Table">
            <summary>
            The name of the table parameter.
            </summary>
        </member>
        <member name="F:NHibernate.Id.TableGenerator.Schema">
            <summary>
            The name of the schema parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the TableGenerator by reading the value of <c>table</c>, 
            <c>column</c>, and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by selecting and updating a value in a table.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.SqlCreateStrings(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to create the database objects for a TableGenerator.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            An array of <see cref="T:System.String"/> objects that contain the Dialect specific sql to 
            create the necessary database objects and to create the first value as <c>1</c> 
            for the TableGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.SqlDropString(NHibernate.Dialect.Dialect)">
            <summary>
            The SQL required to remove the underlying database objects for a TableGenerator.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with creating the sql.</param>
            <returns>
            A <see cref="T:System.String"/> that will drop the database objects for the TableGenerator.
            </returns>
        </member>
        <member name="M:NHibernate.Id.TableGenerator.GeneratorKey">
            <summary>
            Return a key unique to the underlying database objects for a TableGenerator.
            </summary>
            <returns>
            The configured table name.
            </returns>
        </member>
        <member name="T:NHibernate.Id.TableHiLoGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns an <c>Int64</c>, constructed using
            a hi/lo algorithm.
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="hilo"&gt;
            	&lt;param name="table"&gt;table&lt;/param&gt;
            	&lt;param name="column"&gt;id_column&lt;/param&gt;
            	&lt;param name="max_lo"&gt;max_lo_value&lt;/param&gt;
            	&lt;param name="schema"&gt;db_schema&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>table</c> and <c>column</c> parameters are required, the <c>max_lo</c> and 
            <c>schema</c> are optional.
            </p>
            <p>
            The hi value MUST be fecthed in a seperate transaction to the <c>ISession</c>
            transaction so the generator must be able to obtain a new connection and 
            commit it. Hence this implmentation may not be used when the user is supplying
            connections.  In that case a <see cref="T:NHibernate.Id.SequenceHiLoGenerator"/> would be a 
            better choice (where supported).
            </p>
            </remarks>
        </member>
        <member name="F:NHibernate.Id.TableHiLoGenerator.MaxLo">
            <summary>
            The name of the max lo parameter.
            </summary>
        </member>
        <member name="M:NHibernate.Id.TableHiLoGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the TableHiLoGenerator by reading the value of <c>table</c>, 
            <c>column</c>, <c>max_lo</c>, and <c>schema</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="M:NHibernate.Id.TableHiLoGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/> 
            for the identifier by selecting and updating a value in a table.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.Int16"/>, <see cref="T:System.Int32"/>, or <see cref="T:System.Int64"/>.</returns>
        </member>
        <member name="T:NHibernate.Id.UUIDHexGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a string of length
            32, 36, or 38 depending on the configuration.  
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>
            &lt;generator class="uuid.hex"&gt;
            	&lt;param name="format"&gt;format_string&lt;/param&gt;
            	&lt;param name="seperator"&gt;seperator_string&lt;/param&gt;
            &lt;/generator&gt;
            </code>
            </p>
            <p>
            The <c>format</c> and <c>seperator</c> parameters are optional.
            </p>
            <p>
            The identifier string will consist of only hex digits.  Optionally, the identifier string
            may be generated with enclosing characters and seperators between each component 
            of the UUID.  If there are seperators then the string length will be 36.  If a format
            that has enclosing brackets is used, then the string length will be 38.
            </p>
            <p>
            <c>format</c> is either 
            "N" (<c>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</c>), 
            "D" (<c>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</c>), 
            "B" (<c>{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}</c>), 
            or "P" (<c>(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)</c>).  These formats are described in
            the <see cref="M:System.Guid.ToString(System.String)">Guid.ToString(String)</see> method.
            If no <c>format</c> is specified the default is "N".
            </p>
            <p>
            <c>seperator</c> is the char that will replace the "-" if specified.  If no value is
            configured then the default seperator for the format will be used.  If the format "D", "B", or
            "P" is specified, then the seperator will replace the "-".  If the format is "N" then this
            parameter will be ignored.
            </p>
            <p>
            This class is based on <see cref="T:System.Guid"/>
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.UUIDHexGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.String"/> for the identifier using the "uuid.hex" algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:NHibernate.Id.UUIDHexGenerator.Configure(NHibernate.Type.IType,System.Collections.IDictionary,NHibernate.Dialect.Dialect)">
            <summary>
            Configures the UUIDHexGenerator by reading the value of <c>format</c> and
            <c>seperator</c> from the <c>parms</c> parameter.
            </summary>
            <param name="type">The <see cref="T:NHibernate.Type.IType"/> the identifier should be.</param>
            <param name="parms">An <see cref="T:System.Collections.IDictionary"/> of Param values that are keyed by parameter name.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with Configuration.</param>
        </member>
        <member name="T:NHibernate.Id.UUIDStringGenerator">
            <summary>
            An <see cref="T:NHibernate.Id.IIdentifierGenerator"/> that returns a string of length
            16.  
            </summary>
            <remarks>
            <p>
            This id generation strategy is specified in the mapping file as 
            <code>&lt;generator class="uuid.string" /&gt;</code>
            </p>
            <para>
            The identifier string will NOT consist of only alphanumeric characters.  Use
            this only if you don't mind unreadable identifiers.
            </para>
            <para>
            This impelementation was known to be incompatible with Postgres.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Id.UUIDStringGenerator.Generate(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Generate a new <see cref="T:System.String"/> for the identifier using the "uuid.string" algorithm.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this id is being generated in.</param>
            <param name="obj">The entity for which the id is being generated.</param>
            <returns>The new identifier as a <see cref="T:System.String"/>.</returns>
        </member>
        <member name="T:NHibernate.Impl.AbstractQueryImpl">
            <summary>
            Abstract implementation of the IQuery interface.
            </summary>
        </member>
        <member name="T:NHibernate.IQuery">
            <summary>
            An object-oriented representation of a NHibernate query.
            </summary>
            <remarks>
            An <c>IQuery</c> instance is obtained by calling <c>ISession.CreateQuery()</c>. This interface
            exposes some extra functionality beyond that provided by <c>ISession.Iterate()</c> and
            <c>ISession.Find()</c>;
            <list>
            	<item>
            		A particulare page of the result set may be selected by calling 
            		<c>SetMaxResults()</c>, <c>SetFirstResult()</c>.  The generated sql
            		depends on the capabilities of the <see cref="T:NHibernate.Dialect.Dialect"/>.  Some
            		Dialects are for databases that have built in paging (LIMIT) and those capabilities
            		will be used to limit the number of records returned by the sql statement. 
            		If the database does not support LIMITs then all of the records will be returned,
            		but the objects created will be limited to the specific results requested.
            	</item>
            	<item>Named query parameters may be used</item>
            </list>
            <para>
            Named query parameters are tokens of the form <c>:name</c> in the query string. A value is bound
            to the <c>Int32</c> parameter <c>:foo</c> by calling
            <code>
            	SetParameter("foo", foo, NHibernateUtil.Int32);
            </code>
            for example. A name may appear multiple times in the query string.
            </para>
            <para>
            Unnamed parameters <c>?</c> are also supported. To bind a value to an unnamed
            parameter use a Set method that accepts an <c>Int32</c> positional argument - numbered from
            zero.
            </para>
            <para>
            You may not mix and match unnamed parameters and named parameters in the same query.
            </para>
            <para>
            Queries are executed by calling <c>List()</c> or <c>Iterate()</c>. A query
            may be re-executed by subsequent invocations. Its lifespan is, however, bounded by the lifespan
            of the <c>ISession</c> that created it.
            </para>
            <para>
            Implementors are not intended to be threadsafe.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.Enumerable">
            <summary>
            Return the query results as an <see cref="T:System.Collections.IEnumerable"/>. If the query contains multiple results
            per row, the results are returned in an instance of <c>object[]</c>.
            </summary>
            <remarks>
            <p>
            Entities returned as results are initialized on demand. The first SQL query returns
            identifiers only.  
            </p>
            <p>
            This is a good strategy to use if you expect a high number of the objects
            returned to be already loaded in the <see cref="T:NHibernate.ISession"/> or in the 2nd level cache.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.List">
            <summary>
            Return the query results as an <see cref="T:System.Collections.IList"/>. If the query contains multiple results per row,
            the results are returned in an instance of <c>object[]</c>.
            </summary>
            <remarks>
            This is a good strategy to use if you expect few of the objects being returned are already loaded
            or if you want to fill the 2nd level cache.
            </remarks>
        </member>
        <member name="M:NHibernate.IQuery.UniqueResult">
            <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
            <returns>the single result or <c>null</c></returns>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when there is more than one matching result.
            </exception>
        </member>
        <member name="M:NHibernate.IQuery.SetMaxResults(System.Int32)">
            <summary>
            Set the maximum number of rows to retrieve.
            </summary>
            <param name="maxResults">The maximum number of rows to retreive.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetFirstResult(System.Int32)">
            <summary>
            Sets the first row to retrieve.
            </summary>
            <param name="firstResult">The first row to retreive.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set.
            </summary>
            <param name="cacheable">Should the query results be cacheable?</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCacheRegion(System.String)">
            Set the name of the cache region.
            <param name="cacheRegion">The name of a query cache region, or <c>null</c>
            for the default query cache</param>
        </member>
        <member name="M:NHibernate.IQuery.SetForceCacheRefresh(System.Boolean)">
            Should the query force a refresh of the specified query cache region?
            This is particularly useful in cases where underlying data may have been
            updated via a seperate process (i.e., not modified through Hibernate) and
            allows the application to selectively refresh the query cache regions
            based on its knowledge of those events.
            <param name="forceCacheRefresh">Should the query result in a forceable refresh of
            the query cache?</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimeout(System.Int32)">
            <summary>
            The timeout for the underlying ADO query
            </summary>
            <param name="timeout"></param>
        </member>
        <member name="M:NHibernate.IQuery.SetLockMode(System.String,NHibernate.LockMode)">
            <summary>
            Set the lockmode for the objects idententified by the
            given alias that appears in the <c>FROM</c> clause.
            </summary>
            <param name="alias">alias a query alias, or <c>this</c> for a collection filter</param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.Int32,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to an indexed parameter.
            </summary>
            <param name="position">Postion of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The Hibernate type</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            Bind a value to a named query parameter
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The possibly null parameter value</param>
            <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.Int32,System.Object)">
            <summary>
            Bind a value to an indexed parameter, guessing the Hibernate type from
            the class of the given object.
            </summary>
            <param name="position">The position of the parameter in the query, numbered from <c>0</c></param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameter(System.String,System.Object)">
            <summary>
            Bind a value to a named query parameter, guessing the NHibernate <see cref="T:NHibernate.Type.IType"/>
            from the class of the given object.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">The non-null parameter value</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
            <summary>
            Bind multiple values to a named query parameter. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
            <param name="type">The Hibernate type of the values</param>
        </member>
        <member name="M:NHibernate.IQuery.SetParameterList(System.String,System.Collections.ICollection)">
            <summary>
            Bind multiple values to a named query parameter, guessing the Hibernate
            type from the class of the first object in the collection. This is useful for binding a list
            of values to an expression such as <c>foo.bar in (:value_list)</c>
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="vals">A collection of values to list</param>
        </member>
        <member name="M:NHibernate.IQuery.SetProperties(System.Object)">
            <summary>
            Bind the property values of the given object to named paramters of the query,
            matching property names with parameter names and mapping property types to
            Hibernate types using hueristics.
            </summary>
            <param name="obj">Any PONO</param>
        </member>
        <member name="M:NHibernate.IQuery.SetAnsiString(System.Int32,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetAnsiString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.AnsiStringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBinary(System.Int32,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBinary(System.String,System.Byte[])">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> array to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BinaryType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/> array.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBoolean(System.Int32,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetBoolean(System.String,System.Boolean)">
            <summary>
            Bind an instance of a <see cref="T:System.Boolean"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.BooleanType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Boolean"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetByte(System.Int32,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetByte(System.String,System.Byte)">
            <summary>
            Bind an instance of a <see cref="T:System.Byte"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.ByteType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Byte"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCharacter(System.Int32,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetCharacter(System.String,System.Char)">
            <summary>
            Bind an instance of a <see cref="T:System.Char"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.CharType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Char"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDateTime(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDateTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
            <param name="name">The name of the parameter</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDecimal(System.Int32,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDecimal(System.String,System.Decimal)">
            <summary>
            Bind an instance of a <see cref="T:System.Decimal"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DecimalType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Decimal"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDouble(System.Int32,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetDouble(System.String,System.Double)">
            <summary>
            Bind an instance of a <see cref="T:System.Double"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DoubleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Double"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEntity(System.Int32,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to an indexed parameter.
            </summary>
            <param name="position">Position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEntity(System.String,System.Object)">
            <summary>
            Bind an instance of a mapped persistent class to a named parameter.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent class</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEnum(System.Int32,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IQuery.SetEnum(System.String,System.Enum)">
            <summary>
            Bind an instance of a persistent enumeration class to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.PersistentEnumType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a persistent enumeration</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt16(System.Int32,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt16(System.String,System.Int16)">
            <summary>
            Bind an instance of a <see cref="T:System.Int16"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int16Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int16"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt32(System.Int32,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt32(System.String,System.Int32)">
            <summary>
            Bind an instance of a <see cref="T:System.Int32"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int32Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int32"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt64(System.Int32,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetInt64(System.String,System.Int64)">
            <summary>
            Bind an instance of a <see cref="T:System.Int64"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.Int64Type"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetSingle(System.Int32,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetSingle(System.String,System.Single)">
            <summary>
            Bind an instance of a <see cref="T:System.Single"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.SingleType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.Single"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetString(System.Int32,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetString(System.String,System.String)">
            <summary>
            Bind an instance of a <see cref="T:System.String"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.StringType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.String"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTime(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTime(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.DateTimeType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimestamp(System.Int32,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to an indexed parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="position">The position of the parameter in the query string, numbered from <c>0</c></param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="M:NHibernate.IQuery.SetTimestamp(System.String,System.DateTime)">
            <summary>
            Bind an instance of a <see cref="T:System.DateTime"/> to a named parameter
            using an NHibernate <see cref="T:NHibernate.Type.TimestampType"/>.
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="val">A non-null instance of a <see cref="T:System.DateTime"/>.</param>
        </member>
        <member name="P:NHibernate.IQuery.QueryString">
            <summary>
            The query string
            </summary>
        </member>
        <member name="P:NHibernate.IQuery.ReturnTypes">
            <summary>
            The Hibernate types of the query result set.
            </summary>
        </member>
        <member name="P:NHibernate.IQuery.NamedParameters">
            <summary>
            The names of all named parameters of the query
            </summary>
            <value>The parameter names, in no particular order</value>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.#ctor(System.String,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="queryString"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetMaxResults(System.Int32)">
            <summary>
            
            </summary>
            <param name="maxResults"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetTimeout(System.Int32)">
            <summary>
            
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetFetchSize(System.Int32)">
            <summary>
            
            </summary>
            <param name="fetchSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetFirstResult(System.Int32)">
            <summary>
            
            </summary>
            <param name="firstResult"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetParameter(System.Int32,System.Object,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetParameter(System.String,System.Object,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetAnsiString(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetString(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetCharacter(System.Int32,System.Char)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetBoolean(System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetByte(System.Int32,System.Byte)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetInt16(System.Int32,System.Int16)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetInt32(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetInt64(System.Int32,System.Int64)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetSingle(System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetDouble(System.Int32,System.Double)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetBinary(System.Int32,System.Byte[])">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetDecimal(System.Int32,System.Decimal)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetDateTime(System.Int32,System.DateTime)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetTime(System.Int32,System.DateTime)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetTimestamp(System.Int32,System.DateTime)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetEntity(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetEnum(System.Int32,System.Enum)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetAnsiString(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetString(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetCharacter(System.String,System.Char)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetBoolean(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetByte(System.String,System.Byte)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetInt16(System.String,System.Int16)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetInt32(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetInt64(System.String,System.Int64)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetSingle(System.String,System.Single)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetDouble(System.String,System.Double)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetBinary(System.String,System.Byte[])">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetDecimal(System.String,System.Decimal)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetDateTime(System.String,System.DateTime)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetTime(System.String,System.DateTime)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetTimestamp(System.String,System.DateTime)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetEntity(System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetEnum(System.String,System.Enum)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetParameter(System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetParameter(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="position"></param>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.GuessType(System.Object)">
            <summary>
            Guesses the <see cref="T:NHibernate.Type.IType"/> from the <c>param</c>'s value.
            </summary>
            <param name="param">The object to guess the <see cref="T:NHibernate.Type.IType"/> of.</param>
            <returns>An <see cref="T:NHibernate.Type.IType"/> for the object.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <c>param</c> is null because the <see cref="T:NHibernate.Type.IType"/>
            can't be guess from a null value.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.GuessType(System.Type)">
            <summary>
            Guesses the <see cref="T:NHibernate.Type.IType"/> from the <see cref="T:System.Type"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to guess the <see cref="T:NHibernate.Type.IType"/> of.</param>
            <returns>An <see cref="T:NHibernate.Type.IType"/> for the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            Thrown when the <c>clazz</c> is null because the <see cref="T:NHibernate.Type.IType"/>
            can't be guess from a null type.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetParameterList(System.String,System.Collections.ICollection,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="vals"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.BindParameterLists(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="namedParams"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetParameterList(System.String,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="vals"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetProperties(System.Object)">
            <summary>
            
            </summary>
            <param name="bean"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetParameterList(System.String,System.Object[],NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="vals"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.SetLockMode(System.String,NHibernate.LockMode)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Impl.AbstractQueryImpl.UniqueResult">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Impl.AbstractQueryImpl.QueryString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.AbstractQueryImpl.NamedParams">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.AbstractQueryImpl.ReturnTypes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.AbstractQueryImpl.NamedParameters">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.AbstractQueryImpl.LockModes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.AbstractQueryImpl.Session">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.AbstractVisitor">
            <summary>
            Abstract superclass of algorithms that walk a tree of property values
            of an entity, and perform specific functionality for collections,
            components and associated entities.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.ProcessValues(System.Object[],NHibernate.Type.IType[])">
            <summary>
            Dispatch each property value to <see cref="M:NHibernate.Impl.AbstractVisitor.ProcessValue(System.Object,NHibernate.Type.IType)"/>.
            </summary>
            <param name="values"></param>
            <param name="types"></param>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.ProcessValue(System.Object,NHibernate.Type.IType)">
            <summary>
            Visit a property value. Dispatch to the correct handler
            for the property type.
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.Process(System.Object,NHibernate.Persister.IClassPersister)">
            <summary>
            Walk the tree starting from the given entity.
            </summary>
            <param name="obj"></param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.ProcessCollection(System.Object,NHibernate.Type.PersistentCollectionType)">
            <summary>
            Visit a collection. Default superclass implementation is a no-op.
            </summary>
            <param name="collection"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.AbstractVisitor.ProcessEntity(System.Object,NHibernate.Type.EntityType)">
            <summary>
            Visit a many-to-one or one-to-one associated entity. Default
            superclass implementation is a no-op.
            </summary>
            <param name="value"></param>
            <param name="entityType"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Impl.BatcherImpl">
            <summary>
            Manages prepared statements and batching. Class exists to enfores seperation of concerns
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Impl.BatcherImpl"/> class.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this Batcher is executing in.</param>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Generate(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="sqlString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Prepare(System.Data.IDbCommand)">
            <summary>
            Prepares the <see cref="T:System.Data.IDbCommand"/> for execution in the database.
            </summary>
            <param name="command"></param>
            <remarks>
            This takes care of hooking the <see cref="T:System.Data.IDbCommand"/> up to an <see cref="T:System.Data.IDbConnection"/>
            and <see cref="T:System.Data.IDbTransaction"/> if one exists.  It will call <c>Prepare</c> if the Driver
            supports preparing commands.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.PrepareBatchCommand(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.PrepareCommand(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.PrepareQueryCommand(NHibernate.SqlCommand.SqlString,System.Boolean)">
            <summary>
            
            </summary>
            <param name="sql"></param>
            <param name="scrollable"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.AbortBatch(System.Exception)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.ExecuteNonQuery(System.Data.IDbCommand)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.ExecuteReader(System.Data.IDbCommand)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.CheckReaders">
            <summary>
            Ensures that the Driver's rules for Multiple Open DataReaders are being followed.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.CloseCommand(System.Data.IDbCommand,System.Data.IDataReader)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="reader"></param>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.CloseCommands">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.CloseQueryCommand(System.Data.IDbCommand,System.Data.IDataReader)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="reader"></param>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.ExecuteBatch">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.DoExecuteBatch(System.Data.IDbCommand)">
            <summary>
            
            </summary>
            <param name="ps"></param>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.AddToBatch(System.Int32)">
            <summary>
            Adds the expected row count into the batch.
            </summary>
            <param name="expectedRowCount">The number of rows expected to be affected by the query.</param>
            <remarks>
            If Batching is not supported, then this is when the Command should be executed.  If Batching
            is supported then it should hold of on executing the batch until explicitly told to.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.BatcherImpl._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatcherImpl.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this BatcherImpl is being Disposed of or Finalized.</param>
            <remarks>
            If this BatcherImpl is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this BatcherImpl back to life.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.BatcherImpl.CurrentCommand">
            <summary>
            Gets the current <see cref="T:System.Data.IDbCommand"/> that is contained for this Batch
            </summary>
            <value>The current <see cref="T:System.Data.IDbCommand"/>.</value>
        </member>
        <member name="P:NHibernate.Impl.BatcherImpl.Factory">
            <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> the Batcher was
            created in.
            </summary>
            <value>
            The <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> the Batcher was
            created in.
            </value>
        </member>
        <member name="P:NHibernate.Impl.BatcherImpl.Session">
            <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionImplementor"/> the Batcher is handling the 
            sql actions for.
            </summary>
            <value>
            The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the Batcher is handling the 
            sql actions for.
            </value>
        </member>
        <member name="T:NHibernate.Impl.BatchingBatcher">
            <summary>
            Summary description for BatchingBatcher.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.BatchingBatcher.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Impl.BatchingBatcher.AddToBatch(System.Int32)">
            <summary>
            
            </summary>
            <param name="expectedRowCount"></param>
        </member>
        <member name="M:NHibernate.Impl.BatchingBatcher.DoExecuteBatch(System.Data.IDbCommand)">
            <summary>
            
            </summary>
            <param name="ps"></param>
        </member>
        <member name="T:NHibernate.Impl.CacheEntry">
            <summary>
            A cached instance of a persistent class
            </summary>
        </member>
        <member name="M:NHibernate.Impl.CacheEntry.#ctor(System.Object,NHibernate.Persister.IClassPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="persister"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Impl.CacheEntry.Disassemble(System.Object,NHibernate.Persister.IClassPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="persister"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.CacheEntry.Assemble(System.Object,System.Object,NHibernate.Persister.IClassPersister,NHibernate.IInterceptor,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <param name="id"></param>
            <param name="persister"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.CacheEntry.Assemble(System.Object[],System.Object,System.Object,NHibernate.Persister.IClassPersister,NHibernate.IInterceptor,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="values"></param>
            <param name="result"></param>
            <param name="id"></param>
            <param name="persister"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Impl.CacheEntry.Subclass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.CollectionEntry">
            <summary>
            We need an entry to tell us all about the current state
            of a collection with respect to its persistent state
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.dirty">
            <summary>
            Collections detect changes made via their public interface
            and mark themselves as dirty. False by default.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.reached">
            <summary>
            Indicates that the Collection can still be reached by an Entity
            that exist in the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <remarks>
            It is also used to ensure that the Collection is not shared between
            two Entities.  
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.processed">
            <summary>
            Indicates that the Collection has been processed and is ready
            to have its state synchronized with the database.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.doupdate">
            <summary>
            Indicates that a Collection needs to be updated.
            </summary>
            <remarks>
            A Collection needs to be updated whenever the contents of the Collection
            have been changed. 
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.doremove">
            <summary>
            Indicates that a Collection has old elements that need to be removed.
            </summary>
            <remarks>
            A Collection needs to have removals performed whenever its role changes or
            the key changes and it has a loadedPersister - ie - it was loaded by NHibernate.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.dorecreate">
            <summary>
            Indicates that a Collection needs to be recreated.
            </summary>
            <remarks>
            A Collection needs to be recreated whenever its role changes
            or the owner changes.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.ignore">
            <summary>
            If we instantiate a collection during the <see cref="M:NHibernate.ISession.Flush"/>
            process, we must ignore it for the rest of the flush.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.initialized">
            <summary>
            Indicates that the Collection has been fully initialized.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.currentPersister">
            <summary>
            The <see cref="T:NHibernate.Collection.ICollectionPersister"/> that is currently responsible
            for the Collection.
            </summary>
            <remarks>
            This is set when NHibernate is updating a reachable or an
            unreachable collection.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.loadedPersister">
            <summary>
            The <see cref="T:NHibernate.Collection.ICollectionPersister"/> when the Collection was loaded.
            </summary>
            <remarks>
            This can be <c>null</c> if the Collection was not loaded by NHibernate and 
            was passed in along with a transient object.
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.loadedKey">
            <summary>
            The identifier of the Entity that is the owner of this Collection 
            during the load or post flush.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.snapshot">
            <summary>session-start/post-flush persistent state</summary>
        </member>
        <member name="F:NHibernate.Impl.CollectionEntry.role">
            <summary>allow the snapshot to be serialized</summary>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.CollectionEntry"/>.
            </summary>
            <remarks> 
            The CollectionEntry is for a Collection that is not dirty and 
            has already been initialized.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.#ctor(NHibernate.Collection.ICollectionPersister,System.Object,System.Boolean)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.CollectionEntry"/>. 
            </summary>
            <param name="loadedPersister">The <see cref="T:NHibernate.Collection.ICollectionPersister"/> that persists this Collection type.</param>
            <param name="loadedID">The identifier of the Entity that is the owner of this Collection.</param>
            <param name="ignore">A boolean indicating whether to ignore the collection during current (or next) flush.</param>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.#ctor(NHibernate.Engine.ICollectionSnapshot,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.CollectionEntry"/>. 
            </summary>
            <param name="cs">The <see cref="T:NHibernate.Engine.ICollectionSnapshot"/> from another <see cref="T:NHibernate.ISession"/>.</param>
            <param name="factory">The <see cref="T:NHibernate.Engine.ISessionFactoryImplementor"/> that created this <see cref="T:NHibernate.ISession"/>.</param>
            <remarks>
            This takes an <see cref="T:NHibernate.Engine.ICollectionSnapshot"/> from another <see cref="T:NHibernate.ISession"/> and 
            creates an entry for it in this <see cref="T:NHibernate.ISession"/> by copying the values from the 
            <c>cs</c> parameter.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.IsDirty(NHibernate.Collection.PersistentCollection)">
            <summary>
            Checks to see if the <see cref="T:NHibernate.Collection.PersistentCollection"/> has had any changes to the 
            collections contents or if any of the elements in the collection have been modified.
            </summary>
            <param name="coll"></param>
            <returns><c>true</c> if the <see cref="T:NHibernate.Collection.PersistentCollection"/> is dirty.</returns>
            <remarks>
            default behavior; will be overridden in deep lazy collections
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.PreFlush(NHibernate.Collection.PersistentCollection)">
            <summary>
            Prepares this CollectionEntry for the Flush process.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.PersistentCollection"/> that this CollectionEntry will be responsible for flushing.</param>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.PostInitialize(NHibernate.Collection.PersistentCollection)">
            <summary>
            Updates the CollectionEntry to reflect that the <see cref="T:NHibernate.Collection.PersistentCollection"/>
            has been initialized.
            </summary>
            <param name="collection">The initialized <see cref="T:NHibernate.Collection.PersistentCollection"/> that this Entry is for.</param>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.PostFlush(NHibernate.Collection.PersistentCollection)">
            <summary>
            Updates the CollectionEntry to reflect that it is has been successfully flushed to the database.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.PersistentCollection"/> that was flushed.</param>
            <remarks>
            Called after a <em>successful</em> flush.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.CollectionEntry.SetLoadedPersister(NHibernate.Collection.ICollectionPersister)">
            <summary>
            Sets the information in this CollectionEntry that is specific to the
            <see cref="T:NHibernate.Collection.ICollectionPersister"/>.
            </summary>
            <param name="persister">
            The <see cref="T:NHibernate.Collection.ICollectionPersister"/> that is 
            responsible for the Collection.
            </param>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.Key">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.Role">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.Snapshot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.Dirty">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.WasDereferenced">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.SnapshotIsEmpty">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.CollectionEntry.IsNew">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.CriteriaImpl">
            <summary>
            Implementation of the <see cref="T:NHibernate.ICriteria"/> interface
            </summary>
        </member>
        <member name="T:NHibernate.ICriteria">
            <summary>
            <p>
            Criteria is a simplified API for retrieving entities
            by composing Expression objects. This is a very
            convenient approach for functionality like "search" screens
            where there is a variable number of conditions to be placed
            upon the result set.
            </p>
            <p>
            The Session is a factory for ICriteria. 
            Expression instances are usually obtained via 
            the factory methods on Expression. eg:
            <code>
            IList cats = session.CreateCriteria(typeof(Cat)) 
                .Add( Expression.Like("name", "Iz%") ) 
                .Add( Expression.Gt( "weight", minWeight ) ) 
                .AddOrder( Order.Asc("age") ) 
                .List(); 
            </code> 
            You may navigate associations using <c>CreateAlias()</c> or
            <c>CreateCriteria()</c>.
            <code>
            IList cats = session.CreateCriteria(typeof(Cat))
            	.CreateCriteria("kittens")
            		.Add( Expression.like("name", "Iz%") )
            		.List();
            </code>
            Hibernate's query language is much more general
            and should be used for non-simple cases.
            </p>
            This is an experimental API
            </summary>
        </member>
        <member name="M:NHibernate.ICriteria.SetMaxResults(System.Int32)">
            <summary>
            Set a limit upon the number of objects to be retrieved
            </summary>
            <param name="maxResults"></param>
        </member>
        <member name="M:NHibernate.ICriteria.SetFirstResult(System.Int32)">
            <summary>
            Set the first result to be retrieved
            </summary>
            <param name="firstResult"></param>
        </member>
        <member name="M:NHibernate.ICriteria.SetTimeout(System.Int32)">
            <summary>
            Set a timeout for the underlying ADO.NET query
            </summary>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.Add(NHibernate.Expression.ICriterion)">
            <summary>
            Add an Expression to constrain the results to be retrieved.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.AddOrder(NHibernate.Expression.Order)">
            <summary>
            An an Order to the result set 
            </summary>
            <param name="order"></param>
        </member>
        <member name="M:NHibernate.ICriteria.List">
            <summary>
            Get the results
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.UniqueResult">
            <summary>
            Convenience method to return a single instance that matches
            the query, or null if the query returns no results.
            </summary>
            <returns>the single result or <c>null</c></returns>
            <exception cref="T:NHibernate.HibernateException">
            If there is more than one matching result
            </exception>
        </member>
        <member name="M:NHibernate.ICriteria.SetFetchMode(System.String,NHibernate.FetchMode)">
            <summary>
            Specify an association fetching strategy.  Currently, only
            one-to-many and one-to-one associations are supported.
            </summary>
            <param name="associationPath">A dot seperated property path.</param>
            <param name="mode">The Fetch mode.</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateAlias(System.String,System.String)">
            <summary>
            Join an association, assigning an alias to the joined entity
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity
            </summary>
            <param name="associationPath"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.CreateCriteria(System.String,System.String)">
            <summary>
            Create a new <see cref="T:NHibernate.ICriteria"/>, "rooted" at the associated entity,
            assigning the given alias
            </summary>
            <param name="associationPath"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.GetCriteriaClass(System.String)">
            <summary>
            Get the persistent class that the alias refers to
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetResultTransformer(NHibernate.Transform.IResultTransformer)">
            <summary>
            Set a strategy for handling the query results. This determines the
            "shape" of the query result set.
            <seealso cref="F:NHibernate.CriteriaUtil.RootEntity"/>
            <seealso cref="F:NHibernate.CriteriaUtil.DistinctRootEntity"/>
            <seealso cref="F:NHibernate.CriteriaUtil.AliasToEntityMap"/>
            </summary>
            <param name="resultTransformer"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetLockMode(NHibernate.LockMode)">
            <summary>
            Set the lock mode of the current entity
            </summary>
            <param name="lockMode">the lock mode</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetLockMode(System.String,NHibernate.LockMode)">
            <summary>
            Set the lock mode of the aliased entity
            </summary>
            <param name="alias">an alias</param>
            <param name="lockMode">the lock mode</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetCacheable(System.Boolean)">
            <summary>
            Enable caching of this query result set
            </summary>
            <param name="cacheable"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICriteria.SetCacheRegion(System.String)">
            <summary>
            Set the name of the cache region.
            </summary>
            <param name="cacheRegion">the name of a query cache region, or <c>null</c>
            for the default query cache</param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.ICriteria.CriteriaClass">
            <summary>
            Get the persistent class that this <c>ICriteria</c> applies to
            </summary>
        </member>
        <member name="M:NHibernate.Impl.CriteriaImpl.#ctor(System.Type,NHibernate.Impl.CriteriaImpl)">
            <summary>
            Copy all the internal attributes of the given CriteriaImpl
            except alter the root persistent class type to be the given one.
            </summary>
            <param name="persistentClass"></param>
            <param name="original"></param>
        </member>
        <member name="T:NHibernate.Impl.DirtyCollectionSearchVisitor">
            <summary>
            A Visitor that determines if a dirty collection was found.
            </summary>
            <remarks>
            <list type="number">
            	<listheader>
            		<description>Reason for dirty collection</description>
            	</listheader>
            	<item>
            		<description>
            		If it is a new application-instantiated collection, return true (does not occur anymore!)
            		</description>
            	</item>
            	<item>
            		<description>
            		If it is a component, recurse.
            		</description>
            	</item>
            	<item>
            		<description>
            		If it is a wrapped collection, ask the collection entry.
            		</description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.DirtyCollectionSearchVisitor.WasDirtyCollectionFound">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if a dirty collection was found.
            </summary>
            <value><c>true</c> if a dirty collection was found.</value>
        </member>
        <member name="T:NHibernate.Impl.EntityEntry">
            <summary>
            We need an entry to tell us all about the current state
            of an object with respect to its persistent state
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EntityEntry.#ctor(NHibernate.Impl.Status,System.Object[],System.Object,System.Object,NHibernate.LockMode,System.Boolean,NHibernate.Persister.IClassPersister,System.Boolean)">
            <summary>
            Initializes a new instance of EntityEntry.
            </summary>
            <param name="status">The current <see cref="P:NHibernate.Impl.EntityEntry.Status"/> of the Entity.</param>
            <param name="loadedState">The snapshot of the Entity's state when it was loaded.</param>
            <param name="id">The identifier of the Entity in the database.</param>
            <param name="version">The version of the Entity.</param>
            <param name="lockMode">The <see cref="P:NHibernate.Impl.EntityEntry.LockMode"/> for the Entity.</param>
            <param name="existsInDatabase">A boolean indicating if the Entity exists in the database.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for this Entity.</param>
            <param name="disableVersionIncrement"></param>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.LockMode">
            <summary>
            Gets or sets the current <see cref="P:NHibernate.Impl.EntityEntry.LockMode"/> of the Entity.
            </summary>
            <value>The <see cref="P:NHibernate.Impl.EntityEntry.LockMode"/> of the Entity.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.Status">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Impl.EntityEntry.Status"/> of this Entity with respect to its 
            persistence in the database.
            </summary>
            <value>The <see cref="P:NHibernate.Impl.EntityEntry.Status"/> of this Entity.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.Id">
            <summary>
            Gets or sets the identifier of the Entity in the database.
            </summary>
            <value>The identifier of the Entity in the database if one has been assigned.</value>
            <remarks>This might be <c>null</c> when the <see cref="P:NHibernate.Impl.EntityEntry.Status"/> is 
            <see cref="F:NHibernate.Impl.Status.Saving"/> and the database generates the id.</remarks>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.LoadedState">
            <summary>
            Gets or sets the snapshot of the Entity when it was loaded from the database.
            </summary>
            <value>The snapshot of the Entity.</value>
            <remarks>
            There will only be a value when the Entity was loaded in the current Session.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.DeletedState">
            <summary>
            Gets or sets the snapshot of the Entity when it was marked as being ready for deletion.
            </summary>
            <value>The snapshot of the Entity.</value>
            <remarks>This will be <c>null</c> if the Entity is not being deleted.</remarks>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.ExistsInDatabase">
            <summary>
            Gets or sets a <see cref="T:System.Boolean"/> indicating if this Entity exists in the database.
            </summary>
            <value><c>true</c> if it is already in the database.</value>
            <remarks>
            It can also be <c>true</c> if it does not exists in the database yet and the 
            <see cref="P:NHibernate.Persister.IClassPersister.IsIdentifierAssignedByInsert"/> is <c>true</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.Version">
            <summary>
            Gets or sets the version of the Entity.
            </summary>
            <value>The version of the Entity.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.Persister">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for this Entity.
            </summary>
            <value>The <see cref="T:NHibernate.Persister.IClassPersister"/> that is reponsible for this Entity.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.ClassName">
            <summary>
            Gets the Fully Qualified Name of the class this Entity is an instance of.
            </summary>
            <value>The Fully Qualified Name of the class this Entity is an instance of.</value>
        </member>
        <member name="P:NHibernate.Impl.EntityEntry.IsBeingReplicated">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Impl.EnumerableImpl">
            <summary>
            Provides an <see cref="T:System.Collections.IEnumerable"/> wrapper over the results of an <see cref="T:NHibernate.IQuery"/>.
            </summary>
            <remarks>
            This is the IteratorImpl in H2.0.3
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.#ctor(System.Data.IDataReader,System.Data.IDbCommand,NHibernate.Engine.ISessionImplementor,NHibernate.Type.IType[],System.String[][],NHibernate.Engine.RowSelection,System.Type)">
            <summary>
            Create an <see cref="T:System.Collections.IEnumerable"/> wrapper over an <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="reader">The <see cref="T:System.Data.IDataReader"/> to enumerate over.</param>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> used to create the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="sess">The <see cref="T:NHibernate.ISession"/> to use to load objects.</param>
            <param name="types">The <see cref="T:NHibernate.Type.IType"/>s contained in the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="columnNames">The names of the columns in the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="selection">The <see cref="T:NHibernate.Engine.RowSelection"/> that should be applied to the <see cref="T:System.Data.IDataReader"/>.</param>
            <param name="holderType">Optional type of the result holder (used for "select new SomeClass(...)" queries).</param>
            <remarks>
            The <see cref="T:System.Data.IDataReader"/> should already be positioned on the first record in <see cref="T:NHibernate.Engine.RowSelection"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.GetEnumerator">
            <summary>
            Returns an enumerator that can iterate through the query results.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the query results.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.MoveNext">
             <summary>
             Advances the enumerator to the next element of the query results.
             </summary>
             <returns>
             <c>true</c> if the enumerator was successfully advanced to the next query results
             ; <c>false</c> if the enumerator has passed the end of the query results.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Reset">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Impl.EnumerableImpl._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.EnumerableImpl.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this EnumerableImpl is being Disposed of or Finalized.</param>
            <remarks>
            The command is closed and the reader is disposed.  This allows other ADO.NET
            related actions to occur without needing to move all the way through the
            EnumerableImpl.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.EnumerableImpl.Current">
            <summary>
            Gets the current element in the query results.
            </summary>
            <value>
            The current element in the query results which is either an object or 
            an object array.
            </value>
            <remarks>
            If the <see cref="T:NHibernate.IQuery"/> only returns one type of Entity then an object will
            be returned.  If this is a multi-column resultset then an object array will be
            returned.
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.EvictVisitor">
            <summary>
            Evict any collections referenced by the object from the ISession cache.
            </summary>
            <remarks>
            This will <b>NOT</b> pick up any collections that were dereferenced, so
            they will be deleted (suboptimal but not exactly incorrect).
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.FilterImpl">
            <summary>
            Implementation of the <see cref="T:NHibernate.IQuery"/> interface for collection filters.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.QueryImpl.Enumerable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.QueryImpl.List">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.#ctor(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="queryString"></param>
            <param name="collection"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.Enumerable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.FilterImpl.List">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.IExecutable">
            <summary>
            An action that <see cref="T:NHibernate.ISession"/> can Execute during a
            <c>Flush</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.IExecutable.BeforeExecutions">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Impl.IExecutable.Execute">
            <summary>
            Execute the action required to write changes to the database.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.IExecutable.AfterTransactionCompletion(System.Boolean)">
            <summary>
            Called after the Transaction has been completed.
            </summary>
            <param name="success"></param>
            <remarks>
            Actions should make sure that the Cache is notified about
            what just happened.
            </remarks>
        </member>
        <member name="P:NHibernate.Impl.IExecutable.HasAfterTransactionCompletion">
            <summary>
            Does the executable have an AfterTransactionCompletion process
            </summary>
        </member>
        <member name="P:NHibernate.Impl.IExecutable.PropertySpaces">
            <summary>
            The spaces (tables) that are affectd by this Executable action.
            </summary>
            <remarks>
            This is used to determine if the ISession needs to be flushed before
            a query is executed so stale data is not returned.
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.MessageHelper">
            <summary>
            Helper methods for rendering log messages and exception messages
            </summary>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(System.Type,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to create the string from.</param>
            <param name="id">The identifier of the object.</param>
            <returns>A descriptive <see cref="T:System.String"/> in the format of <c>[classname#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.IClassPersister,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> for the class in question</param>
            <param name="id">The id</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[FooBar#id]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Persister.IClassPersister)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> for the class in question</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[FooBar]</c></returns>
        </member>
        <member name="M:NHibernate.Impl.MessageHelper.InfoString(NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            Generate small message that can be used in traces and exception messages.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Collection.ICollectionPersister"/> for the class in question</param>
            <param name="id">The id</param>
            <returns>A descriptive <see cref="T:System.String"/> in the form <c>[collectionrole#id]</c></returns>
        </member>
        <member name="T:NHibernate.Impl.NonBatchingBatcher">
            <summary>
            An implementation of the <see cref="T:NHibernate.Engine.IBatcher"/> 
            interface that does no batching.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.NonBatchingBatcher.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Impl.NonBatchingBatcher"/> class.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the Batcher is in.</param>
        </member>
        <member name="M:NHibernate.Impl.NonBatchingBatcher.AddToBatch(System.Int32)">
            <summary>
            Executes the current <see cref="T:System.Data.IDbCommand"/> and compares the row Count
            to the <c>expectedRowCount</c>.
            </summary>
            <param name="expectedRowCount">
            The expected number of rows affected by the query.  A value of less than <c>0</c>
            indicates that the number of rows to expect is unknown or should not be a factor.
            </param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when there is an expected number of rows to be affected and the
            actual number of rows is different.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.NonBatchingBatcher.DoExecuteBatch(System.Data.IDbCommand)">
            <summary>
            This Batcher implementation does not support batching so this is a no-op call.  The
            actual execution of the <see cref="T:System.Data.IDbCommand"/> is run in the <c>AddToBatch</c> 
            method.
            </summary>
            <param name="ps"></param>
        </member>
        <member name="T:NHibernate.Impl.OnLockVisitor">
            <summary>
            When a transient entity is passed to <see cref="M:NHibernate.ISession.Lock(System.Object,NHibernate.LockMode)"/>, we must inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the
               existing snapshot
            3. throw an exception for each "new" collection
            </summary>
        </member>
        <member name="T:NHibernate.Impl.ReattachVisitor">
            <summary>
            Abstract superclass of visitors that reattach collections
            </summary>
        </member>
        <member name="T:NHibernate.Impl.ProxyVisitor">
            <summary>
            Reassociates uninitialized Proxies with the Session.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.OnReplicateVisitor">
            <summary>
            When an entity is passed to Update(), we must inspect all its collections and
            1. associate any uninitialized PersistentCollections with this session
            2. associate any initialized PersistentCollections with this session, using the existing snapshot
            3. execute a collection removal (SQL DELETE) for each null collection property or "new" collection
            </summary>
        </member>
        <member name="T:NHibernate.Impl.OnUpdateVisitor">
            <summary>
            When an entity is passed to <c>Update()</c>, all its collections must be
            inspected and:
            <list type="number">
            	<item>
            		<description>
            		Associate any uninitialized PersistentCollections with this Session.
            		</description>
            	</item>
            	<item>
            		<description>
            		Associate any initialized PersistentCollections with this Session, using the
            		existing snapshot.
            		</description>
            	</item>
            	<item>
            		<description>
            		Execute a collection removal (SQL DELETE) for each null collection property
            		or "new" collection.
            		</description>
            	</item>
            </list>
            </summary>
        </member>
        <member name="M:NHibernate.Impl.Printer.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="entity">an actual entity object, not a proxy!</param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Impl.ScheduledCollectionAction">
            <summary>
            The base class for a scheduled action to perform on a Collection during a
            flush.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionAction.#ctor(NHibernate.Collection.ICollectionPersister,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledCollectionAction"/>.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="id">The identifier of the Collection owner.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionAction.AfterTransactionCompletion(System.Boolean)">
            <summary></summary>
            <param name="success"></param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionAction.BeforeExecutions">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionAction.Evict">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledCollectionAction.Persister">
            <summary>
            Gets the <see cref="T:NHibernate.Collection.ICollectionPersister"/> that is responsible for persisting the Collection.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledCollectionAction.Id">
            <summary>
            Gets the identifier of the Collection owner.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledCollectionAction.Session">
            <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionImplementor"/> the action is executing in.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledCollectionAction.PropertySpaces">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledCollectionRecreate">
            <summary>
            A scheduled recreation of the Collection in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionRecreate.#ctor(NHibernate.Collection.PersistentCollection,NHibernate.Collection.ICollectionPersister,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledCollectionRecreate"/>.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.PersistentCollection"/> to recreate.</param>
            <param name="persister">The <see cref="T:NHibernate.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="id">The identifier of the Collection owner.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionRecreate.Execute">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledCollectionRemove">
            <summary>
            A scheduled removal of the Collection from the database.
            </summary>
            <remarks>
            This Collection is not represented in the database anymore.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionRemove.#ctor(NHibernate.Collection.ICollectionPersister,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledCollectionRemove"/>.
            </summary>
            <param name="persister">The <see cref="T:NHibernate.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="id">The identifier of the Collection owner.</param>
            <param name="emptySnapshot">Indicates if the Collection was empty when it was loaded.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionRemove.Execute">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledCollectionUpdate">
            <summary>
            A scheduled update of the Collection in the database.
            </summary>
            <remarks>
            Entities in the Collection or the contents of the Collection have been modified
            and the database should be updated accordingly.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionUpdate.#ctor(NHibernate.Collection.PersistentCollection,NHibernate.Collection.ICollectionPersister,System.Object,System.Boolean,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledCollectionUpdate"/>.
            </summary>
            <param name="collection">The <see cref="T:NHibernate.Collection.PersistentCollection"/> to update.</param>
            <param name="persister">The <see cref="T:NHibernate.Collection.ICollectionPersister"/> that is responsible for the persisting the Collection.</param>
            <param name="id">The identifier of the Collection owner.</param>
            <param name="emptySnapshot">Indicates if the Collection was empty when it was loaded.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledCollectionUpdate.Execute">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledDeletion">
            <summary>
            A scheduled deletion of an object.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledEntityAction">
            <summary>
            The base class for a scheduled action to perform on an entity during a
            flush.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledEntityAction.#ctor(NHibernate.Engine.ISessionImplementor,System.Object,System.Object,NHibernate.Persister.IClassPersister)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledEntityAction"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
            <param name="id">The identifier of the object.</param>
            <param name="instance">The actual object instance.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for the persisting the object.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledEntityAction.BeforeExecutions">
            <summary>
            
            </summary>
            <remarks>Not supported for a non-collection entity</remarks>
        </member>
        <member name="M:NHibernate.Impl.ScheduledEntityAction.AfterTransactionCompletion(System.Boolean)">
            <summary>
            Called when the Transaction this action occurred in has completed.
            </summary>
            <param name="success"></param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledEntityAction.Execute">
            <summary>
            Execute the action using the <see cref="T:NHibernate.Persister.IClassPersister"/>.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.Session">
            <summary>
            Gets the <see cref="T:NHibernate.Engine.ISessionImplementor"/> the action is executing in.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.Id">
            <summary>
            Gets the identifier of the object.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.Persister">
            <summary>
            Gets the <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for persisting the object.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.Instance">
            <summary>
            Gets the object that is having the scheduled action performed against it.
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.HasAfterTransactionCompletion">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Impl.ScheduledEntityAction.PropertySpaces">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledDeletion.#ctor(System.Object,System.Object,System.Object,NHibernate.Persister.IClassPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledDeletion"/>.
            </summary>
            <param name="id">The identifier of the object.</param>
            <param name="version">The version of the object being deleted.</param>
            <param name="instance">The actual object instance.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for the persisting the object.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledDeletion.Execute">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledDeletion.AfterTransactionCompletion(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledIdentityInsertion">
            <summary>
            Summary description for ScheduledIdentityInsertion.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledIdentityInsertion.#ctor(System.Object[],System.Object,NHibernate.Persister.IClassPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="state"></param>
            <param name="instance"></param>
            <param name="persister"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledIdentityInsertion.AfterTransactionCompletion(System.Boolean)">
            <summary>
            
            </summary>
            <param name="sucess"></param>
        </member>
        <member name="P:NHibernate.Impl.ScheduledIdentityInsertion.HasAfterTransactionCompletion">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledInsertion">
            <summary>
            A scheduled insertion of an object.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledInsertion.#ctor(System.Object,System.Object[],System.Object,System.Object,NHibernate.Persister.IClassPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledInsertion"/>.
            </summary>
            <param name="id">The identifier of the object.</param>
            <param name="state">An object array that contains the state of the object being inserted.</param>
            <param name="instance">The actual object instance.</param>
            <param name="version">The version of the object instance.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for the persisting the object.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledInsertion.Execute">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledInsertion.AfterTransactionCompletion(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.ScheduledUpdate">
            <summary>
            A scheduled update of an object.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledUpdate.#ctor(System.Object,System.Object[],System.Int32[],System.Object[],System.Object,System.Object,System.Object,System.Object[],NHibernate.Persister.IClassPersister,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Impl.ScheduledUpdate"/>.
            </summary>
            <param name="id">The identifier of the object.</param>
            <param name="fields">An array of objects that contains the value of each Property.</param>
            <param name="dirtyProperties">An array that contains the indexes of the dirty Properties.</param>
            <param name="oldFields"></param>
            <param name="lastVersion">The current version of the object.</param>
            <param name="nextVersion">The version the object should be after update.</param>
            <param name="instance">The actual object instance.</param>
            <param name="updatedState">A deep copy of the <c>fields</c> object array.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> that is responsible for the persisting the object.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> that the Action is occuring in.</param>
        </member>
        <member name="M:NHibernate.Impl.ScheduledUpdate.Execute">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.ScheduledUpdate.AfterTransactionCompletion(System.Boolean)">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryImpl">
            <summary>
             Concrete implementation of a SessionFactory.
            </summary>
            <remarks>
            Has the following responsibilities:
            <list type="">
            <item>
            Caches configuration settings (immutably)</item>
            <item>
            Caches "compiled" mappings - ie. <see cref="T:NHibernate.Persister.IClassPersister"/> 
            and <see cref="T:NHibernate.Collection.ICollectionPersister"/>
            </item>
            <item>
            Caches "compiled" queries (memory sensitive cache)
            </item>
            <item>
            Manages <c>PreparedStatements/IDbCommands</c> - how true in NH?
            </item>
            <item>
            Delegates <c>IDbConnection</c> management to the <see cref="T:NHibernate.Connection.IConnectionProvider"/>
            </item>
            <item>
            Factory for instances of <see cref="T:NHibernate.ISession"/>
            </item>
            </list>
            <para>
            This class must appear immutable to clients, even if it does all kinds of caching
            and pooling under the covers.  It is crucial that the class is not only thread safe
            , but also highly concurrent.  Synchronization must be used extremely sparingly.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.#ctor(NHibernate.Cfg.Configuration,NHibernate.Cfg.Settings)">
            <summary>
            
            </summary>
            <param name="cfg"></param>
            <param name="settings"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenSession(System.Data.IDbConnection,NHibernate.IInterceptor)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <param name="interceptor"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenSession(NHibernate.IInterceptor)">
            <summary>
            
            </summary>
            <param name="interceptor"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenSession(System.Data.IDbConnection)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenSession">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetPersister(System.Type)">
            <summary>
            
            </summary>
            <param name="theClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenDatabinder">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetNamedQuery(System.String)">
            <summary>
            Gets the <c>hql</c> query identified by the <c>name</c>.
            </summary>
            <param name="name">The name of that identifies the query.</param>
            <returns>
            A <c>hql</c> query or <c>null</c> if the named
            query does not exist.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetNamedSQLQuery(System.String)">
            <summary>
            
            </summary>
            <param name="queryName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetIdentifierType(System.Type)">
            <summary>
            
            </summary>
            <param name="objectClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetIdentifierPropertyName(System.Type)">
            <summary>
            
            </summary>
            <param name="objectClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetImplementors(System.Type)">
            <summary>
            Return the names of all persistent (mapped) classes that extend or implement the
            given class or interface, accounting for implicit/explicit polymorphism settings
            and excluding mapped subclasses/joined-subclasses of other classes in the result.
            </summary>
            <param name="clazz"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetImplementorClasses(System.Type)">
            <summary>
            Added to solve a problem with SessionImpl.Find( CriteriaImpl ),
            see the comment there for an explanation.
            </summary>
            <param name="clazz"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetAllClassMetadata">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.GetAllCollectionMetadata">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.Close">
            <summary>
            Closes the session factory, releasing all held resources.
            <list>
            <item>cleans up used cache regions and "stops" the cache provider.</item>
            <item>close the ADO.NET connection</item>
            </list>
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.OpenConnection">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryImpl.CloseConnection(System.Data.IDbConnection)">
            <summary>
            
            </summary>
            <param name="conn"></param>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.Dialect">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.TransactionFactory">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsBatchUpdateEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.BatchSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsScrollableResultSetsEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsGetGeneratedKeysEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsOuterJoinedFetchEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.DefaultSchema">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.MaximumFetchDepth">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.IsShowSqlEnabled">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.FetchSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.ConnectionProvider">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.Isolation">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionFactoryImpl.PrepareSql">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryImpl.QueryCacheKey">
            <summary>
            A class that can be used as a Key in a Hashtable for 
            a Query Cache.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryImpl.FilterCacheKey">
            <summary>
            A class that can be used as a Key in a Hashtable for 
            a Query Cache.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.SessionFactoryObjectFactory">
            <summary>
            Resolves <see cref="T:NHibernate.ISessionFactory"/> lookups and deserialization.
            </summary>
            <remarks>
            <para>
            This is used heavily be Deserialization.  Currently a SessionFactory is not really serialized. 
            All that is serialized is it's name and uid.  During Deserializaiton the serialized SessionFactory
            is converted to the one contained in this object.  So if you are serializing across AppDomains
            you should make sure that "name" is specified for the SessionFactory in the hbm.xml file and that the
            other AppDomain has a configured SessionFactory with the same name.  If
            you are serializing in the same AppDomain then there will be no problem because the uid will
            be in this object.
            </para>
            <para>
            TODO: verify that the AppDomain statements are correct.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.AddInstance(System.String,System.String,NHibernate.ISessionFactory,System.Collections.IDictionary)">
            <summary>
            Adds an Instance of the SessionFactory to the local "cache".
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <param name="name">The name of the ISessionFactory.</param>
            <param name="instance">The ISessionFactory.</param>
            <param name="properties">The configured properties for the ISessionFactory.</param>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.RemoveInstance(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            Removes the Instance of the SessionFactory from the local "cache".
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <param name="name">The name of the ISessionFactory.</param>
            <param name="properties">The configured properties for the ISessionFactory.</param>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.GetNamedInstance(System.String)">
            <summary>
            Returns a Named Instance of the SessionFactory from the local "cache" identified by name.
            </summary>
            <param name="name">The name of the ISessionFactory.</param>
            <returns>An instantiated ISessionFactory.</returns>
        </member>
        <member name="M:NHibernate.Impl.SessionFactoryObjectFactory.GetInstance(System.String)">
            <summary>
            Returns an Instance of the SessionFactory from the local "cache" identified by UUID.
            </summary>
            <param name="uid">The identifier of the ISessionFactory.</param>
            <returns>An instantiated ISessionFactory.</returns>
        </member>
        <member name="T:NHibernate.Impl.SessionImpl">
            <summary>
            Concrete implementation of a Session, also the central, organizing component
            of Hibernate's internal implementation.
            </summary>
            <remarks>
            Exposes two interfaces: ISession itself, to the application and ISessionImplementor
            to other components of hibernate. This is where the hard stuff is...
            NOT THREADSAFE
            </remarks>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.closed">
            <summary>
            Indicates if the Session has been closed.
            </summary>
            <value>
            <c>false</c> (by default) if the Session is Open and can be used, 
            <c>true</c> if the Session has had the methods <c>Close()</c> or
            <c>Dispose()</c> invoked.</value>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.entitiesByKey">
            <summary>
            An <see cref="T:System.Collections.IDictionary"/> with the <see cref="T:NHibernate.Engine.Key"/> as the key
            and an <see cref="T:System.Object"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.proxiesByKey">
            <summary>
            An <see cref="T:System.Collections.IDictionary"/> with the <see cref="T:NHibernate.Engine.Key"/> as the key
            and an <see cref="T:NHibernate.Proxy.INHibernateProxy"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.entityEntries">
            <summary>
            An <see cref="T:NHibernate.Util.IdentityMap"/> with the <see cref="T:System.Object"/> as the key
            and an <see cref="T:NHibernate.Impl.EntityEntry"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.arrayHolders">
            <summary>
            An <see cref="T:NHibernate.Util.IdentityMap"/> with the <see cref="T:System.Array"/> as the key
            and an <see cref="T:NHibernate.Collection.ArrayHolder"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.collectionEntries">
            <summary>
            An <see cref="T:NHibernate.Util.IdentityMap"/> with the <see cref="T:NHibernate.Collection.PersistentCollection"/> as the key
            and an <see cref="T:NHibernate.Impl.CollectionEntry"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.collectionsByKey">
            <summary>
            An <see cref="T:NHibernate.Util.IdentityMap"/> with the <see cref="T:NHibernate.Impl.CollectionKey"/> as the key
            and an <see cref="T:NHibernate.Collection.PersistentCollection"/> as the value.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.nullifiables">
            <summary>
            An <see cref="T:Iesi.Collections.ISet"/> of <see cref="T:NHibernate.Engine.Key"/> objects of the deleted entities.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl.connect">
            <summary>
            A boolean indicating if the Session should automattically connect to the
            database - ie, open a new <see cref="T:System.Data.IDbConnection"/> for the operation if
            <c>this.Connection==null</c>.
            </summary>
            <remarks>
            <p>
            This will be initialzed to <c>true</c> by the ctor if NHibernate is managing
            the Connections, <c>false</c> if the user passes in their own connection - 
            indicating they will be responsible for managing connections.
            </p>
            <p>
            This can also be set to <c>false</c> when NHibernate has opened the connection
            on its own and the Session has had the methods <c>Close()</c> or 
            <c>Disconnect()</c> invoked.
            </p>
            <p>
            This can also be set to <c>true</c> when the Session has had the method 
            <c>Reconnect()</c> invoked.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to recreate the Session during the deserialization.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
            <remarks>
            This is needed because we have to do some checking before the serialization process
            begins.  I don't know how to add logic in ISerializable.GetObjectData and have .net
            write all of the serializable fields out.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Verify the ISession can be serialized and write the fields to the Serializer.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
            <remarks>
            The fields are marked with [NonSerializable] as just a point of reference.  This method
            has complete control and what is serialized and those attributes are ignored.  However, 
            this method should be in synch with the attributes for easy readability.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)">
            <summary>
            Once the entire object graph has been deserialized then we can hook the
            collections, proxies, and entities back up to the ISession.
            </summary>
            <param name="sender"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.#ctor(System.Data.IDbConnection,NHibernate.Impl.SessionFactoryImpl,System.Boolean,System.Int64,NHibernate.IInterceptor)">
            <summary>
            
            </summary>
            <param name="connection"></param>
            <param name="factory"></param>
            <param name="autoClose"></param>
            <param name="timestamp"></param>
            <param name="interceptor"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Close">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AfterTransactionCompletion(System.Boolean)">
            <summary>
            Ensure that the locks are downgraded to <see cref="F:NHibernate.LockMode.None"/>
            and that all of the softlocks in the <see cref="N:NHibernate.Cache"/> have
            been released.
            </summary>
            <param name="success"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Cleanup">
            <summary>
            Mark the Session as being closed and Clear out the HashTables of
            entities and proxies along with the Identity Maps for entries, array
            holders, collections, and nullifiables.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetCurrentLockMode(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetLockMode(System.Object)">
            <summary>
            
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetEntity(NHibernate.Engine.Key)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.SetLockMode(System.Object,NHibernate.LockMode)">
            <summary>
            
            </summary>
            <param name="entity"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Save(System.Object)">
            <summary>
            Save a transient object. An id is generated, assigned to the object and returned
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Save(System.Object,System.Object)">
            <summary>
            Save a transient object with a manually assigned ID
            </summary>
            <param name="obj"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ReassociateIfUninitializedProxy(System.Object)">
            <summary>
            If the parameter <c>value</c> is an unitialized proxy then it will be reassociated
            with the session. 
            </summary>
            <param name="value">A persistable object, proxy, persistent collection or null</param>
            <returns>
            <c>true</c> when an uninitialized proxy was passed into this method, <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ReassociateProxy(NHibernate.Proxy.LazyInitializer,NHibernate.Proxy.INHibernateProxy)">
            <summary>
            associate a proxy that was instantiated by another session with this session
            </summary>
            <param name="li"></param>
            <param name="proxy"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.NullifyTransientReferences(System.Object,NHibernate.Type.IType,System.Boolean,System.Object)">
            <summary>
            Return null if the argument is an "unsaved" entity (ie. one with no existing database row), 
            or the input argument otherwise. This is how Hibernate avoids foreign key constraint violations.
            </summary>
            <param name="value"></param>
            <param name="type"></param>
            <param name="earlyInsert"></param>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.IsUnsaved(System.Object,System.Boolean,System.Object)">
            <summary>
            determine if the object already exists in the database, using a "best guess"
            </summary>
            <param name="obj"></param>
            <param name="earlyInsert"></param>
            <param name="self"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Delete(System.Object)">
            <summary>
            Delete a persistent object
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CheckNullability(System.Object[],NHibernate.Persister.IClassPersister,System.Boolean)">
            <summary>
            Checks to see if there are any Properties that should not be null 
            are references to null or to a transient object.
            </summary>
            <param name="values">An object array of values that should be validated.</param>
            <param name="persister">The <see cref="T:NHibernate.Persister.IClassPersister"/> that describes which values can be null.</param>
            <param name="isUpdate">A <see cref="T:System.Boolean"/> indicating if this is an Update operation.</param>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when a non-nullable property contains a value that would
            persist the value of null to the database.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ReattachCollection(NHibernate.Collection.PersistentCollection,NHibernate.Engine.ICollectionSnapshot)">
            <summary>
            Reattach a detached (disassociated) initialized or uninitialized collection wrapper
            </summary>
            <param name="collection"></param>
            <param name="snapshot"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Update(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoReplicate(System.Object,System.Object,System.Object,NHibernate.ReplicationMode,NHibernate.Persister.IClassPersister)">
            <summary>
            Used only by Replicate
            </summary>
            <param name="obj"></param>
            <param name="id"></param>
            <param name="version"></param>
            <param name="replicationMode"></param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Find(System.String)">
            <summary>
            Retrieve a list of persistent objects using a Hibernate query
            </summary>
            <param name="query"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateFilter(System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <param name="queryString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateQuery(System.String)">
            <summary>
            
            </summary>
            <param name="queryString"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetNamedQuery(System.String)">
            <summary>
            Obtain an instance of <see cref="T:NHibernate.IQuery"/> for a named query string defined in the
            mapping file.
            </summary>
            <param name="queryName">The name of a query defined externally.</param>
            <returns>An <see cref="T:NHibernate.IQuery"/> fro a named query string.</returns>
            <remarks>
            The query can be either in <c>hql</c> or <c>sql</c> format.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Instantiate(NHibernate.Persister.IClassPersister,System.Object)">
            <summary>
            Give the interceptor an opportunity to override the default instantiation
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AutoFlushIfRequired(Iesi.Collections.ISet)">
            <summary>
            detect in-memory changes, determine if the changes are to tables
            named in the query and, if so, complete execution the flush
            </summary>
            <param name="querySpaces"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.NarrowProxy(System.Object,NHibernate.Persister.IClassPersister,NHibernate.Engine.Key,System.Object)">
            <summary>
            If the existing proxy is insufficiently "narrow" (derived), instantiate a 
            new proxy and overwrite the registration of the old one. This breaks == and 
            occurs only for "class" proxies rather than "interface" proxies.
            </summary>
            <param name="proxy"></param>
            <param name="persister"></param>
            <param name="key"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ProxyFor(NHibernate.Persister.IClassPersister,NHibernate.Engine.Key,System.Object)">
            <summary>
            Grab the existing proxy for an instance, if one exists.
            (otherwise return the instance)
            </summary>
            <param name="persister"></param>
            <param name="key"></param>
            <param name="impl"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddUninitializedEntity(NHibernate.Engine.Key,System.Object,NHibernate.LockMode)">
            <summary>
            Create a "temporary" entry for a newly instantiated entity. The entity is 
            uninitialized, but we need the mapping from id to instance in order to guarantee 
            uniqueness.
            </summary>
            <param name="key"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PostHydrate(NHibernate.Persister.IClassPersister,System.Object,System.Object[],System.Object,NHibernate.LockMode)">
            <summary>
            Add the "hydrated state" (an array) of an uninitialized entity to the session. 
            We don't try to resolve any associations yet, because there might be other entities 
            waiting to be read from the ADO datareader we are currently processing
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
            <param name="values"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ImmediateLoad(System.Type,System.Object)">
            <summary> 
             Load the data for the object with the specified id into a newly created object.
             Do NOT return a proxy.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InternalLoadOneToOne(System.Type,System.Object)">
            <summary>
             Return the object with the specified id or null if no row with that id exists. Do not defer the load
             or return a new proxy (but do return an existing proxy). Do not check if the object was deleted.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InternalLoad(System.Type,System.Object)">
            <summary>
            Return the object with the specified id or throw exception if no row with that id exists. Defer the load,
            return a new proxy or return an existing proxy if possible. Do not check if the object was deleted.
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoLoadByObject(System.Object,System.Object,NHibernate.LockMode)">
            <summary>
            Load the data for the object with the specified id into the supplied
            instance. A new key will be assigned to the object. If there is an
            existing uninitialized proxy, this will break identity equals as far
            as the application is concerned.
            </summary>
            <param name="obj"></param>
            <param name="id"></param>
            <param name="lockMode"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoLoadByClass(System.Type,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Load the data for the object with the specified id into a newly created
            object. A new key will be assigned to the object. If the class supports
            lazy initialization, return a proxy instead, leaving the real work for
            later. This should return an existing proxy where appropriate.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> of the object to load.</param>
            <param name="id">The identifier of the object in the database.</param>
            <param name="checkDeleted">
            A boolean indicating if NHiberate should check if the object has or has not been deleted.
            </param>
            <param name="allowProxyCreation">A boolean indicating if it is allowed to return a Proxy instead of an instance of the <see cref="T:System.Type"/>.</param>
            <returns>
            An loaded instance of the object or a proxy of the object is proxies are allowed.
            </returns>
            <remarks>
            If the parameter <c>checkDeleted</c> is <c>false</c> it is possible to return an object that has 
            been deleted by the user in this <see cref="T:NHibernate.ISession"/>.  If the parameter <c>checkDeleted</c> is
            <c>true</c> and the object has been deleted then an <see cref="T:NHibernate.ObjectDeletedException"/> will be
            thrown.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoLoad(System.Type,System.Object,NHibernate.LockMode,System.Boolean)">
            <summary>
            Load the data for the object with the specified id into a newly created object
            using "for update", if supported. A new key will be assigned to the object.
            This method always hits the db, and does not create proxies. It should return
            an existing proxy where appropriate.
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <param name="lockMode"></param>
            <param name="allowNull"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Load(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Load the data for the object with the specified id into a newly created object
            using "for update", if supported. A new key will be assigned to the object.
            This should return an existing proxy where appropriate.
            
            If the object does not exist in the database, an exception is thrown.
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <param name="lockMode"></param>
            <returns></returns>
            <exception cref="T:NHibernate.ObjectNotFoundException">
            Thrown when the object with the specified id does not exist in the database.
            </exception>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Get(System.Type,System.Object,NHibernate.LockMode)">
            <summary>
            Load the data for the object with the specified id into a newly created object
            using "for update", if supported. A new key will be assigned to the object.
            This should return an existing proxy where appropriate.
            
            If the object does not exist in the database, null is returned.
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <param name="lockMode"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.DoLoad(System.Type,System.Object,System.Object,NHibernate.LockMode,System.Boolean)">
            <summary>
            Actually do all the hard work of loading up an object
            </summary>
            <param name="theClass"></param>
            <param name="id"></param>
            <param name="optionalObject"></param>
            <param name="lockMode"></param>
            <param name="checkDeleted"></param>
            <returns></returns>
            <remarks>
            1. see if it is already loaded
            2. see if it is cached
            3. actually go to the database
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InitializeEntity(System.Object)">
            <summary>
            After processing a JDBC result set, we "resolve" all the associations
            between the entities which were instantiated and had their state
            "hydrated" into an array
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Flush">
            <summary>
            
            </summary>
            <remarks>
            This can be called from commit() or at the start of a Find() method.
            <para>
            Perform all the necessary SQL statements in a sensible order, to allow
            users to repect foreign key constraints:
            <list type="">
            	<item>Inserts, in the order they were performed</item>
            	<item>Updates</item>
            	<item>Deletion of collection elements</item>
            	<item>Insertion of collection elements</item>
            	<item>Deletes, in the order they were performed</item>
            </list>
            </para>
            <para>
            Go through all the persistent objects and look for collections they might be
            holding. If they had a nonpersistable collection, substitute a persistable one
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Execute">
            Execute all SQL and second-level cache updates, in a
            special order so that foreign-key constraints cannot
            be violated:
            <ol>
            <li> Inserts, in the order they were performed </li>
            <li> Updates</li>
            <li> Deletion of collection elements</li>
            <li> Insertion of collection elements</li>
            <li> Deletes, in the order they were performed</li>
            </ol>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.FlushEntities">
            <summary>
            1. detect any dirty entities
            2. schedule any entity updates
            3. search out any reachable collections
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PreFlushEntities">
            <summary>
            Process cascade save/update at the start of a flush to discover
            any newly referenced entity that must be passed to
            <see cref="M:NHibernate.Impl.SessionImpl.SaveOrUpdate(System.Object)"/> and also apply orphan delete
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetIdentifier(System.Object)">
            <summary>
            Not for internal use
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetEntityIdentifier(System.Object)">
            <summary>
            Get the id value for an object that is actually associated with the session.
            This is a bit stricter than GetEntityIdentifierIfNotUnsaved().
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.IsSaved(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetEntityIdentifierIfNotUnsaved(System.Object)">
            <summary>
            Used by OneToOneType and ManyToOneType to determine what id value
            should be used for an object that may or may not be associated with
            the session. This does a "best guess" using any/all info available
            to use (not just the EntityEntry).
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.FlushCollections">
            <summary>
            process any unreferenced collections and then inspect all known collections,
            scheduling creates/removes/updates
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PostFlush">
            <summary>
            1. Recreate the collection key -> collection map
            2. rebuild the collection entries
            3. call Interceptor.postFlush()
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PreFlushCollections">
            <summary>
            Initialize the flags of the CollectionEntry, including the
            dirty check.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.UpdateReachableCollection(NHibernate.Collection.PersistentCollection,NHibernate.Type.IType,System.Object)">
            <summary>
            Initialize the role of the collection.
            The CollectionEntry.reached stuff is just to detect any silly users who set up
            circular or shared references between/to collections.
            </summary>
            <param name="coll"></param>
            <param name="type"></param>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.UpdateUnreachableCollection(NHibernate.Collection.PersistentCollection)">
            <summary>
            record the fact that this collection was dereferenced
            </summary>
            <param name="coll"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.PrepareCollectionForUpdate(NHibernate.Collection.PersistentCollection,NHibernate.Impl.CollectionEntry)">
            <summary>
            1. record the collection role that this collection is referenced by
            2. decide if the collection needs deleting/creating/updating (but
               don't actually schedule the action yet)
            </summary>
            <param name="coll"></param>
            <param name="entry"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CollectionIsDirty(NHibernate.Collection.PersistentCollection)">
            <summary>
            ONLY near the end of the flush process, determine if the collection is dirty
            by checking its entry
            </summary>
            <param name="coll"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetLoadingCollection(System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddUninitializedCollection(NHibernate.Collection.PersistentCollection,NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            add a collection we just loaded up (still needs initializing)
            </summary>
            <param name="collection"></param>
            <param name="persister"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddInitializedCollection(NHibernate.Collection.PersistentCollection,NHibernate.Collection.ICollectionPersister,System.Object)">
            <summary>
            add a collection we just pulled out of the cache (does not need initializing)
            </summary>
            <param name="collection"></param>
            <param name="persister"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddNewCollection(NHibernate.Collection.PersistentCollection,NHibernate.Collection.ICollectionPersister)">
            <summary>
            Add a new collection (i.e. a newly created one, just instantiated by
            the application, with no database state or snapshot)
            </summary>
            <param name="collection"></param>
            <param name="persister"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddInitializedDetachedCollection(NHibernate.Collection.PersistentCollection,NHibernate.Engine.ICollectionSnapshot)">
            <summary>
            Add an (initialized) collection that was created by another session and passed
            into update() (i.e. one with a snapshot and existing state on the database)
            </summary>
            <param name="collection"></param>
            <param name="cs"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetArrayHolder(System.Object)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.AddArrayHolder(NHibernate.Collection.ArrayHolder)">
            <summary>
            associate a holder with an array - called after loading an array
            </summary>
            <param name="holder"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InitializeCollection(NHibernate.Collection.PersistentCollection,System.Boolean)">
            <summary>
            called by a collection that wants to initialize itself
            </summary>
            <param name="collection"></param>
            <param name="writing"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Disconnect">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Impl.SessionImpl._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Dispose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Dispose">
            <summary>
            Just in case the user forgot to Commit() or Close()
            </summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this Session is being Disposed of or Finalized.</param>
            <remarks>
            If this Session is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this Session back to life.
            </remarks>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Filter(System.Object,System.String,System.Object[],NHibernate.Type.IType[])">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <param name="filter"></param>
            <param name="values"></param>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetFilterTranslator(System.Object,System.String,NHibernate.Engine.QueryParameters,System.Boolean)">
            <summary>
            1. determine the collection role of the given collection (this may require a flush, if the collection is recorded as unreferenced)
            2. obtain a compiled filter query
            3. autoflush if necessary
            </summary>
            <param name="collection"></param>
            <param name="filter"></param>
            <param name="parameters"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetCollectionEntryOrNull(System.Object)">
            <summary>
            Get the collection entry for a collection passed to filter,
            which might be a collection wrapper, an array, or an unwrapped
            collection. Return <c>null</c> if there is no entry.
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Filter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <param name="filter"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.EnumerableFilter(System.Object,System.String,NHibernate.Engine.QueryParameters)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <param name="filter"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateCriteria(System.Type)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Find(NHibernate.Impl.CriteriaImpl)">
            <summary>
            
            </summary>
            <param name="criteria"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Evict(System.Object)">
            <summary>
            remove any hard references to the entity that are held by the infrastructure
            (references held by application or other persistant instances are okay)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.EvictCachedCollections(NHibernate.Persister.IClassPersister,System.Object)">
            <summary>
            Evict collections from the factory-level cache
            </summary>
            <param name="persister"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetCollectionBatch(NHibernate.Collection.ICollectionPersister,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="collectionPersister"></param>
            <param name="id"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetClassBatch(System.Type,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.ScheduleBatchLoad(System.Type,System.Object)">
            <summary>
            
            </summary>
            <param name="clazz"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateSQLQuery(System.String,System.String,System.Type)">
            <summary>
            
            </summary>
            <param name="sql"></param>
            <param name="returnAlias"></param>
            <param name="returnClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateSQLQuery(System.String,System.String[],System.Type[])">
            <summary>
            
            </summary>
            <param name="sql"></param>
            <param name="returnAliases"></param>
            <param name="returnClasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.CreateSQLQuery(System.String,System.String[],System.Type[],System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="sql"></param>
            <param name="returnAliases"></param>
            <param name="returnClasses"></param>
            <param name="querySpaces"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.FindBySQL(System.String,System.String[],System.Type[],NHibernate.Engine.QueryParameters,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="sqlQuery"></param>
            <param name="aliases"></param>
            <param name="classes"></param>
            <param name="queryParameters"></param>
            <param name="querySpaces"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.LoadByUniqueKey(System.Type,System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="clazz"></param>
            <param name="uniqueKeyPropertyName"></param>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.GetCollection(System.String,System.Object,System.Object)">
            <summary>
            Instantiate a collection wrapper (called when loading an object)
            </summary>
            <param name="role"></param>
            <param name="id"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.InitializeCollectionFromCache(System.Object,System.Object,NHibernate.Collection.ICollectionPersister,NHibernate.Collection.PersistentCollection)">
            <summary>
            Try to initialize a Collection from the cache.
            </summary>
            <param name="id"></param>
            <param name="owner"></param>
            <param name="persister"></param>
            <param name="collection"></param>
            <returns><c>true</c> if the collection was initialized from the cache, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.SaveOrUpdateCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SessionImpl.Copy(System.Object,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="copiedAlready"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Batcher">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Factory">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.Timestamp">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.IsOpen">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.FlushMode">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SessionImpl.IsConnected">
            <summary>
            Gets if the ISession is connected.
            </summary>
            <value>
            <c>true</c> if the ISession is connected.
            </value>
            <remarks>
            An ISession is considered connected if there is an <see cref="T:System.Data.IDbConnection"/> (regardless
            of its state) or if it the field <c>connect</c> is true.  Meaning that it will connect
            at the next operation that requires a connection.
            </remarks>
        </member>
        <member name="T:NHibernate.Impl.SqlQueryImpl">
            <summary>
            Implements SQL query passthrough
            </summary>
            <example>
            An example mapping is:
            <code>
            &lt;sql-query-name name="mySqlQuery"&gt;
            &lt;return alias="person" class="eg.Person" /&gt;
            	SELECT {person}.NAME AS {person.name}, {person}.AGE AS {person.age}, {person}.SEX AS {person.sex}
            	FROM PERSON {person} WHERE {person}.NAME LIKE 'Hiber%'
            &lt;/sql-query-name&gt;
            </code>
            </example>
        </member>
        <member name="M:NHibernate.Impl.SqlQueryImpl.#ctor(System.String,System.String[],System.Type[],NHibernate.Engine.ISessionImplementor,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="sql"></param>
            <param name="returnAliases"></param>
            <param name="returnClasses"></param>
            <param name="session"></param>
            <param name="querySpaces"></param>
        </member>
        <member name="M:NHibernate.Impl.SqlQueryImpl.List">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Impl.SqlQueryImpl.Enumerable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Impl.SqlQueryImpl.ReturnAliases">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Impl.SqlQueryImpl.ReturnClasses">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Impl.SqlQueryImpl.ReturnTypes">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Impl.Status">
            <summary>
            Represents the status of an entity with respect to 
            this session. These statuses are for internal 
            book-keeping only and are not intended to represent 
            any notion that is visible to the <b>application</b>. 
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Loaded">
            <summary>
            The Entity is snapshotted in the Session with the same state as the database.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Deleted">
            <summary>
            The Entity is in the Session and has been marked for deletion but not
            deleted from the database yet.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Gone">
            <summary>
            The Entity has been deleted from database.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Loading">
            <summary>
            The Entity is in the process of being loaded.
            </summary>
        </member>
        <member name="F:NHibernate.Impl.Status.Saving">
            <summary>
            The Entity is in the process of being saved.
            </summary>
        </member>
        <member name="T:NHibernate.Impl.WrapVisitor">
            <summary>
            Wrap collections in a NHibernate collection wrapper.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.AbstractEntityLoader">
            <summary>
            Abstract superclass for entity loaders that use outer joins
            </summary>
        </member>
        <member name="T:NHibernate.Loader.OuterJoinLoader">
            <summary>
            Implements logic for walking a tree of associated classes.
            </summary>
            <remarks>
            Generates an SQL select string containing all properties of those classes.
            Tablse are joined using an ANSI-style left outer join.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.IsJoinedFetchEnabled(NHibernate.Type.IType,System.Boolean,System.String,System.String,System.String[])">
            <summary>
            Override on subclasses to enable or suppress joining of some associations
            </summary>
            <param name="type"></param>
            <param name="mappingDefault"></param>
            <param name="path"></param>
            <param name="table"></param>
            <param name="foreignKeyColumns"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.WalkTree(NHibernate.Persister.IOuterJoinLoadable,System.String,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            For an entity class, return a list of associations to be fetched by outerjion
            </summary>
            <param name="persister"></param>
            <param name="alias"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.WalkCollectionTree(NHibernate.Collection.IQueryableCollection,System.String,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            For a collection role, return a list of associations to be fetched by outerjoin
            </summary>
            <param name="persister"></param>
            <param name="alias"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.WalkCollectionTree(NHibernate.Collection.IQueryableCollection,System.String,System.Collections.IList,Iesi.Collections.ISet,System.String,System.Int32,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            For a collection role, return a list of associations to be fetched by outerjoin
            </summary>
            <param name="persister"></param>
            <param name="alias"></param>
            <param name="associations"></param>
            <param name="visitedPersisters"></param>
            <param name="path"></param>
            <param name="currentDepth"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.IsJoinedFetchAlwaysDisabled(NHibernate.Persister.IOuterJoinLoadable,NHibernate.Type.IAssociationType,System.Int32)">
            <summary>
            Is this an association that we cannot possibly load by outer
            join, no matter what the mapping or subclass specifies?
            </summary>
            <param name="persister"></param>
            <param name="type"></param>
            <param name="propertyNumber"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.WalkClassTree(NHibernate.Persister.IOuterJoinLoadable,System.String,System.Collections.IList,Iesi.Collections.ISet,System.String,System.Int32,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            For an entity class, add to a list of associations to be fetched by outerjoin
            </summary>
            <param name="persister"></param>
            <param name="alias"></param>
            <param name="associations"></param>
            <param name="visitedPersisters"></param>
            <param name="path"></param>
            <param name="currentDepth"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.WalkComponentTree(NHibernate.Type.IAbstractComponentType,System.Int32,System.String[],System.String[],NHibernate.Persister.IOuterJoinLoadable,System.String,System.Collections.IList,Iesi.Collections.ISet,System.String,System.Int32,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            For a component, add to a list of associations to be fetched by outerjoin
            </summary>
            <param name="componentType"></param>
            <param name="propertyNumber"></param>
            <param name="cols"></param>
            <param name="persister"></param>
            <param name="alias"></param>
            <param name="associations"></param>
            <param name="visitedPersisters"></param>
            <param name="aliasedCols"></param>
            <param name="path"></param>
            <param name="currentDepth"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.WalkCompositeElementTree(NHibernate.Type.IAbstractComponentType,System.String[],NHibernate.Collection.IQueryableCollection,System.String,System.Collections.IList,Iesi.Collections.ISet,System.String,System.Int32,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            For a composite element, add to a list of associations to be fetched by outerjoin
            </summary>
            <param name="compositeType"></param>
            <param name="cols"></param>
            <param name="persister"></param>
            <param name="alias"></param>
            <param name="associations"></param>
            <param name="visitedPersisters"></param>
            <param name="path"></param>
            <param name="currentDepth"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.IsJoinedFetchEnabledByDefault(NHibernate.Loader.OuterJoinFetchStrategy,NHibernate.Type.IAssociationType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Does the mapping, and Hibernate default semantics, specify that
            this association should be fetched by outer joining
            </summary>
            <param name="config"></param>
            <param name="type"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.WalkAssociationTree(NHibernate.Type.IAssociationType,System.String[],NHibernate.Persister.IJoinable,System.String,System.Collections.IList,Iesi.Collections.ISet,System.String,System.Int32,NHibernate.SqlCommand.JoinType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
             Add on association (one-to-one or many-to-one) to a list of associations be fetched by outerjoin (if necessary)
            </summary>
            <param name="type"></param>
            <param name="aliasedForeignKeyColumns"></param>
            <param name="persister"></param>
            <param name="alias"></param>
            <param name="associations"></param>
            <param name="visitedPersisters"></param>
            <param name="path"></param>
            <param name="currentDepth"></param>
            <param name="joinType"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.SelectString(System.Collections.IList,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Generate a select list of columns containing all properties of the entity classes
            </summary>
            <param name="associations"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.GenerateTableAlias(System.String,System.Int32,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="className"></param>
            <param name="n"></param>
            <param name="path"></param>
            <param name="isLinkTable"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.GenerateRootAlias(System.String)">
            <summary>
            
            </summary>
            <param name="className"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.MergeOuterJoins(System.Collections.IList)">
            <summary>
            Generate a sequence of <c>LEFT OUTER JOIN</c> clauses for the given associations.
            </summary>
            <param name="associations"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.CountClassPersisters(System.Collections.IList)">
            <summary>
            Count the number of instances of IJoinable which are actually
            also instances of ILoadable, or are one-to-many associations
            </summary>
            <param name="associations"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.WhereString(NHibernate.Engine.ISessionFactoryImplementor,System.String,System.String[],NHibernate.Type.IType,System.Int32)">
            <summary>
            Render the where condition for a (batch) load by identifier / collection key
            </summary>
            <param name="factory"></param>
            <param name="alias"></param>
            <param name="columnNames"></param>
            <param name="type"></param>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.OuterJoinLoader.GetPosition(System.String,System.Collections.IList)">
            <summary>
            Get the position of the join with the given alias in the list of joins, or -1 if not found
            </summary>
            <param name="alias"></param>
            <param name="associations"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Loader.OuterJoinLoader.Suffixes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Loader.OuterJoinLoader.CollectionPersister">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Loader.OuterJoinLoader.OuterJoinableAssociation">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Loader.AbstractEntityLoader.GetWhereFragment">
            <summary>
            Include discriminator, don't include the class where string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.AbstractEntityLoader.IsJoinedFetchEnabled(NHibernate.Type.IType,System.Boolean,System.String,System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="mappingDefault"></param>
            <param name="path"></param>
            <param name="table"></param>
            <param name="foreignKeyColumns"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.AbstractEntityLoader.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Loader.AbstractEntityLoader.Persister">
            <summary>
            Gets the <see cref="T:NHibernate.Persister.ILoadable"/> Persister.
            </summary>
        </member>
        <member name="P:NHibernate.Loader.AbstractEntityLoader.Alias">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Loader.AbstractEntityLoader.CollectionPersister">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Loader.AbstractEntityLoader.CollectionOwner">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Loader.AbstractEntityLoader.EntityAliases">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Loader.BatchingCollectionInitializer">
            <summary>
            "Batch" loads collections, using multiple foreign key values in the SQL Where clause
            </summary>
        </member>
        <member name="T:NHibernate.Loader.ICollectionInitializer">
            <summary>
            An interface for collection loaders
            </summary>
        </member>
        <member name="M:NHibernate.Loader.ICollectionInitializer.Initialize(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initialize the given collection
            </summary>
            <param name="id"></param>
            <param name="session"></param>
        </member>
        <member name="T:NHibernate.Loader.BatchingEntityLoader">
            <summary>
            "Batch" loads entities, using multiple primary key values in the
            SQL <c>where</c> clause.
            </summary>
        </member>
        <member name="T:NHibernate.Loader.IUniqueEntityLoader">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Loader.IUniqueEntityLoader.Load(NHibernate.Engine.ISessionImplementor,System.Object,System.Object)">
            <summary>
            Load an entity instance. If <c>OptionalObject</c> is supplied, load the entity
            state into the given (uninitialized) object
            </summary>
            <param name="session"></param>
            <param name="id"></param>
            <param name="optionalObject"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Loader.CollectionLoader">
            <summary>
            Loads a collection of values or a many-to-many association
            </summary>
            <remarks>
            The collection persister must implement <see cref="T:NHibernate.Collection.IQueryableCollection"/>. For
            other collections, create a customized subclass of <see cref="T:NHibernate.Loader.Loader"/>.
            <seealso cref="T:NHibernate.Loader.OneToManyLoader"/>
            </remarks>
        </member>
        <member name="T:NHibernate.Loader.CriteriaLoader">
            <summary>
            A <c>Loader</c> for <see cref="T:NHibernate.ICriteria"/> queries. 
            </summary>
            <remarks>
            Note that criteria
            queries are more like multi-object <c>Load()</c>s than like HQL queries.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.CriteriaLoader.GetWhereFragment">
            <remarks>Uses the discriminator, to narrow the select to instances of the queried subclass.</remarks>
        </member>
        <member name="T:NHibernate.Loader.EntityLoader">
            <summary>
            Load an entity using outerjoin fetching to fetch associated entities.
            </summary>
            <remarks>
            The <see cref="T:NHibernate.Persister.IClassPersister"/> must implement <see cref="T:NHibernate.Persister.ILoadable"/>. For other entities,
            create a customized subclass of <see cref="T:NHibernate.Loader.Loader"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Loader.EntityLoader.IsSingleRowLoader">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Loader.OneToManyLoader">
            <summary>
            Loads one-to-many associations
            </summary>
            <remarks>
            The collection persister must implement IQueryableCollection. For
            other collections, create a customized subclass of Loader.
            </remarks>
        </member>
        <member name="M:NHibernate.Loader.OneToManyLoader.IsJoinedFetchEnabled(NHibernate.Type.IType,System.Boolean,System.String,System.String,System.String[])">
            <summary>
            Disable a join back to this same association
            </summary>
            <param name="type"></param>
            <param name="mappingDefault"></param>
            <param name="path"></param>
            <param name="table"></param>
            <param name="foreignKeyColumns"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Loader.SimpleEntityLoader">
            <summary>
            Loads entity instances one instance per select (ie without outerjoin fetching)
            </summary>
        </member>
        <member name="P:NHibernate.Loader.SimpleEntityLoader.Persisters">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Loader.SimpleEntityLoader.CollectionPersister">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Loader.SimpleEntityLoader.Suffixes">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Loader.SqlLoader">
            <summary>
            Summary description for SqlLoader.
            </summary>
        </member>
        <member name="M:NHibernate.Loader.SqlLoader.SubstituteBrackets">
            <summary>
            Inspired by the parsing done in TJDO
            TODO: Should record how many properties we have referred to - and throw exception if we don't get them all aka AbstractQueryImpl
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Loader.SqlLoader.BindNamedParameters(System.Data.IDbCommand,System.Collections.IDictionary,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Bind named parameters to the <c>IDbCommand</c>
            </summary>
            <param name="st">The <see cref="T:System.Data.IDbCommand"/> that contains the parameters.</param>
            <param name="namedParams">The named parameters (key) and the values to set.</param>
            <param name="session">The <see cref="T:NHibernate.ISession"/> this Loader is using.</param>
            <param name="start"></param>
            <remarks>
            Assumes that all types are of span 1
            </remarks>
        </member>
        <member name="F:NHibernate.Loader.SqlLoader.isSqlStringPopulated">
            <summary>
            Indicates if the SqlString has been fully populated - it goes
            through a 2 phase process.  The first part is the parsing of the
            hql and it puts in placeholders for the parameters, the second phase 
            puts in the actual types for the parameters using QueryParameters
            passed to query methods.  The completion of the second phase is
            when <c>isSqlStringPopulated==true</c>.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Any">
            <summary>
            A NHibernate <c>any</c> type.
            </summary>
            <remarks>
            Polymorphic association to one of several tables.
            </remarks>
        </member>
        <member name="T:NHibernate.Mapping.SimpleValue">
            <summary>
            Any value that maps to columns.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IValue">
            <summary>
            A value is anything that is persisted by value, instead of
            by reference. It is essentially a Hibernate IType, together
            with zero or more columns. Values are wrapped by things with 
            higher level semantics, for example properties, collections, 
            classes.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IValue.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IValue.IsValid(NHibernate.Engine.IMapping)">
            <summary>
            Determines if the Value is part of a valid mapping.
            </summary>
            <param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> to validate.</param>
            <returns>
            <c>true</c> if the Value is part of a valid mapping, <c>false</c>
            otherwise.
            </returns>
            <exception cref="T:NHibernate.MappingException"></exception>
            <remarks>
            Mainly used to make sure that Value maps to the correct number
            of columns.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.IValue.ColumnSpan">
            <summary>
            Gets the number of columns that this value spans in the table.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects
            that this value is stored in.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.Type">
            <summary>
            Gets the <see cref="T:NHibernate.Type.IType"/> to read/write the Values.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.Table">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.IValue.Table"/> this Value is stored in.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.Formula">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.IValue.Formula"/> used to populate the Value.
            </summary>
            <remarks>
            If a <see cref="P:NHibernate.Mapping.IValue.Formula"/> is not used then this will be 
            <c>null</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsUnique">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this Value is unique.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsNullable">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this Value can have
            null values.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.IsSimpleValue">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if this is a SimpleValue
            that does not involve foreign keys.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IValue.OuterJoinFetchSetting">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.CreateForeignKey">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.CreateForeignKeyOfClass(System.Type)">
            <summary>
            
            </summary>
            <param name="persistentClass"></param>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.CreateIdentifierGenerator(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.SetTypeByReflection(System.Type,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="M:NHibernate.Mapping.SimpleValue.IsValid(NHibernate.Engine.IMapping)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.ColumnSpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.ColumnCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.ConstraintColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.ForeignKeyName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.Table">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.OuterJoinFetchSetting">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.IdentifierGeneratorProperties">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.IdentifierGeneratorStrategy">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.IsComposite">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.IsSimpleValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.IsUnique">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.IsNullable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.NullValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.SimpleValue.Formula">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.Any.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.Any.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="P:NHibernate.Mapping.Any.IdentifierType">
            <summary>
            Get or set the identifier type 
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Any.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Any.MetaType">
            <summary>
            Get or set the metatype 
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Array">
            <summary>
            An array has a primary key consisting of the key columns + index column
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.List">
            <summary>
            A list has a primary key consisting of the key columns + index column
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IndexedCollection">
            <summary>
            Indexed collections include IList, IDictionary, Arrays
            and primitive Arrays.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Collection">
            <summary>
            Mapping for a collection.  Subclasses specialize to particular
            collection styles.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IFetchable">
            <summary>
            Any mapping with an outer-join attribute
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.IFetchable.OuterJoinFetchSetting">
            <summary>
            
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.Collection.DefaultElementColumnName">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Mapping.Collection.DefaultKeyColumnName">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.Collection.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.Collection.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Collection.CreatePrimaryKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Collection.CreateAllKeys">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Collection.IsValid(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Mapping.Collection.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.Collection.ColumnSpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsSet">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Key">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Element">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsIndexed">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.CollectionTable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Table">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsSorted">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Owner">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.CollectionPersisterClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Comparer">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsLazy">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Role">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.ColumnCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Formula">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsNullable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsUnique">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.CollectionType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsPrimitiveArray">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsArray">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsIdentified">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsOneToMany">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Cache">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsInverse">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.OwnerClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.OrderBy">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.Where">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.OrphanDelete">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.BatchSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.OuterJoinFetchSetting">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Collection.IsSimpleValue">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Mapping.IndexedCollection.DefaultIndexColumnName">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.IndexedCollection.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.IndexedCollection.CreatePrimaryKey">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.IndexedCollection.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.IndexedCollection.Index">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.IndexedCollection.IsIndexed">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.List.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:NHibernate.Mapping.List.CollectionType">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.Array.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:NHibernate.Mapping.Array.ElementClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Array.CollectionType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Array.IsArray">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Bag">
            <summary>
            A bag permits duplicates, so it has no primary key
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Bag.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.Bag.CreatePrimaryKey">
            <summary>
            
            </summary>
            <remarks>Should we create an index on the key columns?</remarks>
        </member>
        <member name="P:NHibernate.Mapping.Bag.CollectionType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Column">
            <summary>
            Represents the mapping to a column in a database.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.Column.uniqueInteger">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetQuotedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the name of this Column in quoted form if it is necessary.
            </summary>
            <param name="d">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote
            the column name.
            </param>
            <returns>
            The column name in a form that is safe to use inside of a SQL statement.
            Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.Alias(NHibernate.Dialect.Dialect)">
            <summary>
            Gets an Alias for the column name.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> that contains the rules for Aliasing.</param>
            <returns>
            A string that can be used as the alias for this Column.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.Alias(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Gets an Alias for the column name.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> that contains the rules for Aliasing.</param>
            <param name="suffix">A string to use as the suffix for the Alias.</param>
            <returns>
            A string that can be used as the alias for this Column.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.#ctor(NHibernate.Type.IType,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Column"/>.
            </summary>
            <param name="type">The NHibernate <see cref="T:NHibernate.Type.IType"/> that reads from and writes to the column.</param>
            <param name="typeIndex">The index of the column in the <see cref="T:NHibernate.Type.IType"/>.</param>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetAutoSqlType(NHibernate.Engine.IMapping)">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.Column.SqlType"/> of the column based on the <see cref="T:NHibernate.Type.IType"/>.
            </summary>
            <param name="mapping"></param>
            <returns>
            The <see cref="P:NHibernate.Mapping.Column.SqlType"/> of the column based on the <see cref="T:NHibernate.Type.IType"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetSqlType(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping)">
            <summary>
            Gets the name of the data type for the column.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use to get the valid data types.</param>
            <param name="mapping"></param>
            <returns>
            The name of the data type for the column. 
            </returns>
            <remarks>
            If the mapping file contains a value of the attribute <c>sql-type</c> this will
            return the string contained in that attribute.  Otherwise it will use the 
            typename from the <see cref="T:NHibernate.Dialect.Dialect"/> of the <see cref="P:NHibernate.Mapping.Column.SqlType"/> object. 
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Column.Equals(System.Object)">
            <summary>
            Determines if this instance of <see cref="T:NHibernate.Mapping.Column"/> and a specified object, 
            which must be a <b>Column</b> can be considered the same.
            </summary>
            <param name="obj">An <see cref="T:System.Object"/> that should be a <see cref="T:NHibernate.Mapping.Column"/>.</param>
            <returns>
            <c>true</c> if the name of this Column and the other Column are the same, 
            otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.Equals(NHibernate.Mapping.Column)">
            <summary>
            Determines if this instance of <see cref="T:NHibernate.Mapping.Column"/> and the specified Column 
            can be considered the same.
            </summary>
            <param name="column">A <see cref="T:NHibernate.Mapping.Column"/> to compare to this Column.</param>
            <returns>
            <c>true</c> if the name of this Column and the other Column are the same, 
            otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Column.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <value>The value of Name.GetHashCode().</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Length">
            <summary>
            Gets or sets the length of the datatype in the database.
            </summary>
            <value>The length of the datatype in the database.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Type">
            <summary>
            Gets or sets the NHibernate <see cref="T:NHibernate.Type.IType"/> of the column.
            </summary>
            <value>
            The NHibernate <see cref="T:NHibernate.Type.IType"/> of the column.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Name">
            <summary>
            Gets or sets the name of the column in the database.
            </summary>
            <value>
            The name of the column in the database.  The get does 
            not return a Quoted column name.
            </value>
            <remarks>
            <p>
            If a value is passed in that is wrapped by <c>`</c> then 
            NHibernate will Quote the column whenever SQL is generated
            for it.  How the column is quoted depends on the Dialect.
            </p>
            <p>
            The value returned by the getter is not Quoted.  To get the
            column name in quoted form use <see cref="M:NHibernate.Mapping.Column.GetQuotedName(NHibernate.Dialect.Dialect)"/>.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsNullable">
            <summary>
            Gets or sets if the column can have null values in it.
            </summary>
            <value><c>true</c> if the column can have a null value in it.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.TypeIndex">
            <summary>
            Gets or sets the index of the column in the <see cref="T:NHibernate.Type.IType"/>.
            </summary>
            <value>
            The index of the column in the <see cref="T:NHibernate.Type.IType"/>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsUnique">
            <summary>
            Gets or sets if the column contains unique values.
            </summary>
            <value><c>true</c> if the column contains unique values.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.SqlType">
            <summary>
            Gets or sets the sql data type name of the column.
            </summary>
            <value>
            The sql data type name of the column. 
            </value>
            <remarks>
            This is usually read from the <c>sql-type</c> attribute.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Column.IsQuoted">
            <summary>
            Gets or sets if the column needs to be quoted in SQL statements.
            </summary>
            <value><c>true</c> if the column is quoted.</value>
        </member>
        <member name="P:NHibernate.Mapping.Column.Unique">
            <summary>
            Gets or sets whether the column is unique.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Column.CheckConstraint">
            <summary>
            Gets or sets a check constraint on the column
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Column.HasCheckConstraint">
            <summary>
            Do we have a check constraint?
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Component">
            <summary>
            The mapping for a component, composite element, composite identifier,
            etc.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Component.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.Component.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="P:NHibernate.Mapping.Component.PropertySpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.PropertyCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ColumnSpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ColumnCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.IsEmbedded">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.IsDynamic">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ComponentClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.Owner">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.ParentProperty">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Component.Properties">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Constraint">
            <summary>
            Base class for relational constraints in the database.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IRelationalModel">
            <summary>
            Operations to create/drop the mapping element in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IRelationalModel.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to create 
            the mapping element in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create an object.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.IRelationalModel.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to drop 
            the mapping element from the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop an object.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the constraint.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Constraint.</param>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String)">
            <summary>
            Generates the SQL string to create this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create this Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Constraint.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            When implemented by a class, generates the SQL string to create the named
            Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the named Constraint.
            </returns>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.Name">
            <summary>
            Gets or sets the Name used to identify the constraint in the database.
            </summary>
            <value>The Name used to identify the constraint in the database.</value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are part of the constraint.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are part of the constraint.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.ColumnSpan">
            <summary>
            Gets the number of columns that this Constraint contains.
            </summary>
            <value>
            The number of columns that this Constraint contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Constraint.Table">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Constraint.Table"/> this Constraint is in.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Constraint.Table"/> this Constraint is in.
            </value>
        </member>
        <member name="T:NHibernate.Mapping.ForeignKey">
            <summary>
            A Foreign Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.ForeignKey"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to create the named Foreign Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the named Foreign Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.ForeignKey.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="P:NHibernate.Mapping.ForeignKey.ReferencedTable">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Table"/> that the Foreign Key is referencing.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Table"/> the Foreign Key is referencing.</value>
            <exception cref="T:NHibernate.MappingException">
            Thrown when the number of columns in this Foreign Key is not the same
            amount of columns as the Primary Key in the ReferencedTable.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.ForeignKey.ReferencedClass">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> that this Foreign Key is referencing.
            </summary>
            <value>
            The <see cref="T:System.Type"/> that this Foreign Key is referencing.
            </value>
        </member>
        <member name="T:NHibernate.Mapping.Formula">
            <summary>
            A formula is a derived column value.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Formula.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.Formula.GetTemplate(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Mapping.Formula.Alias">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Formula.FormulaString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.IdentifierBag">
            <summary>
            An <c>IdentifierBag</c> has a primary key consistenting of just
            the identifier column.
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.IdentifierCollection">
            <summary>
            A collection with a synthetic "identifier" column.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.CreatePrimaryKey">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierCollection.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.IdentifierCollection.Identifier">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.IdentifierCollection.IsIdentified">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.IdentifierBag.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:NHibernate.Mapping.IdentifierBag.CollectionType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Index">
            <summary>
            An Index in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Index.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String)">
            <summary>
            Generates the SQL string to create this Index in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create this Index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Index.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to drop this Index in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Index.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the Index.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Index.</param>
        </member>
        <member name="P:NHibernate.Mapping.Index.Table">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Index.Table"/> this Index is in.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Index.Table"/> this Index is in.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Index.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Index.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Index.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Index.Name">
            <summary>
            Gets or sets the Name used to identify the Index in the database.
            </summary>
            <value>The Name used to identify the Index in the database.</value>
        </member>
        <member name="T:NHibernate.Mapping.IntegerValue">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.IntegerValue.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="P:NHibernate.Mapping.IntegerValue.Type">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.ManyToOne">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.ToOne">
            <summary>
            A simple-point association (ie. a reference to another entity).
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ToOne.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ToOne.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.ToOne.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="P:NHibernate.Mapping.ToOne.OuterJoinFetchSetting">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.ToOne.ReferencedPropertyName">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.ManyToOne.#ctor(NHibernate.Mapping.Table)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.ManyToOne.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="M:NHibernate.Mapping.ManyToOne.CreateForeignKey">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Map">
            <summary>
            A map has a primary key consisting of the key columns 
            + index columns.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Map.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.Map.CreateAllKeys">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Map.CollectionType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.MetaAttribute">
            <summary>
            A meta attribute is a named value or values.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.MetaAttribute.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.MetaAttribute.AddValue(System.String)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:NHibernate.Mapping.MetaAttribute.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.MetaAttribute.Values">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.MetaAttribute.Value">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.MetaAttribute.IsMultiValued">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.NamedSQLQuery">
            <summary>
            Simple holder for named sql queries
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.NamedSQLQuery.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="query"></param>
        </member>
        <member name="M:NHibernate.Mapping.NamedSQLQuery.AddSynchronizedTable(System.String)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="M:NHibernate.Mapping.NamedSQLQuery.AddAliasedClass(System.String,System.Type)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="clazz"></param>
        </member>
        <member name="P:NHibernate.Mapping.NamedSQLQuery.ReturnAliases">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.NamedSQLQuery.ReturnClasses">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.NamedSQLQuery.SynchronizedTables">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.NamedSQLQuery.QueryString">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.OneToMany">
            <summary>
            A mapping for a <c>one-to-many</c> association.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToMany.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.OneToMany.IsValid(NHibernate.Engine.IMapping)">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToMany.CreateForeignKey">
            <summary>
            
            </summary>
            <remarks>No foreign key element for a one-to-many</remarks>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.EntityType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.ColumnCollection">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.ColumnSpan">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.ReferencingTable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.AssociatedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.Formula">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.Table">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsNullable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsSimpleValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.IsUnique">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToMany.OuterJoinFetchSetting">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.OneToOne">
            <summary>
            A mapping for a <c>one-to-one</c> association.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.OneToOne.#ctor(NHibernate.Mapping.Table,NHibernate.Mapping.SimpleValue)">
            <summary>
            
            </summary>
            <param name="table"></param>
            <param name="identifier"></param>
        </member>
        <member name="M:NHibernate.Mapping.OneToOne.SetTypeByReflection(System.Type,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propertyClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccess"></param>
        </member>
        <member name="M:NHibernate.Mapping.OneToOne.CreateForeignKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.ConstraintColumns">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.IsConstrained">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.ForeignKeyType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.Identifier">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.OneToOne.IsNullable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.PersistentClass">
            <summary>
            Base class for the <see cref="T:NHibernate.Mapping.RootClass"/> mapped by <c>&lt;class&gt;</c> and a 
            <see cref="T:NHibernate.Mapping.Subclass"/> that is mapped by <c>&lt;subclass&gt;</c> or 
            <c>&lt;joined-subclass&gt;</c>.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.PersistentClass.NullDiscriminatorMapping">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Mapping.PersistentClass.NotNullDiscriminatorMapping">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclass(NHibernate.Mapping.Subclass)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Subclass"/> to the class hierarchy.
            </summary>
            <param name="subclass">The <see cref="T:NHibernate.Mapping.Subclass"/> to add to the hierarchy.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddNewProperty(NHibernate.Mapping.Property)">
            <summary>
            Add a new property definition
            </summary>
            <param name="p"></param>
            <exception cref="T:NHibernate.MappingException">if the property was already defined</exception>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            Change the property definition or add a new property definition
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> to add.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclassProperty(NHibernate.Mapping.Property)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Property"/> that is implemented by a subclass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> implemented by a subclass.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.AddSubclassTable(NHibernate.Mapping.Table)">
            <summary>
            Adds a <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> that a subclass is stored in.
            </summary>
            <param name="table">The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> the subclass is stored in.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.CreatePrimaryKey(NHibernate.Dialect.Dialect)">
            <summary>
            Creates the <see cref="T:NHibernate.Mapping.PrimaryKey"/> for the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/>
            this type is persisted in.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> that is used to Alias columns.</param>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.GetProperty(System.String)">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Mapping.PersistentClass.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DynamicInsert">
            <summary>
            Gets or Sets if the Insert Sql is built dynamically.
            </summary>
            <value><c>true</c> if the Sql is built at runtime.</value>
            <remarks>
            The value of this is set by the <c>dynamic-insert</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DynamicUpdate">
            <summary>
            Gets or Sets if the Update Sql is built dynamically.
            </summary>
            <value><c>true</c> if the Sql is built at runtime.</value>
            <remarks>
            The value of this is set by the <c>dynamic-update</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DiscriminatorValue">
            <summary>
            Gets or Sets the value to use as the discriminator for the Class.
            </summary>
            <value>
            A value that distinguishes this subclass in the database.
            </value>
            <remarks>
            The value of this is set by the <c>discriminator-value</c> attribute.  Each <c>&lt;subclass&gt;</c>
            in a heirarchy must define a unique <c>discriminator-value</c>.  The default value 
            is the class name if no value is supplied.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasSubclasses">
            <summary>
            Gets a boolean indicating if this PersistentClass has any subclasses.
            </summary>
            <value><c>true</c> if this PeristentClass has any subclasses.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassSpan">
            <summary>
            Gets the number of subclasses that inherit either directly or indirectly.
            </summary>
            <value>The number of subclasses that inherit from this PersistentClass.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassCollection">
            <summary>
            Gets the Collection of Subclasses for this PersistentClass.  
            </summary>
            <value>
            It will recursively go through Subclasses so that if a Subclass has Subclasses
            it will pick those up also.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.DirectSubclasses">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Subclass"/> objects
            that directly inherit from this PersistentClass.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Subclass"/> objects
            that directly inherit from this PersistentClass.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Table">
            <summary>
            Gets or Sets the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> that this class is stored in.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> this class is stored in.</value>
            <remarks>
            The value of this is set by the <c>table</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.PropertyCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.MappedClass">
            <summary>
            Gets the <see cref="T:System.Type"/> that is being mapped.
            </summary>
            <value>The <see cref="T:System.Type"/> that is being mapped.</value>
            <remarks>
            The value of this is set by the <c>name</c> attribute on the <c>&lt;class&gt;</c> 
            element.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Name">
            <summary>
            Gets the fully qualified name of the type being persisted.
            </summary>
            <value>The fully qualified name of the type being persisted.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsMutable">
            <summary>
            When implemented by a class, gets or set a boolean indicating 
            if the mapped class has properties that can be changed.
            </summary>
            <value><c>true</c> if the object is mutable.</value>
            <remarks>
            The value of this is set by the <c>mutable</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasIdentifierProperty">
            <summary>
            When implemented by a class, gets a boolean indicating
            if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><c>true</c> if there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IdentifierProperty">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.Property"/>
            that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Identifier">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Version">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.Property"/>
            that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Discriminator">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsInherited">
            <summary>
            When implemented by a class, gets a boolean indicating if this
            mapped class is inherited from another. 
            </summary>
            <value>
            <c>true</c> if this class is a <c>subclass</c> or <c>joined-subclass</c>
            that inherited from another <c>class</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsPolymorphic">
            <summary>
            When implemented by a class, gets or sets if the mapped class has subclasses or is
            a subclass.
            </summary>
            <value>
            <c>true</c> if the mapped class has subclasses or is a subclass.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsVersioned">
            <summary>
            When implemented by a class, gets a boolean indicating if the mapped class
            has a version property.
            </summary>
            <value><c>true</c> if there is a <c>&lt;version&gt;</c> property.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Cache">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> 
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Superclass">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/>
            that this mapped class is extending.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsExplicitPolymorphism">
            <summary>
            When implemented by a class, gets or sets a boolean indicating if 
            explicit polymorphism should be used in Queries.
            </summary>
            <value>
            <c>true</c> if only classes queried on should be returned, <c>false</c>
            if any class in the heirarchy should implicitly be returned.</value>
            <remarks>
            The value of this is set by the <c>polymorphism</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.PropertyClosureCollection">
            <summary>
            When implemented by a class, gets an <see cref="T:System.Collections.ICollection"/> 
            of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
            <remarks>
            This is all of the properties of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.TableClosureCollection">
            <summary>
            When implemented by a class, gets an <see cref="T:System.Collections.ICollection"/> 
            of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that this mapped class reads from
            and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            This is all of the tables of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassPropertyClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that
            this mapped class contains and that all of its subclasses contain.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that
            this mapped class contains and that all of its subclasses contain.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SubclassTableClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of all of the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects that the 
            subclass finds its information in.  
            </summary>
            <value>An <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> objects.</value>
            <remarks>It adds the TableClosureCollection and the subclassTables into the ICollection.</remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.ProxyInterface">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> to use as a Proxy.
            </summary>
            <value>The <see cref="T:System.Type"/> to use as a Proxy.</value>
            <remarks>
            The value of this is set by the <c>proxy</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsForceDiscriminator">
            <summary>
            Gets or sets a boolean indicating if only values in the discriminator column that
            are mapped will be included in the sql.
            </summary>
            <value><c>true</c> if the mapped discriminator values should be forced.</value>
            <remarks>
            The value of this is set by the <c>force</c> attribute on the <c>discriminator</c> element. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorValueNotNull">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorValueNull">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.HasEmbeddedIdentifier">
            <summary>
            When implemented by a class, gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><c>true</c> if the class identifies itself.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.ClassPersisterClass">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:System.Type"/> of the Persister.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.RootTable">
            <summary>
            When implemented by a class, gets the <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.PersistentClass.Table"/> of the class that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.RootClazz">
            <summary>
            When implemented by a class, gets the <see cref="T:NHibernate.Mapping.RootClass"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.RootClass"/> of the class that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Key">
            <summary>
            When implemented by a class, gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/>
            that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.BatchSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.SelectBeforeUpdate">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.Where">
            <summary>
            When implemented by a class, gets or sets the sql string that should 
            be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
            <remarks>
            The value of this is set by the <c>where</c> attribute. 
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.PersistentClass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.PrimaryKey">
            <summary>
            A Primary Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to create the Primary Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the Primary Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to create the named Primary Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName">The name to use as the identifier of the constraint in the database.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the named Primary Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.PrimaryKey.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="T:NHibernate.Mapping.PrimitiveArray">
            <summary>
            A primitive array has a primary key consisting 
            of the key columns + index column.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.PrimitiveArray.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="P:NHibernate.Mapping.PrimitiveArray.IsPrimitiveArray">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Mapping.Property">
            <summary>
            Mapping for a property of a .NET class (entity
            or component).
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Property.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Property.#ctor(NHibernate.Mapping.IValue)">
            <summary>
            
            </summary>
            <param name="propertyValue"></param>
        </member>
        <member name="M:NHibernate.Mapping.Property.GetGetter(System.Type)">
            <summary>
            
            </summary>
            <param name="clazz"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Mapping.Property.GetSetter(System.Type)">
            <summary>
            
            </summary>
            <param name="clazz"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Mapping.Property.IsValid(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Mapping.Property.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.ColumnSpan">
            <summary>
            Gets the number of columns this property uses in the db.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/>s.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.Name">
            <summary>
            Gets or Sets the name of the Property in the class.
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.IsUpdateable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.IsComposite">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.Value">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.CascadeStyle">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.Cascade">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.IsInsertable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.Formula">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.IsFormula">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.IsNullable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.PropertyAccessorName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.PropertyAccessor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.IsBasicPropertyAccessor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Property.NullValue">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.RootClass">
            <summary>
            Declaration of a System.Type mapped with the <c>&lt;class&gt;</c> element that
            is the root class of a table-per-sublcass, or table-per-concrete-class 
            inheritance heirarchy.
            </summary>
        </member>
        <member name="F:NHibernate.Mapping.RootClass.DefaultIdentifierColumnName">
            <summary>
            The default name of the column for the Identifier
            </summary>
            <value><c>id</c> is the default column name for the Identifier.</value>
        </member>
        <member name="F:NHibernate.Mapping.RootClass.DefaultDiscriminatorColumnName">
            <summary>
            The default name of the column for the Discriminator
            </summary>
            <value><c>class</c> is the default column name for the Discriminator.</value>
        </member>
        <member name="M:NHibernate.Mapping.RootClass.AddSubclass(NHibernate.Mapping.Subclass)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Subclass"/> to the class hierarchy.
            </summary>
            <param name="subclass">The <see cref="T:NHibernate.Mapping.Subclass"/> to add to the hierarchy.</param>
            <remarks>
            When a <see cref="T:NHibernate.Mapping.Subclass"/> is added this mapped class has the property <see cref="P:NHibernate.Mapping.RootClass.IsPolymorphic"/>
            set to <c>true</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.RootClass.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IdentifierProperty">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Identifier">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.HasIdentifierProperty">
            <summary>
            Gets a boolean indicating if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><c>true</c> if there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Discriminator">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsInherited">
            <summary>
            Gets a boolean indicating if this mapped class is inherited from another. 
            </summary>
            <value>
            <c>false</c> because this is the root mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsPolymorphic">
            <summary>
            Gets or sets if the mapped class has subclasses.
            </summary>
            <value>
            <c>true</c> if the mapped class has subclasses.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.RootClazz">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.RootClass"/> of the class that is mapped in the <c>class</c> element.
            </summary>
            <value>
            <c>this</c> since this is the root mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.PropertyClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.TableClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Table"/> objects that this 
            mapped class reads from and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            There is only one <see cref="T:NHibernate.Mapping.Table"/> in the <see cref="T:System.Collections.ICollection"/> since
            this is the root class.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsExplicitPolymorphism">
            <summary>
            Gets or sets a boolean indicating if explicit polymorphism should be used in Queries.
            </summary>
            <value>
            <c>true</c> if only classes queried on should be returned, <c>false</c>
            if any class in the heirarchy should implicitly be returned.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Version">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsVersioned">
            <summary>
            Gets a boolean indicating if the mapped class has a version property.
            </summary>
            <value><c>true</c> if there is a Property for a <c>version</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Cache">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> 
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> used with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsMutable">
            <summary>
            Gets or set a boolean indicating if the mapped class has properties that can be changed.
            </summary>
            <value><c>true</c> if the object is mutable.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.HasEmbeddedIdentifier">
            <summary>
            Gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><c>true</c> if the class identifies itself.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.ClassPersisterClass">
            <summary>
            Gets or sets the <see cref="T:System.Type"/> of the Persister.
            </summary>
            <value>The <see cref="T:System.Type"/> of the Persister.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.RootTable">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Table"/> of the class this mapped class.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Superclass">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </summary>
            <value>
            <c>null</c> since this is the root class.
            </value>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the setter is called.  The Superclass can not be set on the 
            RootClass, only the Subclass can have a Superclass set.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Key">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsForceDiscriminator">
            <summary>
            Gets or sets a boolean indicating if only values in the discriminator column that
            are mapped will be included in the sql.
            </summary>
            <value><c>true</c> if the mapped discriminator values should be forced.</value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.Where">
            <summary>
            Gets or sets the sql string that should be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.RootClass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Set">
            <summary>
            A Set with no nullable element columns will have a primary
            key consisting of all table columns (ie - key columns + 
            element columns).
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Set.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:NHibernate.Mapping.Set.CreatePrimaryKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Mapping.Set.IsSet">
            <summary>
            <see cref="P:NHibernate.Mapping.Collection.IsSet"/>
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Set.CollectionType">
            <summary>
            <see cref="P:NHibernate.Mapping.Collection.Type"/>
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Subclass">
            <summary>
            Declaration of a System.Type mapped with the <c>&lt;subclass&gt;</c> or 
            <c>&lt;joined-subclass&gt;</c> element.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.#ctor(NHibernate.Mapping.PersistentClass)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Mapping.Subclass"/> class.
            </summary>
            <param name="superclass">The <see cref="T:NHibernate.Mapping.PersistentClass"/> that is the superclass.</param>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddProperty(NHibernate.Mapping.Property)">
            <summary>
            Add the <see cref="T:NHibernate.Mapping.Property"/> to this PersistentClass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> to add.</param>
            <remarks>
            This also adds the <see cref="T:NHibernate.Mapping.Property"/> to the Superclass' collection
            of Subclass Properties.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddSubclassProperty(NHibernate.Mapping.Property)">
            <summary>
            Adds a <see cref="T:NHibernate.Mapping.Property"/> that is implemented by a subclass.
            </summary>
            <param name="p">The <see cref="T:NHibernate.Mapping.Property"/> implemented by a subclass.</param>
            <remarks>
            This also adds the <see cref="T:NHibernate.Mapping.Property"/> to the Superclass' collection
            of Subclass Properties.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.AddSubclassTable(NHibernate.Mapping.Table)">
            <summary>
            Adds a <see cref="P:NHibernate.Mapping.Subclass.Table"/> that a subclass is stored in.
            </summary>
            <param name="table">The <see cref="P:NHibernate.Mapping.Subclass.Table"/> the subclass is stored in.</param>
            <remarks>
            This also adds the <see cref="P:NHibernate.Mapping.Subclass.Table"/> to the Superclass' collection
            of Subclass Tables.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.Validate(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="M:NHibernate.Mapping.Subclass.CreateForeignKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Cache">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> 
            to use to read/write instances of the persistent class to the Cache.
            </summary>
            <value>The <see cref="T:NHibernate.Cache.ICacheConcurrencyStrategy"/> that the Superclass uses with the Cache.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.RootClazz">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.RootClass"/> of the class that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.RootClass"/> of the Superclass that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Superclass">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.PersistentClass"/> that this mapped class is extending.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.ClassPersisterClass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IdentifierProperty">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the <c>id</c>.
            </summary>
            <value>
            The <see cref="T:NHibernate.Mapping.Property"/> from the Superclass that is used as the <c>id</c>.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Identifier">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the identifier.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> from the Superclass that contains information about the identifier.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.HasIdentifierProperty">
            <summary>
            Gets a boolean indicating if the mapped class has a Property for the <c>id</c>.
            </summary>
            <value><c>true</c> if in the Superclass there is a Property for the <c>id</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Discriminator">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the discriminator.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> from the Superclass that contains information about the discriminator.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsMutable">
            <summary>
            Gets or set a boolean indicating if the mapped class has properties that can be changed.
            </summary>
            <value><c>true</c> if the Superclass is mutable.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsInherited">
            <summary>
            Gets a boolean indicating if this mapped class is inherited from another. 
            </summary>
            <value>
            <c>true</c> because this is a Subclass.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsPolymorphic">
            <summary>
            Gets or sets if the mapped class is a subclass.
            </summary>
            <value>
            <c>true</c> since this mapped class is a subclass.
            </value>
            <remarks>
            The setter should not be used to set the value to anything but <c>true</c>.  
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Table">
            <summary>
            Gets or Sets the <see cref="P:NHibernate.Mapping.Subclass.Table"/> that this class is stored in.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.Subclass.Table"/> this class is stored in.</value>
            <remarks>
            This also adds the <see cref="P:NHibernate.Mapping.Subclass.Table"/> to the Superclass' collection
            of Subclass Tables.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.PropertyClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that this mapped class contains.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Property"/> objects that 
            this mapped class contains.
            </value>
            <remarks>
            This is all of the properties of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.TableClosureCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.Subclass.Table"/> objects that this 
            mapped class reads from and writes to.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="P:NHibernate.Mapping.Subclass.Table"/> objects that 
            this mapped class reads from and writes to.
            </value>
            <remarks>
            This is all of the tables of this mapped class and each mapped class that
            it is inheriting from.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsVersioned">
            <summary>
            Gets a boolean indicating if the mapped class has a version property.
            </summary>
            <value><c>true</c> if for the Superclass there is a Property for a <c>version</c>.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Version">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.Property"/> that is used as the version.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.Property"/> from the Superclass that is used as the version.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.HasEmbeddedIdentifier">
            <summary>
            Gets or sets a boolean indicating if the identifier is 
            embedded in the class.
            </summary>
            <value><c>true</c> if the Superclass has an embedded identifier.</value>
            <remarks>
            An embedded identifier is true when using a <c>composite-id</c> specifying
            properties of the class as the <c>key-property</c> instead of using a class
            as the <c>composite-id</c>.
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.RootTable">
            <summary>
            Gets the <see cref="P:NHibernate.Mapping.Subclass.Table"/> of the class
            that is mapped in the <c>class</c> element.
            </summary>
            <value>
            The <see cref="P:NHibernate.Mapping.Subclass.Table"/> of the Superclass that is mapped in the <c>class</c> element.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Key">
            <summary>
            Gets or sets the <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.
            </summary>
            <value>The <see cref="T:NHibernate.Mapping.SimpleValue"/> that contains information about the Key.</value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsExplicitPolymorphism">
            <summary>
            Gets or sets a boolean indicating if explicit polymorphism should be used in Queries.
            </summary>
            <value>
            The value of the Superclasses <c>IsExplicitPolymorphism</c> property.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.Where">
            <summary>
            Gets the sql string that should be a part of the where clause.
            </summary>
            <value>
            The sql string that should be a part of the where clause.
            </value>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the setter is called.  The where clause can not be set on the 
            Subclass, only the RootClass.
            </exception>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsJoinedSubclass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Mapping.Subclass.IsDiscriminatorInsertable">
            <summary>
            
            </summary>
        </member>
        <member name="T:NHibernate.Mapping.Table">
            <summary>
            Represents a Table in a database that an object gets mapped against.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Table.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Mapping.Table"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQualifiedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the schema qualified name of the Table.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to Quote the Table name.</param>
            <returns>The name of the table qualified with the schema if one is specified.</returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQualifiedName(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Gets the schema qualified name of the Table using the specified qualifier
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to Quote the Table name.</param>
            <param name="defaultQualifier">The Qualifier to use when accessing the table.</param>
            <returns>A String representing the Qualified name.</returns>
            <remarks>If this were used with MSSQL it would return a dbo.table_name.</remarks>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQuotedName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the name of this Table in quoted form if it is necessary.
            </summary>
            <param name="dialect">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote the Table name.
            </param>
            <returns>
            The Table name in a form that is safe to use inside of a SQL statement.
            Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetQuotedSchemaName(NHibernate.Dialect.Dialect)">
            <summary>
            Gets the schema for this table in quoted form if it is necessary.
            </summary>
            <param name="dialect">
            The <see cref="T:NHibernate.Dialect.Dialect"/> that knows how to quote the table name.
            </param>
            <returns>
            The schema name for this table in a form that is safe to use inside
            of a SQL statement. Quoted if it needs to be, not quoted if it does not need to be.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetColumn(System.Int32)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.Column"/> at the specified index.
            </summary>
            <param name="n">The index of the Column to get.</param>
            <returns> 
            The <see cref="T:NHibernate.Mapping.Column"/> at the specified index.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.AddColumn(NHibernate.Mapping.Column)">
            <summary>
            Adds the <see cref="T:NHibernate.Mapping.Column"/> to the <see cref="T:System.Collections.ICollection"/> of 
            Columns that are part of the Table.
            </summary>
            <param name="column">The <see cref="T:NHibernate.Mapping.Column"/> to include in the Table.</param>
        </member>
        <member name="M:NHibernate.Mapping.Table.SqlAlterStrings(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.Data.DataTable)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <param name="p"></param>
            <param name="tableInfo"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.SqlCreateString(NHibernate.Dialect.Dialect,NHibernate.Engine.IMapping,System.String)">
            <summary>
            Generates the SQL string to create this Table in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="p"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create this Table, Primary Key Constraints
            , and Unique Key Constraints.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Generates the SQL string to drop this Table in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Table and to cascade the drop to 
            the constraints if the database supports it.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetIndex(System.String)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.Index"/> identified by the name.
            </summary>
            <param name="name">The name of the <see cref="T:NHibernate.Mapping.Index"/> to get.</param>
            <returns>
            The <see cref="T:NHibernate.Mapping.Index"/> identified by the name.  If the <see cref="T:NHibernate.Mapping.Index"/>
            identified by the name does not exist then it is created.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.GetUniqueKey(System.String)">
            <summary>
            Gets the <see cref="T:NHibernate.Mapping.UniqueKey"/> identified by the name.
            </summary>
            <param name="name">The name of the <see cref="T:NHibernate.Mapping.UniqueKey"/> to get.</param>
            <returns>
            The <see cref="T:NHibernate.Mapping.UniqueKey"/> identified by the name.  If the <see cref="T:NHibernate.Mapping.UniqueKey"/>
            identified by the name does not exist then it is created.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.CreateForeignKey(System.String,System.Collections.IList,System.Type)">
            <summary>
            Create a <see cref="T:NHibernate.Mapping.ForeignKey"/> for the columns in the Table.
            </summary>
            <param name="keyName"></param>
            <param name="columns">An <see cref="T:System.Collections.IList"/> of <see cref="T:NHibernate.Mapping.Column"/> objects.</param>
            <param name="referencedClass"></param>
            <returns>
            A <see cref="T:NHibernate.Mapping.ForeignKey"/> for the columns in the Table.  
            </returns>
            <remarks>
            This does not necessarily create a <see cref="T:NHibernate.Mapping.ForeignKey"/>, if
            one already exists for the columns then it will return an 
            existing <see cref="T:NHibernate.Mapping.ForeignKey"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Mapping.Table.UniqueColumnString(System.Collections.ICollection)">
            <summary>
            Generates a unique string for an <see cref="T:System.Collections.ICollection"/> of 
            <see cref="T:NHibernate.Mapping.Column"/> objects.
            </summary>
            <param name="col">An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects.</param>
            <returns>
            An unique string for the <see cref="T:NHibernate.Mapping.Column"/> objects.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.Table.SetIdentifierValue(NHibernate.Mapping.SimpleValue)">
            <summary>
            Sets the Identifier of the Table.
            </summary>
            <param name="idValue">The <see cref="T:NHibernate.Mapping.SimpleValue"/> that represents the Identifier.</param>
        </member>
        <member name="M:NHibernate.Mapping.Table.AddCheckConstraint(System.String)">
            <summary>
            
            </summary>
            <param name="constraint"></param>
        </member>
        <member name="P:NHibernate.Mapping.Table.Name">
            <summary>
            Gets or sets the name of the Table in the database.
            </summary>
            <value>
            The name of the Table in the database.  The get does 
            not return a Quoted Table name.
            </value>
            <remarks>
            <p>
            If a value is passed in that is wrapped by <c>`</c> then 
            NHibernate will Quote the Table whenever SQL is generated
            for it.  How the Table is quoted depends on the Dialect.
            </p>
            <p>
            The value returned by the getter is not Quoted.  To get the
            column name in quoted form use <see cref="M:NHibernate.Mapping.Table.GetQuotedName(NHibernate.Dialect.Dialect)"/>.
            </p>
            </remarks>
        </member>
        <member name="P:NHibernate.Mapping.Table.ColumnSpan">
            <summary>
            Gets the number of columns that this Table contains.
            </summary>
            <value>
            The number of columns that this Table contains.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.ColumnCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Column"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.IndexCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Index"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.Index"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.ForeignKeyCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.ForeignKey"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.ForeignKey"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.UniqueKeyCollection">
            <summary>
            Gets an <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.UniqueKey"/> objects that 
            are part of the Table.
            </summary>
            <value>
            An <see cref="T:System.Collections.ICollection"/> of <see cref="T:NHibernate.Mapping.UniqueKey"/> objects that are 
            part of the Table.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.PrimaryKey">
            <summary>
            Gets or sets the <see cref="P:NHibernate.Mapping.Table.PrimaryKey"/> of the Table.
            </summary>
            <value>The <see cref="P:NHibernate.Mapping.Table.PrimaryKey"/> of the Table.</value>
        </member>
        <member name="P:NHibernate.Mapping.Table.Schema">
            <summary>
            Gets or sets the schema the table is in.
            </summary>
            <value>
            The schema the table is in or <c>null</c> if no schema is specified.
            </value>
        </member>
        <member name="P:NHibernate.Mapping.Table.UniqueInteger">
            <summary>
            Gets the unique number of the Table.
            </summary>
            <value>The unique number of the Table.</value>
        </member>
        <member name="P:NHibernate.Mapping.Table.IsQuoted">
            <summary>
            Gets or sets if the column needs to be quoted in SQL statements.
            </summary>
            <value><c>true</c> if the column is quoted.</value>
        </member>
        <member name="T:NHibernate.Mapping.UniqueKey">
            <summary>
            An Unique Key constraint in the database.
            </summary>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlConstraintString(NHibernate.Dialect.Dialect)">
            <summary>
            Generates the SQL string to create the Unique Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <returns>
            A string that contains the SQL to create the Unique Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlConstraintString(NHibernate.Dialect.Dialect,System.String,System.String)">
            <summary>
            Generates the SQL string to create the Unique Key Constraint in the database.
            </summary>
            <param name="d">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="constraintName"></param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to create the Unique Key Constraint.
            </returns>
        </member>
        <member name="M:NHibernate.Mapping.UniqueKey.SqlDropString(NHibernate.Dialect.Dialect,System.String)">
            <summary>
            Get the SQL string to drop this Constraint in the database.
            </summary>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to use for SQL rules.</param>
            <param name="defaultSchema"></param>
            <returns>
            A string that contains the SQL to drop this Constraint.
            </returns>
        </member>
        <member name="T:NHibernate.Metadata.IClassMetadata">
            <summary>
            Exposes entity class metadata to the application
            </summary>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.Instantiate(System.Object)">
            <summary>
            Create a class instance initialized with the given identifier
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyType(System.String)">
            <summary>
            Get the type of a particular (named) property
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValue(System.Object,System.String)">
            <summary>
            Get the value of a particular (named) property 
            </summary>
            <param name="obj"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Set the value of a particular (named) property 
            </summary>
            <param name="obj"></param>
            <param name="propertyName"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetPropertyValues(System.Object)">
            <summary>
            Return the values of the mapped properties of the object
            </summary>
            <param name="entity"></param>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Set the given values to the mapped properties of the given object
            </summary>
            <param name="entity"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetIdentifier(System.Object)">
            <summary>
            Get the identifier of an instance (throw an exception if no identifier property)
            </summary>
            <param name="entity"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.SetIdentifier(System.Object,System.Object)">
            <summary>
            Set the identifier of an instance (or do nothing if no identifier property)
            </summary>
            <param name="entity"></param>
            <param name="id"></param>
        </member>
        <member name="M:NHibernate.Metadata.IClassMetadata.GetVersion(System.Object)">
            <summary>
            Get the version number (or timestamp) from the object's version property 
            (or return null if not versioned)
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.MappedClass">
            <summary>
            The persistent class
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IdentifierPropertyName">
            <summary>
            The name of the identifier property (or return null)
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyNames">
            <summary>
            The names of the class' persistent properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IdentifierType">
            <summary>
            The identifier Hibernate type
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyTypes">
            <summary>
            The Hibernate types of the classes properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.ImplementsLifecycle">
            <summary>
            Does the class implement the <c>ILifecycle</c> interface?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.ImplementsValidatable">
            <summary>
            Does the class implement the <c>IValidatable</c> inteface?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.HasProxy">
            <summary>
            Does the class support dynamic proxies?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IsMutable">
            <summary>
            Are instances of this class mutable?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.IsVersioned">
            <summary>
            Are instances of this class versioned by a timestamp or version number column?
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.VersionProperty">
            <summary>
            Gets the index of the version property
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.PropertyNullability">
            <summary>
            Get the nullability of the class' persistent properties
            </summary>
        </member>
        <member name="P:NHibernate.Metadata.IClassMetadata.HasIdentifierProperty">
            <summary>
            Does the class have an identifier property?
            </summary>
        </member>
        <member name="T:NHibernate.Persister.AbstractEntityPersister">
            <summary>
            Superclass for built-in mapping strategies. Implements functionalty common to both mapping
            strategies
            </summary>
            <remarks>
            May be considred an immutable view of the mapping object
            </remarks>
        </member>
        <member name="T:NHibernate.Persister.IOuterJoinLoadable">
            <summary>
            A <c>ClassPersister</c> that may be loaded by outer join using
            the <c>OuterJoinLoader</c> hierarchy and may be an element
            of a one-to-many association.
            </summary>
        </member>
        <member name="T:NHibernate.Persister.ILoadable">
            <summary>
            Implemented by <c>ClassPersister</c> that uses <c>Loader</c>. There are several optional
            operations used only by loaders that inherit <c>OuterJoinLoader</c>
            </summary>
        </member>
        <member name="T:NHibernate.Persister.IClassPersister">
            <summary>
            Concrete <c>IClassPersister</c>s implement mapping and persistence logic for a particular class.
            </summary>
            <remarks>
            Implementors must be threadsafe (preferrably immutable) and must provide a constructor of type
            (PersistentClass, SessionFactoryImplementor)
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.PostInstantiate(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Finish the initialization of this object, once all <c>ClassPersisters</c> have been
            instantiated. Called only once, before any other method.
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.CreateProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a new proxy instance
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.IsUnsaved(System.Object)">
            <summary>
            Is this a new transient instance?
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Set the given values to the mapped properties of the given object
            </summary>
            <param name="obj"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.GetPropertyValues(System.Object)">
            <summary>
            Return the values of the mapped properties of the object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary>
            Set the value of a particular property
            </summary>
            <param name="obj"></param>
            <param name="i"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            Get the value of a particular property
            </summary>
            <param name="obj"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.GetPropertyValue(System.Object,System.String)">
            <summary>
            Get the value of a particular property
            </summary>
            <param name="obj"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.GetPropertyType(System.String)">
            <summary>
            Get the type of a particular property
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.FindDirty(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Compare two snapshots of the state of an instance to determine if the persistent state
            was modified
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="owner"></param>
            <param name="session"></param>
            <returns><c>null</c> or the indices of the dirty properties</returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.FindModified(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Compare the state of an instance to the current database state
            </summary>
            <param name="old"></param>
            <param name="current"></param>
            <param name="owner"></param>
            <param name="session"></param>
            <returns>return <c>null</c> or the indicies of the modified properties</returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.GetIdentifier(System.Object)">
            <summary>
            Get the identifier of an instance ( throw an exception if no identifier property)
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.SetIdentifier(System.Object,System.Object)">
            <summary>
            Set the identifier of an instance (or do nothing if no identifier property)
            </summary>
            <param name="obj">The object to set the Id property on.</param>
            <param name="id">The value to set the Id property to.</param>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.GetVersion(System.Object)">
            <summary>
            Get the version number (or timestamp) from the object's version property (or return null if not versioned)
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.Instantiate(System.Object)">
            <summary>
            Create a class instance initialized with the given identifier
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an insatance of the persistent class.
            </summary>
            <param name="id"></param>
            <param name="optionalObject"></param>
            <param name="lockMode"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.Lock(System.Object,System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Do a version check (optional operation)
            </summary>
            <param name="id"></param>
            <param name="version"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.Insert(System.Object,System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an instance
            </summary>
            <param name="id"></param>
            <param name="fields"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.Insert(System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an instance, using a natively generated identifier (optional operation)
            </summary>
            <param name="fields"></param>
            <param name="obj"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.Delete(System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Delete a persistent instance
            </summary>
            <param name="id"></param>
            <param name="version"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.Update(System.Object,System.Object[],System.Int32[],System.Object[],System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Update a persistent instance
            </summary>
            <param name="id"></param>
            <param name="fields"></param>
            <param name="dirtyFields"></param>
            <param name="oldFields"></param>
            <param name="oldVersion"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.GetCurrentPersistentState(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the current database state of the object, in a "hydrated" form, without resolving identifiers
            </summary>
            <param name="id"></param>
            <param name="version"></param>
            <param name="session"></param>
            <returns><c>null</c> if select-before-update is not enabled or not supported</returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.GetCurrentVersion(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Get the current version of the object, or return null if there is no row for
            the given identifier. In the case of unversioned data, return any object
            if the row exists.
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IClassPersister.IsUnsavedVersion(System.Object[])">
            <summary>
            </summary>
            <param name="values"></param>
            <returns></returns>
            <remarks>NHibernate-specific feature, not present in H2.1</remarks>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IdentifierSpace">
            <summary>
            Returns an object that identifies the space in which identifiers of this class hierarchy
            are unique. eg. a table name, etc.
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.PropertySpaces">
            <summary>
            Returns an array of objects that identifies spaces in which properties of this class
            instance are persisted. eg. table names.
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.MappedClass">
            <summary>
            The persistent class
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.ClassName">
            <summary>
            The classname of the persistent class (used only for messages)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.ImplementsLifecycle">
            <summary>
            Does the class implement the <c>ILifecycle</c> inteface?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.ImplementsValidatable">
            <summary>
            Does the class implement the <c>IValidatable</c> interface?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.HasProxy">
            <summary>
            Does this class support dynamic proxies?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.ConcreteProxyClass">
            <summary>
            Get the proxy interface that instances of <c>this</c> concrete class will be cast to
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.HasCollections">
            <summary>
            Do instances of this class contain collections?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.HasCascades">
            <summary>
            Does this class declare any cascading save/update/deletes?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IsMutable">
            <summary>
            Are instances of this class mutable?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IsIdentifierAssignedByInsert">
            <summary>
            Is the identifier assigned before the insert by an <c>IDGenerator</c> or is it returned
            by the <c>Insert()</c> method?
            </summary>
            <remarks>
            This determines which form of <c>Insert()</c> will be called.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.HasIdentifierProperty">
            <summary>
            Does the class have a property holding the identifier value?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.HasIdentifierPropertyOrEmbeddedCompositeIdentifier">
            <summary>
            Gets if the Type has a Property for the &lt;id&gt; or uses a &lt;composite-id&gt;
            to store the id.
            </summary>
            <returns><c>true if there is a Identifier Property or Composite Identifier.</c></returns>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IsVersioned">
            <summary>
            Are instances of this class versioned by a timestamp or version number column?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.VersionType">
            <summary>
            Get the type of versioning (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.VersionProperty">
            <summary>
            Which property holds the version number? (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IdentifierGenerator">
            <summary>
            Return the <c>IIdentifierGenerator</c> for the class
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.PropertyTypes">
            <summary>
            Get the Hibernate types of the class properties
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.PropertyNames">
            <summary>
            Get the names of the class properties - doesn't have to be the names of the actual
            .NET properties (used for XML generation only)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.PropertyUpdateability">
            <summary>
            Gets if the Property is updatable
            </summary>
            <value><c>true</c> if the Property's value can be updated.</value>
            <remarks>
            This is for formula columns and if the user sets the update attribute on the &lt;property&gt; element.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.PropertyNullability">
            <summary>
            Get the nullability of the properties of this class
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.PropertyInsertability">
            <summary>
            Gets if the Property is insertable.
            </summary>
            <value><c>true</c> if the Property's value can be inserted.</value>
            <remarks>
            This is for formula columns and if the user sets the insert attribute on the &lt;property&gt; element.
            </remarks>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.PropertyCascadeStyles">
            <summary>
            Get the cascade styles of the properties (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IdentifierType">
            <summary>
            Get the identifier type
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IdentifierPropertyName">
            <summary>
            Get the name of the indentifier property (or return null) - need not return the
            name of an actual .NET property
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IsCacheInvalidationRequired">
            <summary>
            Should we always invalidate the cache instead of recaching updated state
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.HasCache">
            <summary>
            Does this class have a cache?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.Cache">
            <summary>
            Get the cache (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.ClassMetadata">
            <summary>
            Get the user-visible metadata for the class (optional operation)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IClassPersister.IsBatchLoadable">
            <summary>
            Is batch loading enabled?
            </summary>
        </member>
        <member name="M:NHibernate.Persister.ILoadable.GetSubclassForDiscriminatorValue(System.Object)">
            <summary>
            Get the concrete subclass corresponding to the given discriminator value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.ILoadable.GetIdentifierAliases(System.String)">
            <summary>
            Get the result set aliases used for the identifier columns, given a suffix
            </summary>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.ILoadable.GetPropertyAliases(System.String,System.Int32)">
            <summary>
            Get the result set aliases used for the property columns, given a suffix (properties of this class, only).
            </summary>
            <param name="suffix"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.ILoadable.GetDiscriminatorAlias(System.String)">
            <summary>
            Get the alias used for the discriminator column, given a suffix
            </summary>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.ILoadable.HasSubclasses">
            <summary>
            Does the persistent class have subclasses?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.ILoadable.DiscriminatorType">
            <summary>
            The discriminator type
            </summary>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.CountSubclassProperties">
            <summary>
            How many properties are there, for this class and all subclasses? (optional operation)
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.EnableJoinedFetch(System.Int32)">
            <summary>
            May this property be fetched using an SQL outerjoin?
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.IsDefinedOnSubclass(System.Int32)">
            <summary>
            Is this property defined on a subclass of the mapped class?
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.GetSubclassPropertyType(System.Int32)">
            <summary>
            Get an array of the types of all properties of all subclasses (optional operation)
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.GetSubclassPropertyName(System.Int32)">
            <summary>
            Get the name of the numbered property of the class or a subclass
            (optional operation)
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.GetSubclassPropertyColumnNames(System.Int32)">
            <summary>
            Return the column names used to persist all properties of all sublasses of the persistent class
            (optional operation)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.GetSubclassPropertyTableName(System.Int32)">
            <summary>
            Return the table name used to persist the numbered property of 
            the class or a subclass
            (optional operation)
            </summary>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.ToColumns(System.String,System.Int32)">
            <summary>
            Given the number of a property of a subclass, and a table alias, return the aliased column names
            (optional operation)
            </summary>
            <param name="name"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.FromTableFragment(System.String)">
            <summary>
            Get the main from table fragment, given a query alias (optional operation)
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IOuterJoinLoadable.SelectFragment(System.String,System.String)">
            <summary>
            Generate a list of collection index and element columns
            </summary>
            <param name="alias"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.IOuterJoinLoadable.IdentifierColumnNames">
            <summary>
            Get the names of columns used to persist the identifier
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IOuterJoinLoadable.DiscriminatorColumnName">
            <summary>
            Get the name of the column used as a discriminator
            </summary>
        </member>
        <member name="T:NHibernate.Persister.IQueryable">
            <summary>
            Extends the generic <c>ILoadable</c> contract to add operations required by HQL
            </summary>
        </member>
        <member name="M:NHibernate.Persister.IQueryable.QueryWhereFragment(System.String,System.Boolean,System.Boolean)">
            <summary>
            Get the where clause fragment, give a query alias
            </summary>
            <param name="alias">SQL alias to use for column names in the returned query</param>
            <param name="innerJoin"></param>
            <param name="includeSubclasses"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IQueryable.IdentifierSelectFragment(System.String,System.String)">
            <summary>
            Given a query alias and an identifying suffix, render the intentifier select fragment.
            </summary>
            <param name="name"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IQueryable.PropertySelectFragment(System.String,System.String)">
            <summary>
            Given a query alias and an identifying suffix, render the property select fragment.
            </summary>
            <param name="alias"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.IQueryable.IsInherited">
            <summary>
            Is this class mapped as a subclass of another class?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IQueryable.IsExplicitPolymorphism">
            <summary>
            Is this class explicit polymorphism only?
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IQueryable.MappedSuperclass">
            <summary>
            The class that this class is mapped as a subclass of - not necessarily the direct superclass
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IQueryable.DiscriminatorSQLValue">
            <summary>
            The discriminator value for this particular concrete subclass, as a string that may be
            embedded in a select statement
            </summary>
        </member>
        <member name="P:NHibernate.Persister.IQueryable.IdentifierColumnNames">
            <summary>
            Get the names of columns used to persist the identifier
            </summary>
        </member>
        <member name="T:NHibernate.Persister.IUniqueKeyLoadable">
            <summary>
            Describes a class that may be loaded via a unique key.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.IUniqueKeyLoadable.LoadByUniqueKey(System.String,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an instance of the persistent class, by a unique key other than the primary key.
            </summary>
            <param name="propertyName"></param>
            <param name="uniqueKey"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.IUniqueKeyLoadable.GetUniqueKeyColumnNames(System.String)">
            <summary>
            Get the columns of the unique key.
            </summary>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Persister.ISqlLoadable">
            <summary>
            A class persister that supports queries expressed in the platform native SQL dialect.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.ISqlLoadable.GetSubclassPropertyColumnAliases(System.String,System.String)">
            <summary>
            Returns the column alias names used to persist/query the numbered property of the class or a subclass (optional operation).
            </summary>
            <param name="propertyName"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.ISqlLoadable.SelectFragment(System.String,System.String)">
            <summary>
            All columns to select, when loading.
            </summary>
            <param name="alias"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.ISqlLoadable.Type">
            <summary>
            Get the type
            </summary>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Set the given values to the mapped properties of the given object
            </summary>
            <remarks>
            Use the IGetSetHelper if available
            </remarks>
            <param name="obj"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.GetPropertyValues(System.Object)">
            <summary>
            Return the values of the mapped properties of the object
            </summary>
            <remarks>
            Use the IGetSetHelper if available
            </remarks>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            Get the value of the numbered property
            </summary>
            <param name="obj"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary>
            Set the value of the numbered property
            </summary>
            <param name="obj"></param>
            <param name="i"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.FindDirty(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine if the given field values are dirty.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="obj"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.FindModified(System.Object[],System.Object[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine if the given field values are dirty.
            </summary>
            <param name="old"></param>
            <param name="current"></param>
            <param name="obj"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.Instantiate(System.Object)">
            <summary>
            Return a new instance initialized with the given identifier.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.Check(System.Int32,System.Object)">
            <summary>
            Checks to make sure that one and only one row was affected
            by the IDbCommand that was run.
            </summary>
            <param name="rows">The results of IDbCommand..ExecuteNonQuery()</param>
            <param name="id">The idenitifer of the Entity.  Use for logging purposes.</param>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.InitSubclassPropertyAliasesMap(NHibernate.Mapping.PersistentClass)">
            <summary>
            Must be called by subclasses, at the end of their constructors
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.InitHasCollections">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.GetCurrentVersion(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Retrieve the version number
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.Lock(System.Object,System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Do a version check
            </summary>
            <param name="id"></param>
            <param name="version"></param>
            <param name="obj"></param>
            <param name="lockMode"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.GenerateSelectVersionString(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Generate the SQL that selects the version number by id
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.GetPropertiesToUpdate(System.Int32[])">
            <summary>
            Transform the array of property indexes to an array of booleans
            </summary>
            <param name="dirtyProperties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.AbstractEntityPersister.GetPropertyColumnNames(System.Int32)">
            <summary>
            Get the column names for the numbered property of <em>this</em> class
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.PropertyNames">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.IdentifierPropertyName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.VersionColumnName">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.ImplementsLifecycle">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.ImplementsValidatable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.HasCollections">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.IsMutable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.HasCache">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.HasSubclasses">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.HasProxy">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.SqlIdentitySelect">
            <summary>
            Returns the SQL used to get the Identity value from the last insert.
            </summary>
            <remarks>This is not a NHibernate Command because there are no parameters.</remarks>
        </member>
        <member name="P:NHibernate.Persister.AbstractEntityPersister.Dialect">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Persister.EntityPersister">
            <summary>
            Default implementation of the <c>ClassPersister</c> interface. Implements the
            "table-per-class hierarchy" mapping strategy for an entity class.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.GenerateDeleteString">
            <summary>
            Generate the SQL that deletes a row by id (and version)
            </summary>
            <returns>A SqlString for a Delete</returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.GenerateInsertString(System.Boolean,System.Boolean[])">
            <summary>
            Generate the SQL that inserts a row
            </summary>
            <param name="identityInsert"></param>
            <param name="includeProperty"></param>
            <returns>A SqlString for an Insert</returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.GenerateSelectForUpdateString">
            <summary>
            Generate the SQL that selects a row by id using <c>FOR UPDATE</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.GenerateSelectForUpdateNoWaitString">
            <summary>
            Generate the SQL that selects a row by id using <c>FOR UPDATE NOWAIT</c>
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.GenerateSelectString(System.String)">
            <summary>
            Generates an SqlString that selects a row by id
            </summary>
            <param name="forUpdateFragment">SQL containing <c>FOR UPDATE</c> clauses
            to append at the end of the query (optional)</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.GenerateConcreteSelectString(System.Boolean[])">
            <summary>
            Generate the SQL that selects a row by id, excluding subclasses
            </summary>
            <param name="includeProperty"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.GenerateUpdateString(System.Boolean[])">
            <summary>
            Generate the SQL that selects a row by id, excluding subclasses
            </summary>
            <param name="includeProperty"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.GenerateLockString(NHibernate.SqlCommand.SqlString,System.String)">
            <summary>
            Generates the SQL that pessimistically locks a row by id (and version)
            </summary>
            <param name="sqlString">An existing SqlString to copy for then new SqlString.</param>
            <param name="forUpdateFragment"></param>
            <returns>A new SqlString</returns>
            <remarks>
            The parameter <c>sqlString</c> does not get modified.  It is Cloned to make a new SqlString.
            If the parameter<c>sqlString</c> is null a new one will be created.
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.Dehydrate(System.Object,System.Object[],System.Boolean[],System.Data.IDbCommand,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Marshall the fields of a persistent instance to a prepared statement
            </summary>
            <param name="id"></param>
            <param name="fields">The fields to write to the command.</param>
            <param name="includeProperty">A bool indicating if the Property should be written to the Command</param>
            <param name="st"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an instance uing either the <c>forUpdateLoader</c> or the outer joining <c>loader</c>,
            depending upon the value of the <c>lock</c> parameter
            </summary>
            <param name="id"></param>
            <param name="optionalObject"></param>
            <param name="lockMode"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.Insert(System.Object,System.Object[],System.Boolean[],NHibernate.SqlCommand.SqlString,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an object
            </summary>
            <param name="id"></param>
            <param name="fields"></param>
            <param name="notNull"></param>
            <param name="sql"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.Insert(System.Object[],System.Boolean[],NHibernate.SqlCommand.SqlString,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an object, using a natively generated identifier
            </summary>
            <param name="fields"></param>
            <param name="notNull"></param>
            <param name="sql"></param>
            <param name="obj"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.Delete(System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Delete an object
            </summary>
            <param name="id">The id of the object to delete.</param>
            <param name="version">The version of the object to delete.</param>
            <param name="obj">The object to delete.</param>
            <param name="session">The session to perform the deletion in.</param>
        </member>
        <member name="M:NHibernate.Persister.EntityPersister.Update(System.Object,System.Object[],System.Int32[],System.Object[],System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Update an object
            </summary>
            <param name="id"></param>
            <param name="fields"></param>
            <param name="dirtyFields"></param>
            <param name="oldFields"></param>
            <param name="oldVersion"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="P:NHibernate.Persister.EntityPersister.SqlDeleteString">
            <summary>
            The query that deletes a row by id (and version)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.EntityPersister.SqlInsertString">
            <summary>
            The query that inserts a row with a given id
            </summary>
        </member>
        <member name="P:NHibernate.Persister.EntityPersister.SqlIdentityInsertString">
            <summary>
            The query that inserts a row, letting the database generate an id
            </summary>
        </member>
        <member name="P:NHibernate.Persister.EntityPersister.SqlUpdateString">
            <summary>
            The query that updates a row by id (and version)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.EntityPersister.IsCacheInvalidationRequired">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.EntityPersister.VersionedTableName">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Persister.GetSetHelperFactory">
            <summary>
            Factory that generate object based on IGetSetHelper needed to replace the use
            of reflection.
            </summary>
            <remarks>
            Used in <see cref="T:NHibernate.Persister.AbstractEntityPersister"/> and
            <see cref="T:NHibernate.Type.ComponentType"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.GetSetHelperFactory.#ctor(System.Type,NHibernate.Property.ISetter[],NHibernate.Property.IGetter[])">
            <summary>
            ctor
            </summary>
            <param name="mappedClass">The target class</param>
            <param name="setters">Array of setters</param>
            <param name="getters">Array of getters</param>
        </member>
        <member name="M:NHibernate.Persister.GetSetHelperFactory.#ctor">
            <summary>
            Private ctor. Can't create an empty object
            </summary>
        </member>
        <member name="M:NHibernate.Persister.GetSetHelperFactory.Create(System.Type,NHibernate.Property.ISetter[],NHibernate.Property.IGetter[])">
            <summary>
            Generate the IGetSetHelper object
            </summary>
            <param name="mappedClass">The target class</param>
            <param name="setters">Array of setters</param>
            <param name="getters">Array of getters</param>
            <returns>null if the generation fail</returns>
        </member>
        <member name="M:NHibernate.Persister.GetSetHelperFactory.InitCompiler">
            <summary>
            Set up the compiler options
            </summary>
        </member>
        <member name="M:NHibernate.Persister.GetSetHelperFactory.AddAssembly(System.String)">
            <summary>
            Add an assembly to the list of ReferencedAssemblies
            required to build the class
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:NHibernate.Persister.GetSetHelperFactory.Build(System.String)">
            <summary>
            Build the generated code
            </summary>
            <param name="code">Generated code</param>
            <returns>An instance of the generated class</returns>
        </member>
        <member name="M:NHibernate.Persister.GetSetHelperFactory.IsPublic(System.String)">
            <summary>
            Check if the property is public
            </summary>
            <remarks>
            <para>If IsPublic==true I can directly set the property</para>
            <para>If IsPublic==false I need to use the setter/getter</para>
            </remarks>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.GetSetHelperFactory.GenerateCode">
            <summary>
            Generate the required code
            </summary>
            <returns>C# code</returns>
        </member>
        <member name="T:NHibernate.Persister.IGetSetHelper">
            <summary>
            Base interface for the object generated by <see cref="T:NHibernate.Persister.GetSetHelperFactory"/>
            </summary>
        </member>
        <member name="M:NHibernate.Persister.IGetSetHelper.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Set all the property of the object
            </summary>
            <param name="o">The object to load</param>
            <param name="values">The properties values</param>
        </member>
        <member name="M:NHibernate.Persister.IGetSetHelper.GetPropertyValues(System.Object)">
            <summary>
            Get all the property of the object
            </summary>
            <param name="o">The object to save</param>
            <returns>The properties values</returns>
        </member>
        <member name="T:NHibernate.Persister.NormalizedEntityPersister">
            <summary>
            A <c>IClassPersister</c> implementing the normalized "table-per-subclass" mapping strategy
            </summary>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.GenerateDeleteStrings">
            <summary>
            Generate the SQL that deletes rows by id (and version)
            </summary>
            <returns>An array of SqlStrings</returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.GenerateInsertStrings(System.Boolean,System.Boolean[])">
            <summary>
            Generate the SQL that inserts rows
            </summary>
            <param name="identityInsert"></param>
            <param name="includeProperty"></param>
            <returns>An array of SqlStrings</returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.GenerateUpdateStrings(System.Boolean[])">
            <summary>
            Generate the SQL that updates rows by id (and version)
            </summary>
            <param name="includeProperty"></param>
            <returns>An array of SqlStrings</returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.GenerateLockString(NHibernate.SqlCommand.SqlString,System.String)">
            <summary>
            Generate the SQL that pessimistic locks a row by id (and version)
            </summary>
            <param name="sqlString">An existing SqlString to copy for then new SqlString.</param>
            <param name="forUpdateFragment"></param>
            <returns>A new SqlString</returns>
            <remarks>
            The parameter <c>sqlString</c> does not get modified.  It is Cloned to make a new SqlString.
            If the parameter<c>sqlString</c> is null a new one will be created.
            </remarks>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.Dehydrate(System.Object,System.Object[],System.Boolean[],System.Data.IDbCommand[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Marshall the fields of a persistent instance to a properared statement
            </summary>
            <param name="id"></param>
            <param name="fields"></param>
            <param name="includeProperty"></param>
            <param name="statements"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.Load(System.Object,System.Object,NHibernate.LockMode,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Load an instance using either the <c>ForUpdateLoader</c> or the outer joining <c>loader</c>,
            depending on the value of the <c>lock</c> parameter
            </summary>
            <param name="id"></param>
            <param name="optionalObject"></param>
            <param name="lockMode"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.Insert(System.Object,System.Object[],System.Boolean[],NHibernate.SqlCommand.SqlString[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an object
            </summary>
            <param name="id">The Id to give the new object/</param>
            <param name="fields">The fields to transfer to the Command</param>
            <param name="notNull"></param>
            <param name="sql"></param>
            <param name="obj">The object to Insert into the database.  I don't see where this is used???</param>
            <param name="session">The Session to use when Inserting the object.</param>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.Insert(System.Object[],System.Boolean[],NHibernate.SqlCommand.SqlString[],System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Persist an object, using a natively generated identifier
            </summary>
            <param name="fields"></param>
            <param name="notNull"></param>
            <param name="sql"></param>
            <param name="obj"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.Delete(System.Object,System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Delete an object.
            </summary>
            <param name="id"></param>
            <param name="version"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.GetTableUpdateNeeded(System.Int32[])">
            <summary>
            Decide which tables need to be updated
            </summary>
            <param name="dirtyFields"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.Update(System.Object,System.Object[],System.Int32[],System.Object[],System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Update an object.
            </summary>
            <param name="id"></param>
            <param name="fields"></param>
            <param name="dirtyFields"></param>
            <param name="oldFields"></param>
            <param name="oldVersion"></param>
            <param name="obj"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.#ctor(NHibernate.Mapping.PersistentClass,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Constructs the NormalizedEntityPerister for the PersistentClass.
            </summary>
            <param name="model">The PeristentClass to create the EntityPersister for.</param>
            <param name="factory">The SessionFactory that this EntityPersister will be stored in.</param>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.Reverse(System.String[])">
            <summary>
            Create a new one dimensional array sorted in the Reverse order of the original array.
            </summary>
            <param name="objects">The original array.</param>
            <returns>A new array in the reverse order of the original array.</returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.Reverse(System.String[][])">
            <summary>
            Create a new two dimensional array sorted in the Reverse order of the original array. The 
            second dimension is not reversed.
            </summary>
            <param name="objects">The original array.</param>
            <returns>A new array in the reverse order of the original array.</returns>
        </member>
        <member name="M:NHibernate.Persister.NormalizedEntityPersister.GetTableId(System.String,System.String[])">
            <summary>
            Find the Index of the table name from a list of table names.
            </summary>
            <param name="tableName">The name of the table to find.</param>
            <param name="tables">The array of table names</param>
            <returns>The Index of the table in the array.</returns>
            <exception cref="T:NHibernate.AssertionFailure">Thrown when the tableName specified can't be found</exception>
        </member>
        <member name="P:NHibernate.Persister.NormalizedEntityPersister.DiscriminatorType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.NormalizedEntityPersister.DiscriminatorSQLValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Persister.NormalizedEntityPersister.SqlDeleteStrings">
            <summary>
            The queries that delete rows by id (and version)
            </summary>
        </member>
        <member name="P:NHibernate.Persister.NormalizedEntityPersister.SqlInsertStrings">
            <summary>
            The queries that insert rows with a given id
            </summary>
        </member>
        <member name="P:NHibernate.Persister.NormalizedEntityPersister.SqlIdentityInsertStrings">
            <summary>
            The queries that insert rows, letting the database generate an id
            </summary>
        </member>
        <member name="P:NHibernate.Persister.NormalizedEntityPersister.SqlUpdateStrings">
            <summary>
            The queries that update rows by id (and version)
            </summary>
        </member>
        <member name="T:NHibernate.Persister.PersisterFactory">
            <summary>
            Factory for <c>IClassPersister</c> and <c>ICollectionPersister</c> instances.
            </summary>
        </member>
        <member name="M:NHibernate.Persister.PersisterFactory.CreateClassPersister(NHibernate.Mapping.PersistentClass,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Creates a built in Entity Persister or a custom Persister.
            </summary>
            <param name="model"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.PersisterFactory.Create(System.Type,NHibernate.Mapping.PersistentClass,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Creates a specific Persister - could be a built in or custom persister.
            </summary>
            <param name="persisterClass"></param>
            <param name="model"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Persister.PersisterFactory.Create(System.Type,NHibernate.Mapping.Collection,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="persisterClass"></param>
            <param name="model"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Property.BasicGetter">
            <summary>
            An <see cref="T:NHibernate.Property.IGetter"/> for a Property <c>get</c>.
            </summary>
        </member>
        <member name="T:NHibernate.Property.IGetter">
            <summary>
            Gets values of a particular mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Property.IGetter.Get(System.Object)">
            <summary>
            When implemented by a class, gets the value of the Property/Field from the object.
            </summary>
            <param name="target">The object to get the Property/Field value from.</param>
            <returns>
            The value of the Property for the target.
            </returns>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem getting the value from the target.
            </exception>
        </member>
        <member name="P:NHibernate.Property.IGetter.ReturnType">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Type"/> that the Property/Field returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Property returns.</value>
        </member>
        <member name="P:NHibernate.Property.IGetter.PropertyName">
            <summary>
            When implemented by a class, gets the name of the Property.
            </summary>
            <value>The name of the Property or <c>null</c>.</value>
            <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Property.IGetter"/> is not 
            for a Property <c>get</c> then <c>null</c> is an acceptable value to return.
            </remarks>
        </member>
        <member name="P:NHibernate.Property.IGetter.Property">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value>
            The <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </value>
            <remarks>
            This is an optional operation - if the <see cref="T:NHibernate.Property.IGetter"/> is not 
            for a Property <c>get</c> then <c>null</c> is an acceptable value to return.
            It is used by the Proxies to determine which getter to intercept as the
            &lt;id&gt; property.
            </remarks>
        </member>
        <member name="M:NHibernate.Property.BasicGetter.#ctor(System.Type,System.Reflection.PropertyInfo,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.BasicGetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Property <c>get</c>.</param>
            <param name="property">The <see cref="T:System.Reflection.PropertyInfo"/> for reflection.</param>
            <param name="propertyName">The name of the Property.</param>
        </member>
        <member name="M:NHibernate.Property.BasicGetter.Get(System.Object)">
            <summary>
            Gets the value of the Property from the object.
            </summary>
            <param name="target">The object to get the Property value from.</param>
            <returns>
            The value of the Property for the target.
            </returns>
        </member>
        <member name="P:NHibernate.Property.BasicGetter.ReturnType">
            <summary>
            Gets the <see cref="T:System.Type"/> that the Property returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Property returns.</value>
        </member>
        <member name="P:NHibernate.Property.BasicGetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value>The name of the Property.</value>
        </member>
        <member name="P:NHibernate.Property.BasicGetter.Property">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value>
            The <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </value>
        </member>
        <member name="T:NHibernate.Property.BasicPropertyAccessor">
            <summary>
            Accesses mapped property values via a get/set pair, which may be nonpublic.
            The default (and recommended strategy).
            </summary>
        </member>
        <member name="T:NHibernate.Property.IPropertyAccessor">
            <summary>
            Abstracts the notion of a "property". Defines a strategy for accessing the
            value of a mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Property.IPropertyAccessor.GetGetter(System.Type,System.String)">
            <summary>
            When implemented by a class, create a "getter" for the mapped property.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.IGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.IPropertyAccessor.GetSetter(System.Type,System.String)">
            <summary>
            When implemented by a class, create a "setter" for the mapped property.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Property.ISetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.BasicPropertyAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.BasicGetter"/> for the mapped property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.BasicPropertyAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.BasicSetter"/> for the mapped property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.BasicPropertyAccessor.GetGetterOrNull(System.Type,System.String)">
            <summary>
            Helper method to find the Property <c>get</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicGetter"/> for the Property <c>get</c> or <c>null</c>
            if the Property could not be found.
            </returns>
        </member>
        <member name="M:NHibernate.Property.BasicPropertyAccessor.GetSetterOrNull(System.Type,System.String)">
            <summary>
            Helper method to find the Property <c>set</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicSetter"/> for the Property <c>set</c> or <c>null</c>
            if the Property could not be found.
            </returns>
        </member>
        <member name="T:NHibernate.Property.BasicSetter">
            <summary>
            An <see cref="T:NHibernate.Property.ISetter"/> for a Property <c>set</c>.
            </summary>
        </member>
        <member name="T:NHibernate.Property.ISetter">
            <summary>
            Sets values of a particular mapped property.
            </summary>
        </member>
        <member name="M:NHibernate.Property.ISetter.Set(System.Object,System.Object)">
            <summary>
            When implemented by a class, sets the value of the Property/Field on the object.
            </summary>
            <param name="target">The object to set the Property value in.</param>
            <param name="value">The value to set the Property to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Property.ISetter.PropertyName">
            <summary>
            When implemented by a class, gets the name of the Property.
            </summary>
            <value>The name of the Property or <c>null</c>.</value>
            <remarks>
            This is an optional operation - if it is not implemented then 
            <c>null</c> is an acceptable value to return.
            </remarks>
        </member>
        <member name="P:NHibernate.Property.ISetter.Property">
            <summary>
            When implemented by a class, gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value>
            The <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </value>
            <remarks>
            This is an optional operation - if it is not implemented then 
            <c>null</c> is an acceptable value to return.  It is used by
            the Proxies to determine which setter to intercept as the
            &lt;id&gt; property.
            </remarks>
        </member>
        <member name="M:NHibernate.Property.BasicSetter.#ctor(System.Type,System.Reflection.PropertyInfo,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.BasicSetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Property <c>set</c>.</param>
            <param name="property">The <see cref="T:System.Reflection.PropertyInfo"/> for reflection.</param>
            <param name="propertyName">The name of the mapped Property.</param>
        </member>
        <member name="M:NHibernate.Property.BasicSetter.Set(System.Object,System.Object)">
            <summary>
            Sets the value of the Property on the object.
            </summary>
            <param name="target">The object to set the Property value in.</param>
            <param name="value">The value to set the Property to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Property.BasicSetter.PropertyName">
            <summary>
            Gets the name of the mapped Property.
            </summary>
            <value>The name of the mapped Property or <c>null</c>.</value>
        </member>
        <member name="P:NHibernate.Property.BasicSetter.Property">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the mapped Property.
            </summary>
            <value>The <see cref="T:System.Reflection.PropertyInfo"/> for the mapped Property.</value>
        </member>
        <member name="T:NHibernate.Property.CamelCaseStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are the 
            camelCase version of the PropertyName
            </summary>
        </member>
        <member name="T:NHibernate.Property.IFieldNamingStrategy">
            <summary>
            A Strategy for converting a mapped property name to a Field name.
            </summary>
        </member>
        <member name="M:NHibernate.Property.IFieldNamingStrategy.GetFieldName(System.String)">
            <summary>
            When implemented by a class, converts the Property's name into a Field name
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field.</returns>
        </member>
        <member name="M:NHibernate.Property.CamelCaseStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character
            lower case.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in CamelCase format.</returns>
        </member>
        <member name="T:NHibernate.Property.CamelCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are prefixed with
            an underscore and the PropertyName is changed to camelCase.
            </summary>
        </member>
        <member name="M:NHibernate.Property.CamelCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> lowercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in CamelCase format prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Property.FieldAccessor">
            <summary>
            Access the mapped property by using a Field to <c>get</c> and <c>set</c> the value.
            </summary>
            <remarks>
            The <see cref="T:NHibernate.Property.FieldAccessor"/> is useful when you expose <c>getter</c> and <c>setters</c>
            for a Property, but they have extra code in them that shouldn't be executed when NHibernate
            is setting or getting the values for loads or saves.
            </remarks>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.FieldAccessor"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.#ctor(NHibernate.Property.IFieldNamingStrategy)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.FieldAccessor"/>.
            </summary>
            <param name="namingStrategy">The <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> to use.</param>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.FieldGetter"/> to <c>get</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.FieldGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.FieldSetter"/> to <c>set</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the mapped Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Property.FieldSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field for the Property specified by the <c>propertyName</c> using the
            <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> could not be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.GetField(System.Type,System.String)">
            <summary>
            Helper method to find the Field.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Field in.</param>
            <param name="fieldName">The name of the Field to find.</param>
            <returns>
            The <see cref="T:System.Reflection.FieldInfo"/> for the field.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a field could not be found.
            </exception>
        </member>
        <member name="M:NHibernate.Property.FieldAccessor.GetFieldName(System.String)">
            <summary>
            Converts the mapped property's name into a Field using 
            the <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> if one exists.
            </summary>
            <param name="propertyName">The name of the Property.</param>
            <returns>The name of the Field.</returns>
        </member>
        <member name="P:NHibernate.Property.FieldAccessor.NamingStrategy">
            <summary>
            Gets the <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> used to convert the name of the
            mapped Property in the hbm.xml file to the name of the field in the class.
            </summary>
            <value>The <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> or <c>null</c>.</value>
        </member>
        <member name="T:NHibernate.Property.FieldGetter">
            <summary>
            An <see cref="T:NHibernate.Property.IGetter"/> that uses a Field instead of the Property <c>get</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Property.FieldGetter.#ctor(System.Reflection.FieldInfo,System.Type,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.FieldGetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the field to use for the Property <c>get</c>.</param>
            <param name="field">The <see cref="T:System.Reflection.FieldInfo"/> for reflection.</param>
            <param name="name">The name of the Field.</param>
        </member>
        <member name="M:NHibernate.Property.FieldGetter.Get(System.Object)">
            <summary>
            Gets the value of the Field from the object.
            </summary>
            <param name="target">The object to get the Field value from.</param>
            <returns>
            The value of the Field for the target.
            </returns>
        </member>
        <member name="P:NHibernate.Property.FieldGetter.ReturnType">
            <summary>
            Gets the <see cref="T:System.Type"/> that the Field returns.
            </summary>
            <value>The <see cref="T:System.Type"/> that the Field returns.</value>
        </member>
        <member name="P:NHibernate.Property.FieldGetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value><c>null</c> since this is a Field - not a Property.</value>
        </member>
        <member name="P:NHibernate.Property.FieldGetter.Property">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value><c>null</c> since this is a Field - not a Property.</value>
        </member>
        <member name="T:NHibernate.Property.FieldSetter">
            <summary>
            An <see cref="T:NHibernate.Property.IGetter"/> that uses a Field instead of the Property <c>set</c>.
            </summary>
        </member>
        <member name="M:NHibernate.Property.FieldSetter.#ctor(System.Reflection.FieldInfo,System.Type,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.FieldSetter"/>.
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> that contains the Field to use for the Property <c>set</c>.</param>
            <param name="field">The <see cref="T:System.Reflection.FieldInfo"/> for reflection.</param>
            <param name="name">The name of the Field.</param>
        </member>
        <member name="M:NHibernate.Property.FieldSetter.Set(System.Object,System.Object)">
            <summary>
            Sets the value of the Field on the object.
            </summary>
            <param name="target">The object to set the Field value in.</param>
            <param name="value">The value to set the Field to.</param>
            <exception cref="T:NHibernate.PropertyAccessException">
            Thrown when there is a problem setting the value in the target.
            </exception>
        </member>
        <member name="P:NHibernate.Property.FieldSetter.PropertyName">
            <summary>
            Gets the name of the Property.
            </summary>
            <value><c>null</c> since this is a Field - not a Property.</value>
        </member>
        <member name="P:NHibernate.Property.FieldSetter.Property">
            <summary>
            Gets the <see cref="T:System.Reflection.PropertyInfo"/> for the Property.
            </summary>
            <value><c>null</c> since this is a Field - not a Property.</value>
        </member>
        <member name="T:NHibernate.Property.LowerCaseStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are  
            the PropertyName in all LowerCase characters.
            </summary>
        </member>
        <member name="M:NHibernate.Property.LowerCaseStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the all characters 
            of the <c>propertyName</c> lowercase.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in lowercase.</returns>
        </member>
        <member name="T:NHibernate.Property.LowerCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are prefixed with
            an underscore and the PropertyName is changed to lower case.
            </summary>
        </member>
        <member name="M:NHibernate.Property.LowerCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the all characters 
            of the <c>propertyName</c> lowercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in lowercase prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Property.NoSetterAccessor">
            <summary>
            Access the mapped property through a Property <c>get</c> to get the value 
            and go directly to the Field to set the value.
            </summary>
            <remarks>
            This is most useful because Classes can provider a get for the Property
            that is the <c>&lt;id&gt;</c> but tell NHibernate there is no setter for the Property
            so the value should be written directly to the field.
            </remarks>
        </member>
        <member name="M:NHibernate.Property.NoSetterAccessor.#ctor(NHibernate.Property.IFieldNamingStrategy)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Property.NoSetterAccessor"/>.
            </summary>
            <param name="namingStrategy">The <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> to use.</param>
        </member>
        <member name="M:NHibernate.Property.NoSetterAccessor.GetGetter(System.Type,System.String)">
            <summary>
            Creates an <see cref="T:NHibernate.Property.BasicGetter"/> to <c>get</c> the value from the Property.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="propertyName">The name of the mapped Property to get.</param>
            <returns>
            The <see cref="T:NHibernate.Property.BasicGetter"/> to use to get the value of the Property from an
            instance of the <see cref="T:System.Type"/>.</returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Property specified by the <c>propertyName</c> could not
            be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Property.NoSetterAccessor.GetSetter(System.Type,System.String)">
            <summary>
            Create a <see cref="T:NHibernate.Property.FieldSetter"/> to <c>set</c> the value of the mapped Property
            through a <c>Field</c>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the mapped Property in.</param>
            <param name="propertyName">The name of the mapped Property to set.</param>
            <returns>
            The <see cref="T:NHibernate.Property.FieldSetter"/> to use to set the value of the Property on an
            instance of the <see cref="T:System.Type"/>.
            </returns>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            Thrown when a Field for the Property specified by the <c>propertyName</c> using the
            <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> could not be found in the <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="T:NHibernate.Property.PascalCaseMUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are prefixed with
            an <c>m_</c> and the first character in PropertyName capitalized.
            </summary>
        </member>
        <member name="M:NHibernate.Property.PascalCaseMUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with the letter 'm' 
            and an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in PascalCase format prefixed with an 'm' and an underscore.</returns>
        </member>
        <member name="T:NHibernate.Property.PascalCaseUnderscoreStrategy">
            <summary>
            Implementation of <see cref="T:NHibernate.Property.IFieldNamingStrategy"/> for fields that are prefixed with
            an <c>_</c> and the first character in PropertyName capitalized.
            </summary>
        </member>
        <member name="M:NHibernate.Property.PascalCaseUnderscoreStrategy.GetFieldName(System.String)">
            <summary>
            Converts the Property's name into a Field name by making the first character 
            of the <c>propertyName</c> uppercase and prefixing it with an underscore.
            </summary>
            <param name="propertyName">The name of the mapped property.</param>
            <returns>The name of the Field in PascalCase format prefixed with an underscore.</returns>
        </member>
        <member name="T:NHibernate.Property.PropertyAccessorFactory">
            <summary>
            Factory for creating the various PropertyAccessor strategies.
            </summary>
        </member>
        <member name="M:NHibernate.Property.PropertyAccessorFactory.#cctor">
            <summary>
            Initializes the static members in <see cref="T:NHibernate.Property.PropertyAccessorFactory"/>.
            </summary>
        </member>
        <member name="M:NHibernate.Property.PropertyAccessorFactory.GetPropertyAccessor(System.String)">
            <summary>
            Gets or creates the <see cref="T:NHibernate.Property.IPropertyAccessor"/> specified by the type.
            </summary>
            <param name="type"></param>
            <returns>The <see cref="T:NHibernate.Property.IPropertyAccessor"/> specified by the type.</returns>
            <remarks>
            <para>
            The built in ways of accessing the values of Properties in your domain class are:
            </para>
            <list type="table">
            	<listheader>
            		<term>Access Method</term>
            		<description>How NHibernate accesses the Mapped Class.</description>
            	</listheader>
            	<item>
            		<term>property</term>
            		<description>
            			The <c>name</c> attribute is the name of the Property.  This is the 
            			default implementation.
            		</description>
            	</item>
            	<item>
            		<term>field</term>
            		<description>
            			The <c>name</c> attribute is the name of the field.  If you have any Properties
            			in the Mapped Class those will be bypassed and NHibernate will go straight to the
            			field.  This is a good option if your setters have business rules attached to them
            			or if you don't want to expose a field through a Getter &amp; Setter.
            		</description>
            	</item>
            	<item>
            		<term>nosetter</term>
            		<description>
            			The <c>name</c> attribute is the name of the Property.  NHibernate will use the 
            			Property's get method to retreive the value and will use the field
            			to set the value.  This is a good option for &lt;id&gt; Properties because this access method 
            			allow's users of the Class to get the value of the Id but not set the value.
            		</description>
            	</item>
            	<item>
            		<term>Assembly Qualified Name</term>
            		<description>
            			If NHibernate's built in <see cref="T:NHibernate.Property.IPropertyAccessor"/>s are not what is needed for your 
            			situation then you are free to build your own.  Provide an Assembly Qualified Name so that 
            			NHibernate can call <c>Activator.CreateInstance(AssemblyQualifiedName)</c> to create it.  
            		</description>
            	</item>
            </list>
            <para>
            In order for the <c>nosetter</c> to know the name of the field to access NHibernate needs to know
            what the naming strategy is.  The following naming strategies are built into NHibernate:
            </para>
            <list type="table">
            	<listheader>
            		<term>Naming Strategy</term>
            		<description>How NHibernate converts the value of the <c>name</c> attribute to a field name.</description>
            	</listheader>
            	<item>
            		<term>camelcase</term>
            		<description>
            			The <c>name</c> attribute should be changed to CamelCase to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>foo</c>.
            		</description>
            	</item>
            	<item>
            		<term>camelcase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be changed to CamelCase and prefixed with
            			an underscore to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>_foo</c>.
            		</description>
            	</item>
            	<item>
            		<term>pascalcase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be prefixed with an underscore
            			to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>_Foo</c>.
            		</description>
            	</item>
            	<item>
            		<term>pascalcase-m-underscore</term>
            		<description>
            			The <c>name</c> attribute should be prefixed with an 'm' and underscore
            			to find the field.
            			<c>&lt;property name="Foo" ... &gt;</c> finds a field <c>m_Foo</c>.
            		</description>
            	</item>
            	<item>
            		<term>lowercase</term>
            		<description>
            			The <c>name</c> attribute should be changed to lowercase to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>foobar</c>.
            		</description>
            	</item>
            	<item>
            		<term>lowercase-underscore</term>
            		<description>
            			The <c>name</c> attribute should be changed to lowercase and prefixed with
            			and underscore to find the field.
            			<c>&lt;property name="FooBar" ... &gt;</c> finds a field <c>_foobar</c>.
            		</description>
            	</item>
            </list>
            <para>
            The naming strategy can also be appended at the end of the <c>field</c> access method.  Where
            this could be useful is a scenario where you do expose a get and set method in the Domain Class 
            but NHibernate should only use the fields.  
            </para>
            <para>
            With a naming strategy and a get/set for the Property available the user of the Domain Class 
            could write an Hql statement <c>from Foo as foo where foo.SomeProperty = 'a'</c>.   If no naming 
            strategy was specified the Hql statement whould have to be <c>from Foo as foo where foo._someProperty</c>
             (assuming CamelCase with an underscore field naming strategy is used).  
            </para>
            </remarks>
        </member>
        <member name="P:NHibernate.Property.PropertyAccessorFactory.PropertyAccessors">
            <summary>
            Gets an <see cref="T:System.Collections.IDictionary"/> of the built in <see cref="T:NHibernate.Property.IPropertyAccessor"/> strategies.
            </summary>
            <value>An <see cref="T:System.Collections.IDictionary"/> of the built in <see cref="T:NHibernate.Property.IPropertyAccessor"/> strategies.</value>
        </member>
        <member name="T:NHibernate.Proxy.CastleLazyInitializer">
            <summary>
            A <see cref="T:NHibernate.Proxy.LazyInitializer"/> for use with the Castle Dynamic Class Generator.
            </summary>
        </member>
        <member name="T:NHibernate.Proxy.LazyInitializer">
            <summary>
            Provides the base functionallity to Handle Member calls into a dynamically
            generated NHibernate Proxy.
            </summary>
            <remarks>
            This could be an extension point later if the .net framework ever gets a Proxy
            class that is similar to the java.lang.reflect.Proxy or if a library similar
            to cglib was made in .net.
            </remarks>
        </member>
        <member name="F:NHibernate.Proxy.LazyInitializer.InvokeImplementation">
            <summary>
            If this is returned by Invoke then the subclass needs to Invoke the
            method call against the object that is being proxied.
            </summary>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.#ctor(System.Type,System.Object,System.Reflection.MethodInfo,System.Reflection.MethodInfo,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a LazyInitializer to handle all of the Methods/Properties that are called
            on the Proxy.
            </summary>
            <param name="persistentClass">The Class to Proxy.</param>
            <param name="id">The Id of the Object we are Proxying.</param>
            <param name="getIdentifierMethod"></param>
            <param name="setIdentifierMethod"></param>
            <param name="session">The ISession this Proxy is in.</param>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.Initialize">
            <summary>
            Perform an ImmediateLoad of the actual object for the Proxy.
            </summary>
            <exception cref="T:NHibernate.HibernateException">
            Thrown when the Proxy has no Session or the Session is closed or disconnected.
            </exception>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.InitializeWrapExceptions">
            <summary>
            Initializes the Proxy.
            </summary>
            <remarks>
            If an Exception is thrown then it will be logged and wrapped into a 
            <see cref="T:NHibernate.LazyInitializationException"/>.
            </remarks>
            <exception cref="T:NHibernate.LazyInitializationException">
            Thrown whenever a problem is encountered during the Initialization of the Proxy.
            </exception>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.AddSerializationInfo(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Adds all of the information into the SerializationInfo that is needed to
            reconstruct the proxy during deserialization or to replace the proxy
            with the instantiated target.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> to write the object to.</param>
            <remarks>
            This will only be called if the Dynamic Proxy generator does not handle serialization
            itself or delegates calls to the method GetObjectData to the LazyInitializer.
            </remarks>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.Invoke(System.Reflection.MethodBase,System.Object[],System.Object)">
            <summary>
            Invokes the method if this is something that the LazyInitializer can handle
            without the underlying proxied object being instantiated.
            </summary>
            <param name="method">The name of the method/property to Invoke.</param>
            <param name="args">The arguments to pass the method/property.</param>
            <returns>
            The result of the Invoke if the underlying proxied object is not needed.  If the 
            underlying proxied object is needed then it returns the result <see cref="F:NHibernate.Proxy.LazyInitializer.InvokeImplementation"/>
            which indicates that the Proxy will need to forward to the real implementation.
            </returns>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.GetImplementation">
            <summary>
            Return the Underlying Persistent Object, initializing if necessary.
            </summary>
            <returns>The Persistent Object this proxy is Proxying.</returns>
        </member>
        <member name="M:NHibernate.Proxy.LazyInitializer.GetImplementation(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Return the Underlying Persistent Object in a given <see cref="T:NHibernate.ISession"/>, or null.
            </summary>
            <param name="s">The Session to get the object from.</param>
            <returns>The Persistent Object this proxy is Proxying, or <c>null</c>.</returns>
        </member>
        <member name="P:NHibernate.Proxy.LazyInitializer.Identifier">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Proxy.LazyInitializer.PersistentClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Proxy.LazyInitializer.IsUninitialized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Proxy.LazyInitializer.Session">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Proxy.CastleLazyInitializer.#ctor(System.Type,System.Object,System.Reflection.MethodInfo,System.Reflection.MethodInfo,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new <see cref="T:NHibernate.Proxy.CastleLazyInitializer"/> object.
            </summary>
            <param name="persistentClass">The Class to Proxy.</param>
            <param name="id">The Id of the Object we are Proxying.</param>
            <param name="getIdentifierMethod"></param>
            <param name="setIdentifierMethod"></param>
            <param name="session">The ISession this Proxy is in.</param>
        </member>
        <member name="M:NHibernate.Proxy.CastleLazyInitializer.Intercept(Castle.DynamicProxy.IInvocation,System.Object[])">
            <summary>
            Invoke the actual Property/Method using the Proxy or instantiate the actual
            object and use it when the Proxy can't handle the method. 
            </summary>
            <param name="invocation">The <see cref="T:Castle.DynamicProxy.IInvocation"/> from the generated Castle.DynamicProxy.</param>
            <param name="args">The parameters for the Method/Property</param>
            <returns>The result just like the actual object was called.</returns>
        </member>
        <member name="M:NHibernate.Proxy.IProxyFactory.PostInstantiate(System.Type,Iesi.Collections.ISet,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
            <summary>
            Called immediately after instantiation
            </summary>
            <param name="persistentClass"></param>
            <param name="interfaces"></param>
            <param name="getIdentifierMethod"></param>
            <param name="setIdentifierMethod"></param>
        </member>
        <member name="M:NHibernate.Proxy.IProxyFactory.GetProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Create a new proxy
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Proxy.CastleProxyFactory.GetProxy(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Build a proxy using the Castle.DynamicProxy library.
            </summary>
            <param name="id">The value for the Id.</param>
            <param name="session">The Session the proxy is in.</param>
            <returns>A fully built <c>INHibernateProxy</c>.</returns>
        </member>
        <member name="T:NHibernate.Proxy.INHibernateProxy">
            <summary>
            A marker interface so NHibernate can know if it is dealing with
            an object that is a Proxy. 
            </summary>
            <remarks>
            <para>
            This interface should not be implemented by anything other than
            the Dynamically generated Proxy.  If it is implemented by a class then
            NHibernate will think that class is a Proxy and will not work.
            </para> 
            <para>
            It has to be public scope because
            the Proxies are created in a seperate DLL than NHibernate. 
            </para> 
            </remarks>
        </member>
        <member name="T:NHibernate.Proxy.NHibernateProxyHelper">
            <summary>
            NHibernateProxyHelper provides convenience methods for working with
            objects that might be instances of Classes or the Proxied version of 
            the Class.
            </summary>
        </member>
        <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GetLazyInitializer(NHibernate.Proxy.INHibernateProxy)">
            <summary>
            Gets the <see cref="T:NHibernate.Proxy.LazyInitializer"/> that is used by the Proxy.
            </summary>
            <param name="proxy">The Proxy object</param>
            <returns>
            A reference to <see cref="T:NHibernate.Proxy.LazyInitializer"/> that contains the details 
            of the Proxied object.
            </returns>
        </member>
        <member name="M:NHibernate.Proxy.NHibernateProxyHelper.GetClass(System.Object)">
            <summary>
            Convenience method to figure out the underlying type for the object regardless of it
            is a Proxied object or the real object.
            </summary>
            <param name="obj">The object to get the type of.</param>
            <returns>The Underlying Type for the object regardless of if it is a Proxy.</returns>
        </member>
        <member name="T:NHibernate.SqlCommand.Alias">
            <summary>
            Aliases tables and fields for Sql Statements.
            </summary>
            <remarks>
            Several methods of this class take an additional
            <see cref="T:NHibernate.Dialect.Dialect"/> parameter, while their Java counterparts
            do not. The dialect is used to correctly quote and unquote identifiers.
            Java versions do the quoting and unquoting themselves and fail to
            consider dialect-specific rules, such as escaping closing brackets in
            identifiers on MS SQL 2000.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <param name="suffix"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="suffix"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToAliasString(System.String,NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifier"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToUnquotedAliasString(System.String,NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifier"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToUnquotedAliasStrings(System.String[],NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifiers"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Alias.ToAliasStrings(System.String[],NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="sqlIdentifiers"></param>
            <param name="dialect"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.SqlCommand.ANSICaseFragment">
            <summary>
            Represents an SQL <c>case when ... then ... end as ...</c>
            </summary>
            <remarks>This class looks StringHelper.SqlParameter safe...</remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.CaseFragment">
            <summary>
            Represents an SQL <c>case when ... then ... end as ...</c>
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.CaseFragment.SetReturnColumnName(System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.CaseFragment.SetReturnColumnName(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.CaseFragment.AddWhenColumnNotNull(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnName"></param>
            <param name="columnValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.CaseFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.SetReturnColumnName(System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.SetReturnColumnName(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.AddWhenColumnNotNull(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnName"></param>
            <param name="columnValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSICaseFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ANSIJoinFragment">
            <summary>
            An ANSI-style Join.
            </summary>
        </member>
        <member name="T:NHibernate.SqlCommand.JoinFragment">
            <summary>
            Represents a SQL <c>JOIN</c>
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddJoin(System.String,System.String,System.String[],System.String[],NHibernate.SqlCommand.JoinType)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
            <param name="joinType"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddCrossJoin(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddJoins(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fromFragment"></param>
            <param name="whereFragment"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddCondition(System.String,System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columns"></param>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddCondition(System.String,System.String[],System.String,NHibernate.Type.IType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columns"></param>
            <param name="condition"></param>
            <param name="conditionType"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddCondition(System.String,System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddCondition(System.String)">
            <summary>
            
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddCondition(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddFromFragmentString(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fromFragmentString"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.Copy">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddFragment(NHibernate.SqlCommand.JoinFragment)">
            <summary>
            
            </summary>
            <param name="ojf"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.JoinFragment.AddJoins(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="fromFragment"></param>
            <param name="whereFragment"></param>
        </member>
        <member name="P:NHibernate.SqlCommand.JoinFragment.ToFromFragmentString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.JoinFragment.ToWhereFragmentString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddJoin(System.String,System.String,System.String[],System.String[],NHibernate.SqlCommand.JoinType)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
            <param name="joinType"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddJoins(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fromFragment"></param>
            <param name="whereFragment"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.Copy">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddCondition(System.String,System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columns"></param>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddCondition(System.String,System.String[],System.String,NHibernate.Type.IType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columns"></param>
            <param name="condition"></param>
            <param name="conditionType"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddCrossJoin(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddCondition(System.String,System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddCondition(System.String)">
            <summary>
            
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddCondition(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.ANSIJoinFragment.AddFromFragmentString(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fromFragmentString"></param>
        </member>
        <member name="P:NHibernate.SqlCommand.ANSIJoinFragment.ToFromFragmentString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.ANSIJoinFragment.ToWhereFragmentString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ConditionalFragment">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetOp(System.String)">
            <summary>
            Sets the op
            </summary>
            <param name="op">The op to set</param>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetTableAlias(System.String)">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetCondition(System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.SetCondition(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ConditionalFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.DecodeCaseFragment">
            <summary>
            Represents an SQL decode(pkvalue, key1, 1, key2, 2, ..., 0)
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.SetReturnColumnName(System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.SetReturnColumnName(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="returnColumnName"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.AddWhenColumnNotNull(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnName"></param>
            <param name="columnValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.DecodeCaseFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ForUpdateFragment">
            <summary>
            Represents an SQL <c>for update of ... nowait</c> statement
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ForUpdateFragment.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ForUpdateFragment.AddTableAlias(System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ForUpdateFragment.ToSqlStringFragment(NHibernate.Dialect.Dialect)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.ForUpdateFragment.NoWait">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.InFragment">
            <summary>
            Represents an <c>... in (...)</c> expression
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.InFragment.Null">
            <summary></summary>
        </member>
        <member name="F:NHibernate.SqlCommand.InFragment.NotNull">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.AddValue(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.SetColumn(System.String)">
            <summary>
            
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.SetColumn(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.InFragment.ToFragmentString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.ISqlStringBuilder">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.ISqlStringBuilder.ToSqlString">
            <summary>
            Builds a SqlString from the internal data.
            </summary>
            <returns>A valid SqlString that can be converted into an IDbCommand</returns>
        </member>
        <member name="T:NHibernate.SqlCommand.JoinType">
            <summary></summary>
        </member>
        <member name="F:NHibernate.SqlCommand.JoinType.None">
            <summary></summary>
        </member>
        <member name="F:NHibernate.SqlCommand.JoinType.InnerJoin">
            <summary></summary>
        </member>
        <member name="F:NHibernate.SqlCommand.JoinType.FullJoin">
            <summary></summary>
        </member>
        <member name="F:NHibernate.SqlCommand.JoinType.LeftOuterJoin">
            <summary></summary>
        </member>
        <member name="F:NHibernate.SqlCommand.JoinType.RightOuterJoin">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.OracleJoinFragment">
            <summary>
            An Oracle-style (theta) Join
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddJoin(System.String,System.String,System.String[],System.String[],NHibernate.SqlCommand.JoinType)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
            <param name="joinType"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddJoins(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fromFragment"></param>
            <param name="whereFragment"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.Copy">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddCondition(System.String,System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columns"></param>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddCondition(System.String,System.String[],System.String,NHibernate.Type.IType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columns"></param>
            <param name="condition"></param>
            <param name="conditionType"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddCrossJoin(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddCondition(System.String,System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddCondition(System.String)">
            <summary>
            
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddCondition(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.OracleJoinFragment.AddFromFragmentString(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fromFragmentString"></param>
        </member>
        <member name="P:NHibernate.SqlCommand.OracleJoinFragment.ToFromFragmentString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.OracleJoinFragment.ToWhereFragmentString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.Parameter">
            <summary>
            An immutable Parameter that later will be converted into an IDbParameter
            for an IDbCommand.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.SqlCommand.Parameter"/> class.
            </summary>
            <param name="name">The name of the parameter.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.#ctor(System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.SqlCommand.Parameter"/> class.
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="sqlType">The <see cref="P:NHibernate.SqlCommand.Parameter.SqlType"/> to create the parameter for.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.#ctor(System.String,System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.SqlCommand.Parameter"/> class.
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="tableAlias">The Alias to use for the table.</param>
            <param name="sqlType">The <see cref="P:NHibernate.SqlCommand.Parameter.SqlType"/> to create the parameter for.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.GenerateParameters(NHibernate.Engine.IMapping,System.String[],NHibernate.Type.IType)">
            <summary>
            Generates an Array of Parameters for the columns that make up the IType
            </summary>
            <param name="columnNames">The names of the Columns that compose the IType</param>
            <param name="type">The IType to turn into Parameters</param>
            <param name="factory"></param>
            <returns>An Array of <see cref="T:NHibernate.SqlCommand.Parameter"/> objects</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.GenerateParameters(NHibernate.Engine.IMapping,System.String,System.String[],NHibernate.Type.IType)">
            <summary>
            Generates an Array of Parameters for the columns that make up the IType
            </summary>
            <param name="factory">The SessionFactory to use to get the DbTypes.</param>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="columnNames">The names of the Columns that compose the IType</param>
            <param name="type">The IType to turn into Parameters</param>
            <returns>An Array of <see cref="T:NHibernate.SqlCommand.Parameter"/> objects</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.Equals(System.Object)">
            <summary>
            Determines wether this instance and the specified object 
            are the same Type and have the same values.
            </summary>
            <param name="obj">An object to compare to this instance.</param>
            <returns>
            <c>true</c> if the object is a Parameter (not a subclass) and has the
            same values.
            </returns>
            <remarks>
            Each subclass needs to implement their own <c>Equals</c>. 
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.Equals(NHibernate.SqlCommand.Parameter,System.Boolean)">
            <summary>
            Determines if this instance and the specified object have the 
            same values.  If <c>isTypeSensitive==true</c> then <c>rhs</c>
            has to be a <see cref="T:NHibernate.SqlCommand.Parameter"/> and can not be a subclass.
            </summary>
            <param name="rhs">The <see cref="T:NHibernate.SqlCommand.Parameter"/> to compare to this instance.</param>
            <param name="isTypeSensitive">
            <c>true</c> if <c>rhs</c> has to be a <see cref="T:NHibernate.SqlCommand.Parameter"/> and not a subclass,
            <c>false</c> if <c>rhs</c> can be a subclass of <see cref="T:NHibernate.SqlCommand.Parameter"/>.</param>
            <returns>
            <c>true</c> if the properties in <see cref="T:NHibernate.SqlCommand.Parameter"/> are all the same.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.GetHashCode">
            <summary>
            Gets a hash code based on the SqlType, Name, and TableAlias properties.
            </summary>
            <returns>
            An <see cref="T:System.Int32"/> value for the hash code.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Parameter.System#ICloneable#Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:NHibernate.SqlCommand.Parameter.Name">
            <summary>
            Gets the name of the Parameter.
            </summary>
            <value>The name of the Parameter.</value>
            <remarks>
            The Parameter name is not used by anything except to compare equality
            and to generate a debug string.
            </remarks>
        </member>
        <member name="P:NHibernate.SqlCommand.Parameter.SqlType">
            <summary>
            Gets the <see cref="P:NHibernate.SqlCommand.Parameter.SqlType"/> that defines the specifics of 
            the IDbDataParameter.
            </summary>
            <value>
            The <see cref="P:NHibernate.SqlCommand.Parameter.SqlType"/> that defines the specifics of 
            the IDbDataParameter.
            </value>
        </member>
        <member name="T:NHibernate.SqlCommand.ParameterLength">
            <summary>
            Extension to the Parameter class that supports Parameters with
            a Length.
            </summary>
            <remarks>
            This should only be used when the property needs to be mapped with
            a <c>type="String(200)"</c> because for some reason the default parameter
            generation of <c>nvarchar(4000)</c> (MsSql specific) is not good enough.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.ParameterLength.#ctor(System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.SqlCommand.ParameterLength"/> class.
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="sqlType">
            The <see cref="T:NHibernate.SqlTypes.SqlType"/> that contains a Length 
            to create the parameter for.
            </param>
        </member>
        <member name="M:NHibernate.SqlCommand.ParameterLength.#ctor(System.String,System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.SqlCommand.ParameterLength"/> class.
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="tableAlias">The Alias to use for the table.</param>
            <param name="sqlType">
            The <see cref="T:NHibernate.SqlTypes.SqlType"/> that contains a Length 
            to create the parameter for.
            </param>
        </member>
        <member name="M:NHibernate.SqlCommand.ParameterLength.Equals(System.Object)">
            <summary>
            Determines wether this instance and the specified object 
            are the same Type and have the same values.
            </summary>
            <param name="obj">An object to compare to this instance.</param>
            <returns>
            <c>true</c> if the object is a <see cref="T:NHibernate.SqlCommand.ParameterLength"/> and has the
            same values.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ParameterLength.GetHashCode">
            <summary>
            Gets a hash code based on the SqlType, Name, and TableAlias properties.
            </summary>
            <returns>
            An <see cref="T:System.Int32"/> value for the hash code.
            </returns>
            <remarks>
            This just uses the <see cref="T:NHibernate.SqlCommand.Parameter"/>'s <c>GetHashCode()</c> method.  The
            compiler complains if Equals is implemented without a GetHashCode.
            </remarks>
        </member>
        <member name="P:NHibernate.SqlCommand.ParameterLength.Length">
            <summary>
            Gets the length of data the IDbDataParameter should hold.
            </summary>
            <value>The length of data the IDbDataParameter should hold.</value>
        </member>
        <member name="T:NHibernate.SqlCommand.ParameterPrecisionScale">
            <summary>
            An immutable Parameter that supports a Precision and a Scale
            </summary>
            <remarks>
            This should only be used when the property needs to be mapped with
            a <c>type="Decimal(20,4)"</c> because for some reason the default parameter
            generation of <c>decimal(19,5)</c> (MsSql specific) is not good enough.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.ParameterPrecisionScale.#ctor(System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.SqlCommand.ParameterPrecisionScale"/> class.
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="sqlType">
            The <see cref="T:NHibernate.SqlTypes.SqlType"/> that contains a Precision &amp; Scale 
            to create the parameter for.
            </param>
        </member>
        <member name="M:NHibernate.SqlCommand.ParameterPrecisionScale.#ctor(System.String,System.String,NHibernate.SqlTypes.SqlType)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.SqlCommand.ParameterPrecisionScale"/> class.
            </summary>
            <param name="name">The name of the parameter.</param>
            <param name="tableAlias">The Alias to use for the table.</param>
            <param name="sqlType">
            The <see cref="T:NHibernate.SqlTypes.SqlType"/> that contains a Precision &amp; Scale 
            to create the parameter for.
            </param>
        </member>
        <member name="M:NHibernate.SqlCommand.ParameterPrecisionScale.Equals(System.Object)">
            <summary>
            Determines wether this instance and the specified object 
            are the same Type and have the same values.
            </summary>
            <param name="obj">An object to compare to this instance.</param>
            <returns>
            <c>true</c> if the object is a <see cref="T:NHibernate.SqlCommand.ParameterPrecisionScale"/> and has the
            same values.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.ParameterPrecisionScale.GetHashCode">
            <summary>
            Gets a hash code based on the SqlType, Name, and TableAlias properties.
            </summary>
            <returns>
            An <see cref="T:System.Int32"/> value for the hash code.
            </returns>
            <remarks>
            This just uses the <see cref="T:NHibernate.SqlCommand.Parameter"/>'s <c>GetHashCode()</c> method.  The
            compiler complains if Equals is implemented without a GetHashCode.
            </remarks>
        </member>
        <member name="P:NHibernate.SqlCommand.ParameterPrecisionScale.Precision">
            <summary>
            Gets the precision of data the IDbDataParameter should hold.
            </summary>
            <value>The precision of data the IDbDataParameter should hold.</value>
        </member>
        <member name="P:NHibernate.SqlCommand.ParameterPrecisionScale.Scale">
            <summary>
            Gets the scale of data the IDbDataParameter should hold.
            </summary>
            <value>The scale of data the IDbDataParameter should hold.</value>
        </member>
        <member name="T:NHibernate.SqlCommand.QueryJoinFragment">
            <summary>
            Summary description for QueryJoinFragment.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.#ctor(NHibernate.Dialect.Dialect,System.Boolean)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
            <param name="useThetaStyleInnerJoins"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddJoin(System.String,System.String,System.String[],System.String[],NHibernate.SqlCommand.JoinType)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
            <param name="joinType"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddJoin(System.String,System.String,System.String,System.String[],System.String[],NHibernate.SqlCommand.JoinType)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
            <param name="concreteAlias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
            <param name="joinType"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddJoins(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fromFragment"></param>
            <param name="whereFragment"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.Copy">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddCondition(System.String,System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columns"></param>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddCondition(System.String,System.String[],System.String,NHibernate.Type.IType,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columns"></param>
            <param name="condition"></param>
            <param name="conditionType"></param>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddCrossJoin(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <param name="alias"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddCondition(System.String,System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="fkColumns"></param>
            <param name="pkColumns"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddCondition(System.String)">
            <summary>
            
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddCondition(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="condition"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QueryJoinFragment.AddFromFragmentString(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fromFragmentString"></param>
        </member>
        <member name="P:NHibernate.SqlCommand.QueryJoinFragment.ToFromFragmentString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.QueryJoinFragment.ToWhereFragmentString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.QuerySelect">
            <summary>
            Summary description for QuerySelect.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.QuerySelect.dontSpace">
            <summary>
            Certain databases don't like spaces around these operators.
            </summary>
            <remarks>
            This needs to contain both a plain string and a 
            SqlString version of the operator because the portions in 
            the WHERE clause will come in as SqlStrings since there
            might be parameters, other portions of the clause come in
            as strings since there are no parameters.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="dialect"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectFragmentString(System.String)">
            <summary>
            
            </summary>
            <param name="fragment"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectFragmentString(NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="fragment"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddSelectColumn(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="columnName"></param>
            <param name="alias"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetWhereTokens(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetGroupByTokens(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetOrderByTokens(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.SetHavingTokens(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="tokens"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AddOrderBy(System.String)">
            <summary>
            Adds a string containing a valid "order by" sql statement
            to this QuerySelect
            </summary>
            <param name="orderBySql">The "order by" sql statement.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.ToQuerySqlString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AppendTokens(System.Text.StringBuilder,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="buf"></param>
            <param name="iter"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.QuerySelect.AppendTokens(NHibernate.SqlCommand.SqlStringBuilder,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="builder"></param>
            <param name="iter"></param>
        </member>
        <member name="P:NHibernate.SqlCommand.QuerySelect.JoinFragment">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.QuerySelect.Distinct">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SelectFragment">
            <summary>
            Represents part of an SQL <c>SELECT</c> clause
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.#ctor(NHibernate.Dialect.Dialect)">
            <summary>
            
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.SetUsedAliases(System.String[])">
            <summary>
            
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.SetSuffix(System.String)">
            <summary>
            
            </summary>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.AddColumn(System.String)">
            <summary>
            
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.AddColumns(System.String[])">
            <summary>
            
            </summary>
            <param name="columnNames"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.AddColumn(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.AddColumn(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <param name="columnName"></param>
            <param name="columnAlias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.AddColumns(System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <param name="columnNames"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.AddColumns(System.String,System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <param name="columnNames"></param>
            <param name="columnAliases"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.AddFormulas(System.String,System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <param name="formulas"></param>
            <param name="formulaAliases"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.AddFormula(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="tableAlias"></param>
            <param name="formula"></param>
            <param name="formulaAlias"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.ToSqlStringFragment">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SelectFragment.ToSqlStringFragment(System.Boolean)">
            <summary>
            
            </summary>
            <param name="includeLeadingComma"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlBaseBuilder">
            <summary>
            The base class for all of the SqlBuilders.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String[],System.Object[])">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <param name="columnValues">The Values for the Columns in the WhereFragment</param>
            <returns>A SqlString that contains the WhereFragment</returns>
            <remarks>This just calls the overloaded ToWhereFragment() with the operator as " = " and the tableAlias null.</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String,System.String[],System.Object[])">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <param name="columnValues">The Values for the Columns in the WhereFragment</param>
            <returns>A SqlString that contains the WhereFragment</returns>
            <remarks>This defaults the op to " = "</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String[],System.Object[],System.String)">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <param name="columnValues">The Values for the Columns in the WhereFragment</param>
            <param name="op">The operator to use between the names &amp; values.  For example " = " or "!="</param>
            <returns>A SqlString that contains the WhereFragment</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlBaseBuilder.ToWhereString(System.String,System.String[],System.Object[],System.String)">
            <summary>
            Converts the ColumnNames and ColumnValues to a WhereFragment
            </summary>
            <param name="tableAlias">The Alias for the Table.</param>
            <param name="columnNames">The names of the Columns to Add to the WhereFragment</param>
            <param name="columnValues">The Values for the Columns in the WhereFragment</param>
            <param name="op">The operator to use between the names &amp; values.  For example " = " or "!="</param>
            <returns>A SqlString that contains the WhereFragment</returns>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlDeleteBuilder">
            <summary>
            A class that builds an <c>DELETE</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetTableName(System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>DELETE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlDeleteBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>DELETE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlDeleteBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlDeleteBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.AddWhereFragment(System.String)">
            <summary>
            Adds a string to the WhereFragement
            </summary>
            <param name="whereSql">A well formed sql statement with no parameters.</param>
            <returns>The SqlDeleteBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlDeleteBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlInsertBuilder">
            <summary>
            A class that builds an <c>INSERT</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.#ctor(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.SetTableName(System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Adds the Property's columns to the INSERT sql
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="propertyType">The IType of the property.</param>
            <returns>The SqlInsertBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,System.Object,NHibernate.Type.ILiteralType)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">The value to set for the column.</param>
            <param name="literalType">The NHibernateType to use to convert the value to a sql string.</param>
            <returns>The SqlInsertBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.AddColumn(System.String,System.String)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">A valid sql string to set as the value of the column.</param>
            <returns>The SqlInsertBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlInsertBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlSelectBuilder">
            <summary>
            A class that builds an <c>INSERT</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.#ctor(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(System.String)">
            <summary>
            Sets the text that should appear after the FROM 
            </summary>
            <param name="fromClause">The fromClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(System.String,System.String)">
            <summary>
            Sets the text that should appear after the FROM 
            </summary>
            <param name="tableName">The name of the Table to get the data from</param>
            <param name="alias">The Alias to use for the table name.</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetFromClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the text that should appear after the FROM
            </summary>
            <param name="fromClause">The fromClause in a SqlString</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOrderByClause(System.String)">
            <summary>
            Sets the text that should appear after the ORDER BY.
            </summary>
            <param name="orderByClause">The orderByClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOuterJoins(System.String,System.String)">
            <summary>
            Sets the SQL for the OUTER JOINs.  
            </summary>
            <remarks>
            All of the SQL needs to be included in the SELECT.  No OUTER JOINS will automatically be
            added.
            </remarks>
            <param name="outerJoinsAfterFrom">The outerJoinsAfterFrom to set</param>
            <param name="outerJoinsAfterWhere">The outerJoinsAfterWhere to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOuterJoins(NHibernate.SqlCommand.SqlString,System.String)">
            <summary>
            
            </summary>
            <param name="outerJoinsAfterFrom"></param>
            <param name="outerJoinsAfterWhere"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOuterJoins(System.String,NHibernate.SqlCommand.SqlString)">
            <summary>
            
            </summary>
            <param name="outerJoinsAfterFrom"></param>
            <param name="outerJoinsAfterWhere"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetOuterJoins(NHibernate.SqlCommand.SqlString,NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the SqlString for the OUTER JOINs.  
            </summary>
            <remarks>
            All of the Sql needs to be included in the SELECT.  No OUTER JOINS will automatically be
            added.
            </remarks>
            <param name="outerJoinsAfterFrom">The outerJoinsAfterFrom to set</param>
            <param name="outerJoinsAfterWhere">The outerJoinsAfterWhere to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetSelectClause(System.String)">
            <summary>
            Sets the text for the SELECT
            </summary>
            <param name="selectClause">The selectClause to set</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetWhereClause(System.String,System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the criteria to use for the WHERE.  It joins all of the columnNames together with an AND.
            </summary>
            <param name="tableAlias"></param>
            <param name="columnNames">The names of the columns</param>
            <param name="whereType">The Hibernate Type</param>
            <returns>The SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.SetWhereClause(NHibernate.SqlCommand.SqlString)">
            <summary>
            Sets the prebuilt SqlString to the Where clause
            </summary>
            <param name="whereSqlString">The SqlString that contains the sql and parameters to add to the WHERE</param>
            <returns>This SqlSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSelectBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlSimpleSelectBuilder">
            <summary>
            Summary description for SqlSimpleSelectBuilder.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.#ctor(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetTableName(System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumn(System.String)">
            <summary>
            Adds a columnName to the SELECT fragment.
            </summary>
            <param name="columnName">The name of the column to add.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumn(System.String,System.String)">
            <summary>
            Adds a columnName and its Alias to the SELECT fragment.
            </summary>
            <param name="columnName">The name of the column to add.</param>
            <param name="alias">The alias to use for the column</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumns(System.String[])">
            <summary>
            Adds an array of columnNames to the SELECT fragment.
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddColumns(System.String[],System.String[])">
            <summary>
            Adds an array of columnNames with their Aliases to the SELECT fragment.
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="aliases">The aliases to use for the columns</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.GetAlias(System.String)">
            <summary>
            Gets the Alias that should be used for the column
            </summary>
            <param name="columnName">The name of the column to get the Alias for.</param>
            <returns>The Alias if one exists, null otherwise</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>SELECT</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlSimpleSelectBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>SELECT</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlSimpleSelectBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetForUpdateFragment(System.String)">
            <summary>
            Sets the For Update Fragment to the Select Command
            </summary>
            <param name="fragment">The fragment to set.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.SetOrderBy(System.String)">
            <summary>
            Set the Order By fragment of the Select Command
            </summary>
            <param name="orderBy">The OrderBy fragment.  It should include the SQL "ORDER BY"</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlSimpleSelectBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlSimpleSelectBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlString">
            <summary>
            This is a non-modifiable Sql statement that is ready to be prepared 
            and sent to the Database for execution.
            
            If you need to modify this object pass it to a <c>SqlStringBuilder</c> and
            get a new object back from it.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="sqlPart"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.#ctor(System.Object[])">
            <summary>
            
            </summary>
            <param name="sqlParts"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Append(NHibernate.SqlCommand.SqlString)">
            <summary>
            Appends the SqlString parameter to the end of the current SqlString to create a 
            new SqlString object.
            </summary>
            <param name="rhs">The SqlString to append.</param>
            <returns>A new SqlString object.</returns>
            <remarks>
            A SqlString object is immutable so this returns a new SqlString.  If multiple Appends 
            are called it is better to use the SqlStringBuilder.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Append(System.String)">
            <summary>
            Appends the string parameter to the end of the current SqlString to create a 
            new SqlString object.
            </summary>
            <param name="rhs">The string to append.</param>
            <returns>A new SqlString object.</returns>
            <remarks>
            A SqlString object is immutable so this returns a new SqlString.  If multiple Appends 
            are called it is better to use the SqlStringBuilder.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Compact">
            <summary>
            Compacts the SqlString into the fewest parts possible.
            </summary>
            <returns>A new SqlString.</returns>
            <remarks>
            Combines all SqlParts that are strings and next to each other into
            one SqlPart.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.EndsWith(System.String)">
            <summary>
            Determines whether the end of this instance matches the specified String.
            </summary>
            <param name="value">A string to seek at the end.</param>
            <returns><c>true</c> if the end of this instance matches value; otherwise, <c>false</c></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Replace(System.String,System.String)">
            <summary>
            Replaces all occurrences of a specified <see cref="T:System.String"/> in this instance, 
            with another specified <see cref="T:System.String"/> .
            </summary>
            <param name="oldValue">A String to be replaced.</param>
            <param name="newValue">A String to replace all occurrences of oldValue. </param>
            <returns>
            A new SqlString with oldValue replaced by the newValue.  The new SqlString is 
            in the Compacted form.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.StartsWith(System.String)">
            <summary>
            Determines whether the beginning of this SqlString matches the specified System.String
            </summary>
            <param name="value">The System.String to seek</param>
            <returns>true if the SqlString starts with the value.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Substring(System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position. 
            </summary>
            <param name="startIndex">The starting character position of a substring in this instance.</param>
            <returns>
            A new SqlString to the substring that begins at startIndex in this instance. 
            </returns>
            <remarks>
            If the first SqlPart is a Parameter then no action is taken and a copy of the SqlString is
            returned.
            
            If the startIndex is greater than the length of the strings before the first SqlPart that
            is a Parameter then all of the strings will be removed and the first SqlPart returned
            will be the Parameter. 
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Trim">
            <summary>
            Removes all occurrences of white space characters from the beginning and end of this instance.
            </summary>
            <returns>
            A new SqlString equivalent to this instance after white space characters 
            are removed from the beginning and end.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.ToString">
            <summary>
            Returns the SqlString in a string where it looks like
            SELECT col1, col2 FROM table WHERE col1 = :param1
            
            The ":" is used as the indicator of a parameter because at this point
            we are not using the specific Provider so we don't know how that provider
            wants our parameters formatted.
            </summary>
            <returns>A Provider nuetral version of the CommandText</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.Clone">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlString.System#ICloneable#Clone">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlString.SqlParts">
            <summary></summary>
            <remarks>
            TODO: modify this from object[] to an ICollection so that we can
            safely say that SqlString truly is immutable.  Right now someone
            can change the contents of the array - hence changing the SqlString
            and throwing any place this is used as a key in a hashtable into
            an unfindable instance.
            </remarks>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlString.ContainsUntypedParameter">
            <summary>
            Gets a bool that indicates if there is a Parameter that has a null SqlType.
            </summary>
            <value>true if there is a Parameter with a null SqlType.</value>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlString.Count">
            <summary>
            Gets the number of SqlParts contained in this SqlString.
            </summary>
            <value>The number of SqlParts contained in this SqlString.</value>
            <remarks>
            If a SqlPart contains a SqlString then this recursively looks at each SqlPart
            for the Count.
            </remarks>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlString.IsEmpty">
            <summary>
            Determines if this <see cref="T:NHibernate.SqlCommand.SqlString"/> contains no parts
            or only has parts containing an empty string.
            </summary>
            <value>
            <c>true</c> if there are no parts containing a valid string or if one
            of the parts has a parameter in it, <c>false</c> otherwise.
            </value>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlString.ParameterIndexes">
            <summary>
            Gets the indexes of the Parameters in the SqlParts array.
            </summary>
            <value>
            An Int32 array that contains the indexes of the Parameters in the SqlPart array.
            </value>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlStringBuilder">
            <summary>
            The SqlStringBuilder is used to construct a SqlString.  The SqlString is a nonmutable
            class so it can't have sql parts added to it.  Instead this class should be used to
            generate a new SqlString.  The SqlStringBuilder is to SqlString what 
            the StringBuilder is to a String.  
             
            This might actually be a good use for a struct - very lightweight and gives me th
            modifications if I pass it to a method such as AddLock(ISqlCommand)...
            </summary>
            <remarks>
            This is a modifiable version - the unmodifiable version is SqlString.  This
            should mimic the use of a StringBuilder and just plain String.
            
            This is different from the original version of SqlString because this does not
            hold the sql string in the form of "column1=@column1" instead it uses an array to
            build the sql statement such that 
            object[0] = "column1="
            object[1] = ref to column1 parameter
            
            What this allows us to do is to delay the generating of the parameter for the sql
            until the very end - making testing dialect indifferent.  Right now all of our test
            to make sure the correct sql is getting built are specific to MsSql2000Dialect.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor">
            <summary>
            Create an empty StringBuilder with the default capacity.  
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor(System.Int32)">
            <summary>
            Create a StringBuilder with a specific capacity.
            </summary>
            <param name="partsCapacity">The number of parts expected.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.#ctor(NHibernate.SqlCommand.SqlString)">
            <summary>
            Create a StringBuilder to modify the SqlString
            </summary>
            <param name="sqlString">The SqlString to modify.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(System.String)">
            <summary>
            Adds the preformatted sql to the SqlString that is being built.
            </summary>
            <param name="sql">The string to add.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.Parameter)">
            <summary>
            Adds the Parameter to the SqlString that is being built.
            The correct operator should be added before the Add(Parameter) is called
            because there will be no operator ( such as "=" ) placed between the last Add call
            and this Add call.
            </summary>
            <param name="parameter">The Parameter to add.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.AddObject(System.Object)">
            <summary>
            Attempts to discover what type of object this is and calls the appropriate
            method.
            </summary>
            <param name="part">The part to add when it is not known if it is a Parameter, String, or SqlString.</param>
            <returns>This SqlStringBuilder.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the part is not a Parameter, String, or SqlString.</exception>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString)">
            <summary>
            Adds an existing SqlString to this SqlStringBuilder.  It does NOT add any
            prefix, postfix, operator, or wrap around this.  It is equivalent to just 
            adding a string.
            </summary>
            <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>This calls the overloaded Add(sqlString, null, null, null, false)</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString,System.String,System.String,System.String)">
            <summary>
            Adds an existing SqlString to this SqlStringBuilder
            </summary>
            <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
            <param name="prefix">String to put at the beginning of the combined SqlString.</param>
            <param name="op">How these Statements should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlString.</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>
            This calls the overloaded Add method with an array of SqlStrings and wrapStatment=false
            so it will not be wrapped with a "(" and ")"
            </remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Adds an existing SqlString to this SqlStringBuilder
            </summary>
            <param name="sqlString">The SqlString to add to this SqlStringBuilder</param>
            <param name="prefix">String to put at the beginning of the combined SqlString.</param>
            <param name="op">How these Statements should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlString.</param>
            <param name="wrapStatement">Wrap each SqlStrings with "(" and ")"</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString[],System.String,System.String,System.String)">
            <summary>
            Adds existing SqlStrings to this SqlStringBuilder
            </summary>
            <param name="sqlStrings">The SqlStrings to combine.</param>
            <param name="prefix">String to put at the beginning of the combined SqlString.</param>
            <param name="op">How these SqlStrings should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlStrings.</param>
            <returns>This SqlStringBuilder</returns>
            <remarks>This calls the overloaded Add method with wrapStatement=true</remarks>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Add(NHibernate.SqlCommand.SqlString[],System.String,System.String,System.String,System.Boolean)">
            <summary>
            Adds existing SqlStrings to this SqlStringBuilder
            </summary>
            <param name="sqlStrings">The SqlStrings to combine.</param>
            <param name="prefix">String to put at the beginning of the combined SqlStrings.</param>
            <param name="op">How these SqlStrings should be junctioned "AND" or "OR"</param>
            <param name="postfix">String to put at the end of the combined SqlStrings.</param>
            <param name="wrapStatement">Wrap each SqlStrings with "(" and ")"</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Insert(System.Int32,System.String)">
            <summary>
            Insert a string containing sql into the SqlStringBuilder at the specified index.
            </summary>
            <param name="index">The zero-based index at which the sql should be inserted.</param>
            <param name="sql">The string containing sql to insert.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.Insert(System.Int32,NHibernate.SqlCommand.Parameter)">
            <summary>
            Insert a Parameter into the SqlStringBuilder at the specified index.
            </summary>
            <param name="index">The zero-based index at which the Parameter should be inserted.</param>
            <param name="param">The Parameter to insert.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.RemoveAt(System.Int32)">
            <summary>
            Removes the string or Parameter at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
            <returns>This SqlStringBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlStringBuilder.ToSqlString">
            <summary>
            Converts the mutable SqlStringBuilder into the immutable SqlString.
            </summary>
            <returns>The SqlString that was built.</returns>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlStringBuilder.Count">
            <summary>
            Gets the number of SqlParts in this SqlStringBuilder.
            </summary>
            <returns>
            The number of SqlParts in this SqlStringBuilder.
            </returns>
        </member>
        <member name="P:NHibernate.SqlCommand.SqlStringBuilder.Item(System.Int32)">
            <summary>
            Gets or Sets the element at the index
            </summary>
            <value>Returns a string or Parameter.</value>
            <remarks></remarks>
        </member>
        <member name="T:NHibernate.SqlCommand.SqlUpdateBuilder">
            <summary>
            A class that builds an <c>UPDATE</c> sql statement.
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetTableName(System.String)">
            <summary>
            
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumn(System.String,System.Object,NHibernate.Type.ILiteralType)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">The value to set for the column.</param>
            <param name="literalType">The NHibernateType to use to convert the value to a sql string.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumn(System.String,System.String)">
            <summary>
            Add a column with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The name of the Column to add.</param>
            <param name="val">A valid sql string to set as the value of the column.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],System.String)">
            <summary>
            Adds columns with a specific value to the INSERT sql
            </summary>
            <param name="columnName">The names of the Column sto add.</param>
            <param name="val">A valid sql string to set as the value of the column.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddColumns(System.String[],NHibernate.Type.IType)">
            <summary>
            Adds the Property's columns to the UPDATE sql
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="propertyType">The IType of the property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetIdentityColumn(System.String[],NHibernate.Type.IType)">
            <summary>
            Sets the IdentityColumn for the <c>UPDATE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="identityType">The IType of the Identity Property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.SetVersionColumn(System.String[],NHibernate.Type.IVersionType)">
            <summary>
            Sets the VersionColumn for the <c>UPDATE</c> sql to use.
            </summary>
            <param name="columnNames">An array of the column names for the Property</param>
            <param name="versionType">The IVersionType of the Version Property.</param>
            <returns>The SqlUpdateBuilder.</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddWhereFragment(System.String[],NHibernate.Type.IType,System.String)">
            <summary>
            Adds the columns for the Type to the WhereFragment
            </summary>
            <param name="columnNames">The names of the columns to add.</param>
            <param name="type">The IType of the property.</param>
            <param name="op">The operator to put between the column name and value.</param>
            <returns>The SqlUpdateBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.AddWhereFragment(System.String)">
            <summary>
            Adds a string to the WhereFragement
            </summary>
            <param name="whereSql">A well formed sql string with no parameters.</param>
            <returns>The SqlUpdateBuilder</returns>
        </member>
        <member name="M:NHibernate.SqlCommand.SqlUpdateBuilder.ToSqlString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlCommand.Template">
            <summary>
            Summary description for Template.
            </summary>
        </member>
        <member name="F:NHibernate.SqlCommand.Template.Placeholder">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.Template.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlCommand.Template.AddKeyword(System.String)">
            <summary>
            Add a Keyword to this Template. 
            </summary>
            <param name="keyword">The Keyword to add.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.Template.AddDelimiter(System.String)">
            <summary>
            Add a Delimeter to use when parsing the string.
            </summary>
            <param name="delimiter">The delimiter to add.</param>
        </member>
        <member name="M:NHibernate.SqlCommand.Template.RenderWhereStringTemplate(System.String,NHibernate.Dialect.Dialect)">
            <summary>
            Takes the where condition provided in the mapping attribute and iterpolates the alias.
            </summary>
            <param name="whereSql">The "where" sql statement from the mapping attribute.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with rendering the Sql.</param>
            <returns>
            A well formed "where" sql statement for the <see cref="T:NHibernate.Dialect.Dialect"/>.
            </returns>
        </member>
        <member name="M:NHibernate.SqlCommand.Template.RenderOrderByStringTemplate(System.String,NHibernate.Dialect.Dialect)">
            <summary>
            Takes "order by" clause in the mapping attribute and iterpolates the alias
            </summary>
            <param name="orderBySql">The "order by" sql statement from the mapping.</param>
            <param name="dialect">The <see cref="T:NHibernate.Dialect.Dialect"/> to help with rendering the Sql.</param>
            <returns>
            A well formed "order by" sql statement for the <see cref="T:NHibernate.Dialect.Dialect"/>.
            </returns>
        </member>
        <member name="T:NHibernate.SqlCommand.WhereBuilder">
            <summary>
            Allows us to construct SQL WHERE fragments
            </summary>
        </member>
        <member name="M:NHibernate.SqlCommand.WhereBuilder.#ctor(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="factory"></param>
        </member>
        <member name="M:NHibernate.SqlCommand.WhereBuilder.WhereClause(System.String,System.String[],NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="alias"></param>
            <param name="columnNames"></param>
            <param name="whereType"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.SqlType">
            <summary>
            This is the base class that adds information to the <see cref="P:NHibernate.SqlTypes.SqlType.DbType"/> 
            for the <see cref="T:NHibernate.Driver.IDriver"/> and <see cref="T:NHibernate.Dialect.Dialect"/>
            to use.
            </summary>
            <remarks>
            <p>
            The <see cref="T:NHibernate.Driver.IDriver"/> uses the SqlType to get enough
            information to create an <see cref="T:System.Data.IDbDataParameter"/>.  
            </p>
            <p>
            The <see cref="T:NHibernate.Dialect.Dialect"/> use the SqlType to convert the <see cref="P:NHibernate.SqlTypes.SqlType.DbType"/>
            to the appropriate sql type for SchemaExport.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlType.#ctor(System.Data.DbType)">
            <summary>
            
            </summary>
            <param name="dbType"></param>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlType.#ctor(System.Data.DbType,System.Int32)">
            <summary>
            
            </summary>
            <param name="dbType"></param>
            <param name="length"></param>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlType.#ctor(System.Data.DbType,System.Byte,System.Byte)">
            <summary>
            
            </summary>
            <param name="dbType"></param>
            <param name="precision"></param>
            <param name="scale"></param>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlType.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlType.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.SqlTypes.SqlType.DbType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlTypes.SqlType.Length">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlTypes.SqlType.Precision">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlTypes.SqlType.Scale">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlTypes.SqlType.LengthDefined">
            <summary></summary>
        </member>
        <member name="P:NHibernate.SqlTypes.SqlType.PrecisionDefined">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.AnsiStringSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.AnsiString"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.AnsiStringSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.AnsiStringSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.BinaryBlobSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Binary"/> that is stored in
            a BLOB column with the information required to generate 
            an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            <p>
            This can store the length of the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </p>
            <p>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a 
            BinarySqlType would work just fine.
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.BinarySqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Binary"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.BinarySqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinarySqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.BinarySqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinarySqlType"/> class.
            </summary>
            <param name="length">The length of the binary data the <see cref="T:System.Data.IDbDataParameter"/> should hold</param>
        </member>
        <member name="M:NHibernate.SqlTypes.BinaryBlobSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinaryBlobSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.BinaryBlobSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BinaryBlobSqlType"/> class.
            </summary>
            <param name="length">The length of the binary data the <see cref="T:System.Data.IDbDataParameter"/> should hold</param>
        </member>
        <member name="T:NHibernate.SqlTypes.BooleanSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Boolean"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Boolean"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.BooleanSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.BooleanSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.ByteSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Byte"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Byte"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.ByteSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.ByteSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.CurrencySqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Currency"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Currency"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.CurrencySqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.CurrencySqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.DateSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Date"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Date"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.DateSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.DateSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.DateTimeSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.DateTime"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.DateTime"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.DateTimeSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.DateTimeSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.DecimalSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Decimal"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the precision &amp; scale of the decimal value that the 
            <see cref="T:System.Data.IDbDataParameter"/> can hold. If no value is provided for the 
            precision &amp; scale then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.DecimalSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.DecimalSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.DecimalSqlType.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.DecimalSqlType"/> class.
            </summary>
            <param name="precision">The precision of the Decimal the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
            <param name="scale">The scale of the Decimal the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.DoubleSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Double"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Double"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.DoubleSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.DoubleSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.GuidSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Guid"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Guid"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.GuidSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.GuidSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.Int16SqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Int16"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Int16"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.Int16SqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.Int16SqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.Int32SqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Int32"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Int32"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.Int32SqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.Int32SqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.Int64SqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Int64"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Int64"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.Int64SqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.Int64SqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.SByteSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.SByte"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.SByte"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.SByteSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.SByteSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.SingleSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Single"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Single"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.SingleSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.SingleSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.SqlTypeFactory">
            <summary>
            SqlTypeFactory provides Singleton access to the SqlTypes.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetAnsiString(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetAnsiStringFixedLength(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetBinary(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetBoolean">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetByte">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetSByte">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetCurrency">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetDate">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetDateTime">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetDecimal(System.Byte,System.Byte)">
            <summary>
            
            </summary>
            <param name="precision"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetDouble">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetGuid">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetInt16">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetUInt16">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetInt32">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetUInt32">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetInt64">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetUInt64">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetSingle">
            <summary></summary>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetString(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetStringFixedLength(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.SqlTypes.SqlTypeFactory.GetTime">
            <summary></summary>
        </member>
        <member name="T:NHibernate.SqlTypes.StringClobSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.String"/> that is stored in
            a CLOB column with the information required to generate 
            an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            <p>
            This can store the length of the binary data that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </p>
            <p>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a 
            StringSqlType would work just fine.
            </p>
            </remarks>
        </member>
        <member name="T:NHibernate.SqlTypes.StringSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.String"/> with the 
            information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.StringSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="M:NHibernate.SqlTypes.StringClobSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringClobSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringClobSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringClobSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.StringFixedLengthSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.StringFixedLength"/> with the 
            information required to to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            This can store the length of the string that the <see cref="T:System.Data.IDbDataParameter"/> can hold.
            If no value is provided for the length then the <c>Driver</c> is responsible for 
            setting the properties on the <see cref="T:System.Data.IDbDataParameter"/> correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.StringFixedLengthSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringFixedLengthSqlType"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.SqlTypes.StringFixedLengthSqlType.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.StringFixedLengthSqlType"/> class.
            </summary>
            <param name="length">The length of the string the <see cref="T:System.Data.IDbDataParameter"/> should hold.</param>
        </member>
        <member name="T:NHibernate.SqlTypes.TimeSqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.Time"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.Time"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.TimeSqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.TimeSqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.UInt16SqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.UInt16"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.UInt16"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.UInt16SqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.UInt16SqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.UInt32SqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.UInt32"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.UInt32"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.UInt32SqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.UInt32SqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.SqlTypes.UInt64SqlType">
            <summary>
            Describes the details of a <see cref="F:System.Data.DbType.UInt64"/> with the 
            extra information required to generate an <see cref="T:System.Data.IDbDataParameter"/>.
            </summary>
            <remarks>
            There is not any extra information needed for a <see cref="F:System.Data.DbType.UInt64"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.SqlTypes.UInt64SqlType.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.SqlTypes.UInt64SqlType"/> class.
            </summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.AdoColumn">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoColumn.#ctor(System.Data.DataColumn)">
            <summary>
            
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoColumn.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoColumn.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoColumn.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoColumn.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoColumn.Type">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoColumn.ColumnSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoColumn.IsNullable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.AdoTable">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.AdoTable.#ctor(System.Data.DataTable)">
            <summary>
            
            </summary>
            <param name="table"></param>
        </member>
        <member name="P:NHibernate.Tool.hbm2ddl.AdoTable.Columns">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Tool.hbm2ddl.SchemaExport">
            <summary>
            Generates ddl to export table schema for a configured <c>Configuration</c> to the database
            </summary>
            <remarks>
            This Class can be used directly or the command line wrapper NHibernate.Tool.hbm2ddl.exe can be
            used when a dll can not be directly used.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.#ctor(NHibernate.Cfg.Configuration)">
            <summary>
            Create a schema exported for a given Configuration
            </summary>
            <param name="cfg">The NHibernate Configuration to generate the schema from.</param>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.#ctor(NHibernate.Cfg.Configuration,System.Collections.IDictionary)">
            <summary>
            Create a schema exporter for the given Configuration, with the given
            database connection properties
            </summary>
            <param name="cfg">The NHibernate Configuration to generate the schema from.</param>
            <param name="connectionProperties">The Properties to use when connecting to the Database.</param>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.SetOutputFile(System.String)">
            <summary>
            Set the output filename. The generated script will be written to this file
            </summary>
            <param name="filename">The name of the file to output the ddl to.</param>
            <returns>The SchemaExport object.</returns>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.SetDelimiter(System.String)">
            <summary>
            Set the end of statement delimiter 
            </summary>
            <param name="delimiter">The end of statement delimiter.</param>
            <returns>The SchemaExport object.</returns>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Create(System.Boolean,System.Boolean)">
            <summary>
            Run the schema creation script
            </summary>
            <param name="script"><c>true</c> if the ddl should be outputted in the Console.</param>
            <param name="export"><c>true</c> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> and sets
            the justDrop parameter to false and the format parameter to true.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Drop(System.Boolean,System.Boolean)">
            <summary>
            Run the drop schema script
            </summary>
            <param name="script"><c>true</c> if the ddl should be outputted in the Console.</param>
            <param name="export"><c>true</c> if the ddl should be executed against the Database.</param>
            <remarks>
            This is a convenience method that calls <see cref="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Boolean)"/> and sets
            the justDrop and format parameter to true.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Execute(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Executes the Export of the Schema.
            </summary>
            <param name="script"><c>true</c> if the ddl should be outputted in the Console.</param>
            <param name="export"><c>true</c> if the ddl should be executed against the Database.</param>
            <param name="justDrop"><c>true</c> if only the ddl to drop the Database objects should be executed.</param>
            <param name="format"><c>true</c> if the ddl should be nicely formatted instead of one statement per line.</param>
            <remarks>
            This method allows for both the drop and create ddl script to be executed.
            </remarks>
        </member>
        <member name="M:NHibernate.Tool.hbm2ddl.SchemaExport.Format(System.String)">
            <summary>
            Format an SQL statement using simple rules
            </summary>
            <param name="sql">The string containing the sql to format.</param>
            <returns>A string that contains formatted sql.</returns>
            <remarks>
            The simple rules to used when formatting are:
            <list type="number">
            	<item>
            		<description>Insert a newline after each comma</description>
            	</item>
            	<item>
            		<description>Indent three spaces after each inserted newline</description>
            	</item>
            	<item>
            		<description>
            		If the statement contains single/double quotes return unchanged because
            		it is too complex and could be broken by simple formatting.
            		</description>
            	</item>
            </list>
            </remarks>
        </member>
        <member name="T:NHibernate.Transaction.AdoTransaction">
            <summary>
            Wraps an ADO.NET <see cref="T:System.Data.IDbTransaction"/> to implement
            the <see cref="T:NHibernate.ITransaction"/> interface.
            </summary>
        </member>
        <member name="T:NHibernate.ITransaction">
            <summary>
            Allows the application to define units of work, while maintaining abstraction from the
            underlying transaction implementation
            </summary>
            <remarks>
            A transaction is associated with a <c>ISession</c> and is usually instanciated by a call to
            <c>ISession.BeginTransaction()</c>. A single session might span multiple transactions since 
            the notion of a session (a conversation between the application and the datastore) is of
            coarser granularity than the notion of a transaction. However, it is intended that there be
            at most one uncommitted <c>ITransaction</c> associated with a particular <c>ISession</c>
            at a time. Implementors are not intended to be threadsafe.
            </remarks>
        </member>
        <member name="M:NHibernate.ITransaction.Commit">
            <summary>
            Flush the associated <c>ISession</c> and end the unit of work.
            </summary>
            <remarks>
            This method will commit the underlying transaction if and only if the transaction
            was initiated by this object.
            </remarks>
        </member>
        <member name="M:NHibernate.ITransaction.Rollback">
            <summary>
            Force the underlying transaction to roll back.
            </summary>
        </member>
        <member name="M:NHibernate.ITransaction.Enlist(System.Data.IDbCommand)">
            <summary>
            Enlist the <see cref="T:System.Data.IDbCommand"/> in the current Transaction.
            </summary>
            <param name="command">The <see cref="T:System.Data.IDbCommand"/> to enlist.</param>
            <remarks>
            It is okay for this to be a no op implementation.
            </remarks>
        </member>
        <member name="P:NHibernate.ITransaction.WasRolledBack">
            <summary>
            Was the transaction rolled back or set to rollback only?
            </summary>
        </member>
        <member name="P:NHibernate.ITransaction.WasCommitted">
            <summary>
            Was the transaction successfully committed?
            </summary>
            <remarks>
            This method could return <c>false</c> even after successful invocation of <c>Commit()</c>
            </remarks>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.#ctor(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Transaction.AdoTransaction"/> class.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> the Transaction is for.</param>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Enlist(System.Data.IDbCommand)">
            <summary>
            Enlist the <see cref="T:System.Data.IDbCommand"/> in the current <see cref="T:NHibernate.ITransaction"/>.
            </summary>
            <param name="command">The <see cref="T:System.Data.IDbCommand"/> to enlist in this Transaction.</param>
            <remarks>
            <para>
            This takes care of making sure the <see cref="T:System.Data.IDbCommand"/>'s Transaction property 
            contains the correct <see cref="T:System.Data.IDbTransaction"/> or <c>null</c> if there is no
            Transaction for the ISession - ie <c>BeginTransaction()</c> not called.
            </para>
            <para>
            This method may be called even when the transaction is disposed.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Begin(System.Data.IsolationLevel)">
            <summary>
            Begins the <see cref="T:System.Data.IDbTransaction"/> on the <see cref="T:System.Data.IDbConnection"/>
            used by the <see cref="T:NHibernate.ISession"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any problems encountered while trying to create
            the <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Commit">
            <summary>
            Commits the <see cref="T:NHibernate.ITransaction"/> by flushing the <see cref="T:NHibernate.ISession"/>
            and committing the <see cref="T:System.Data.IDbTransaction"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any exception while trying to call <c>Commit()</c> on 
            the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Rollback">
            <summary>
            Rolls back the <see cref="T:NHibernate.ITransaction"/> by calling the method <c>Rollback</c> 
            on the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </summary>
            <exception cref="T:NHibernate.TransactionException">
            Thrown if there is any exception while trying to call <c>Rollback()</c> on 
            the underlying <see cref="T:System.Data.IDbTransaction"/>.
            </exception>
        </member>
        <member name="F:NHibernate.Transaction.AdoTransaction._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.AdoTransaction.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this AdoTransaction is being Disposed of or Finalized.</param>
            <remarks>
            If this AdoTransaction is being Finalized (<c>isDisposing==false</c>) then make sure not
            to call any methods that could potentially bring this AdoTransaction back to life.
            </remarks>
        </member>
        <member name="P:NHibernate.Transaction.AdoTransaction.WasRolledBack">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the transaction was rolled back.
            </summary>
            <value>
            <c>true</c> if the <see cref="T:System.Data.IDbTransaction"/> had <c>Rollback</c> called
            without any exceptions.
            </value>
        </member>
        <member name="P:NHibernate.Transaction.AdoTransaction.WasCommitted">
            <summary>
            Gets a <see cref="T:System.Boolean"/> indicating if the transaction was committed.
            </summary>
            <value>
            <c>true</c> if the <see cref="T:System.Data.IDbTransaction"/> had <c>Commit</c> called
            without any exceptions.
            </value>
        </member>
        <member name="T:NHibernate.Transaction.ITransactionFactory">
            <summary>
            An abstract factory for <c>ITransaction</c> instances. (NHibernate note: do we need this??)
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.ITransactionFactory.BeginTransaction(NHibernate.Engine.ISessionImplementor)">
            <summary>
            Begin a transaction and return the associated <c>ITransaction</c> instance
            </summary>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Transaction.ITransactionFactory.BeginTransaction(NHibernate.Engine.ISessionImplementor,System.Data.IsolationLevel)">
            <summary>
            Begin a transaction with the specified isolation level and return
            the associated <c>ITransaction</c> instance
            </summary>
            <param name="session"></param>
            <param name="isolationLevel"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Transaction.ITransactionFactory.Configure(System.Collections.IDictionary)">
            <summary>
            Configure from the given properties
            </summary>
            <param name="props"></param>
        </member>
        <member name="T:NHibernate.Transaction.TransactionFactory">
            <summary>
            Summary description for TransactionFactory.
            </summary>
        </member>
        <member name="M:NHibernate.Transaction.TransactionFactory.BeginTransaction(NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Transaction.TransactionFactory.BeginTransaction(NHibernate.Engine.ISessionImplementor,System.Data.IsolationLevel)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="isolationLevel"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Transaction.TransactionFactory.Configure(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="props"></param>
        </member>
        <member name="T:NHibernate.Transform.IResultTransformer">
            <summary>
            Implementors define a strategy for transforming criteria query
            results into the actual application-visible query result list.
            </summary>
            <remarks>see NHibernate.Criteria#setResultTransformer(ResultTransformer)</remarks>
        </member>
        <member name="M:NHibernate.Transform.IResultTransformer.TransformTuple(System.Object[],System.String[])">
            <summary>
            
            </summary>
            <param name="tuple"></param>
            <param name="aliases"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Transform.IResultTransformer.TransformList(System.Collections.IList)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Type.AbstractType">
            <summary>
            The base implementation of the <see cref="T:NHibernate.Type.IType"/> interface.
            Mapping of the built in Type hierarchy.
            </summary>
        </member>
        <member name="T:NHibernate.Type.IType">
            <summary>
			Defines a mapping from a .NET <see cref="T:System.Type"/> to a SQL datatype.
			This interface is intended to be implemented by applications that need custom types.
		</summary><remarks>
			Implementors should usually be immutable and MUST definately be threadsafe.
		</remarks>
        </member>
        <member name="M:NHibernate.Type.IType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="T:NHibernate.SqlTypes.SqlType"/>s.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns how many columns are used to persist this type.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>The number of columns this IType spans.</returns><exception cref="T:NHibernate.MappingException">MappingException</exception> 
        </member>
        <member name="M:NHibernate.Type.IType.Equals(System.Object,System.Object)">
            <summary>
		When implemented by a class, compare two instances of the class mapped by this 
		IType for persistence "equality" - ie. Equality of persistent state.
		</summary><param name="x">The left hand side object.</param><param name="y">The right hand side object.</param><returns>True if the two objects contain the same values.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, should the parent be considered dirty, 
		given both the old and current field or element value?
		</summary><param name="old">The old value</param><param name="current">The current value</param><param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> </param><returns>true if the field is dirty</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.IsModified(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.IsModified&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object mapped by 
		this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementors should handle possibility of null values.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object 
		mapped by this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="name">The name of the column in the <see cref="T:System.Data.IDataReader"/> that contains the 
		value to populate the IType with.</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementations should handle possibility of null values.
		This method might be called if the IType is known to be a single-column type.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param><param name="value">The object that contains the values.</param><param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param><param name="session"></param><remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <c>Index</c>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.ToString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.FromString(System.String)">
            <summary>
		Parse the XML representation of an instance
		</summary><param name="xml"></param><returns>an instance of the type</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.DeepCopy(System.Object)">
            <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary><param name="val">A Collection element or Entity field</param><returns>A deep copy of the object.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, disassembles the object into a cacheable representation.
		</summary><param name="value">The value to disassemble.</param><param name="session">The sesion</param><returns>The disassembled, deep cloned state of the object</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, reconstructs the object from its 
		cached "disassembled" state.
		</summary><param name="cached">The disassembled state from the cache</param><param name="session">The session</param><param name="owner">tThe parent Entity object</param><returns>The assembled object.</returns> 
        </member>
        <member name="M:NHibernate.Type.IType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, retrives an instance of the mapped class, 
		or the identifier of an entity or collection from a <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values.</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session">the session</param><param name="owner">The parent Entity</param><returns>An identifier or actual object mapped by this IType.</returns><remarks>
		<para>
		This is useful for 2-phase property initialization - the second phase is a call to
		<c>ResolveIdentifier()</c>
		</para>
		<para>
		Most implementors of this method will just pass the call to <c>NullSafeGet()</c>.
		</para>
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, maps identifiers to Entities or Collections. 
		</summary><param name="value">An identifier or value returned by <c>Hydrate()</c></param><param name="session">The session</param><param name="owner">The parent Entity</param><returns>The Entity or Collection referenced by this Identifier.</returns><remarks>
		This is the second phase of 2-phase property initialization.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.IType.Copy(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.Copy&quot;]/*"/> 
        </member>
        <member name="P:NHibernate.Type.IType.IsAssociationType">
            <summary>
			When implemented by a class, gets a value indicating if the implementor is castable to an an <see cref="T:NHibernate.Type.IAssociationType"/>
		</summary><value>true if this is an Association</value><remarks>This does not necessarily imply that the type actually represents an association.</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.IsPersistentCollectionType">
            <summary>
			When implemented by a class, gets a value indicating if the implementor is a collection type
		</summary><value>true if this is a <see cref="T:NHibernate.Type.PersistentCollectionType"/>.</value> 
        </member>
        <member name="P:NHibernate.Type.IType.IsComponentType">
            <summary>
		When implemented by a class, gets a value indicating if the implementor 
		is an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
		</summary><value>true if this is an <see cref="T:NHibernate.Type.IAbstractComponentType"/></value><remarks>
		If true, the implementation must be castable to <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
		A component type may own collections or associations and hence must provide certain extra functionality.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.IsEntityType">
            <summary>
		When implemented by a class, gets a value indicating if the implementor 
		extends <see cref="T:NHibernate.Type.EntityType"/>
		</summary><value>true if this is an <see cref="T:NHibernate.Type.EntityType"/></value> 
        </member>
        <member name="P:NHibernate.Type.IType.IsObjectType">
            <summary>
		When implemented by a class, gets a value indicating if the implementation is an "object" type
		</summary><value>true if this an "object" type</value><remarks>
		This is a reference to a persistent entity that is not modelled as a (foreign key) association.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.ReturnedClass">
            <summary>
		When implemented by a class, gets the <see cref="T:System.Type"/> returned 
		by the <c>NullSafeGet()</c> methods.
		</summary><value>
		The <see cref="T:System.Type"/> from the .NET framework.
		</value><remarks>
		This is used to establish the class of an array of this Itype
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.Name">
            <summary>
		When implemented by a class, gets the abbreviated name of the type.
		</summary><value>The NHibernate type name.</value> 
        </member>
        <member name="P:NHibernate.Type.IType.IsMutable">
            <summary>
		When implemented by a class, gets the value indicating if the objects 
		of this IType are mutable.
		</summary><value>true if the objects mapped by this IType are mutable.</value><remarks>
		With respect to the referencing object...
		Entities and Collections are considered immutable because they manage their own internal state.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.IType.HasNiceEquals">
            <summary>
		When implemented by a class, gets whether or not this IType contains 
		<see cref="T:System.Type"/>s that implement well-behaived <c>Equals()</c> method.
		</summary><value>true if a well-behaived <c>Equals()</c> is implemented.</value><remarks>
		<para>
		Strickly, if this method returns <c>true</c> then <c>x.Equals(y)</c> implies
		<c>IType.Equals(x, y)</c> and also <c>IType.Equals(x, y)</c> implies that
		probably <c>x.Equals(y)</c>
		</para>
		<para>
		In the default implementations <see cref="T:NHibernate.Type.ImmutableType"/>s are assumed to have
		HaveNiceEquals==true and <see cref="T:NHibernate.Type.MutableType"/>s are assumed to have 
		HaveNiceEquals==false.
		</para>
		<para>
		This code doesn't look like it is used anywhere internally because I did a search
		on ".HasNiceEquals" and found no results.  So it looks like it is used for a description
		of the IType only.
		</para>
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Disassembles the object into a cacheable representation.
            </summary>
            <param name="value">The value to disassemble.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <returns>The disassembled, deep cloned state of the object</returns>
            <remarks>
            This method calls DeepCopy if the value is not null.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Reconstructs the object from its cached "disassembled" state.
            </summary>
            <param name="cached">The disassembled state from the cache</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <param name="owner">The parent Entity object is not used by this method</param>
            <returns>The assembled object.</returns>
            <remarks>
            This method calls DeepCopy if the value is not null.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Should the parent be considered dirty, given both the old and current 
            field or element value?
            </summary>
            <param name="old">The old value</param>
            <param name="current">The current value</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <returns>true if the field is dirty</returns>
            <remarks>This method uses <c>IType.Equals(object, object)</c> to determine the value of IsDirty.</remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Retrives an instance of the mapped class, or the identifier of an entity 
            or collection from a <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values.</param>
            <param name="names">
            The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
            value to populate the IType with.
            </param>
            <param name="session">the session</param>
            <param name="owner">The parent Entity</param>
            <returns>An identifier or actual object mapped by this IType.</returns>
            <remarks>
            This method uses the <c>IType.NullSafeGet(IDataReader, string[], ISessionImplementor, object)</c> method
            to Hydrate this <see cref="T:NHibernate.Type.AbstractType"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Maps identifiers to Entities or Collections. 
            </summary>
            <param name="value">An identifier or value returned by <c>Hydrate()</c></param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> is not used by this method.</param>
            <param name="owner">The parent Entity is not used by this method.</param>
            <returns>The value.</returns>
            <remarks>
            There is nothing done in this method other than return the value parameter passed in.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.AbstractType.IsModified(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Says whether the value has been modified
            </summary>
            <param name="old"></param>
            <param name="current"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AbstractType.Copy(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="original"></param>
            <param name="current"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <param name="copiedAlready"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AbstractType.DeepCopy(System.Object)">
            <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary><param name="val">A Collection element or Entity field</param><returns>A deep copy of the object.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="T:NHibernate.SqlTypes.SqlType"/>s.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns how many columns are used to persist this type.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>The number of columns this IType spans.</returns><exception cref="T:NHibernate.MappingException">MappingException</exception> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.Equals(System.Object,System.Object)">
            <summary>
		When implemented by a class, compare two instances of the class mapped by this 
		IType for persistence "equality" - ie. Equality of persistent state.
		</summary><param name="x">The left hand side object.</param><param name="y">The right hand side object.</param><returns>True if the two objects contain the same values.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.NullSafeGet(IDataReader, string[], ISessionImplementor, object)&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <!-- No matching elements were found for the following include tag --><include file="IType.cs.xmldoc" path="//members[@type=&quot;IType&quot;]/member[@name=&quot;M:IType.NullSafeGet(IDataReader, string, ISessionImplementor, object)&quot;]/*"/> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param><param name="value">The object that contains the values.</param><param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param><param name="session"></param><remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <c>Index</c>.
		</remarks> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.ToString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
        </member>
        <member name="M:NHibernate.Type.AbstractType.FromString(System.String)">
            <summary>
		Parse the XML representation of an instance
		</summary><param name="xml"></param><returns>an instance of the type</returns> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsAssociationType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is an <see cref="T:NHibernate.Type.IAssociationType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not an <see cref="T:NHibernate.Type.IAssociationType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsPersistentCollectionType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is a <see cref="T:NHibernate.Type.PersistentCollectionType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a <see cref="T:NHibernate.Type.PersistentCollectionType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsComponentType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not an <see cref="T:NHibernate.Type.IAbstractComponentType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsEntityType">
            <summary>
            Gets a value indicating if the <see cref="T:NHibernate.Type.AbstractType"/> is a <see cref="T:NHibernate.Type.EntityType"/>.
            </summary>
            <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a <see cref="T:NHibernate.Type.EntityType"/>.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsObjectType">
             <summary>
            Gets a value indicating if the implementation is an "object" type
             </summary>
             <value>false - by default an <see cref="T:NHibernate.Type.AbstractType"/> is not a "object" type.</value>
        </member>
        <member name="P:NHibernate.Type.AbstractType.IsMutable">
            <summary>
		When implemented by a class, gets the value indicating if the objects 
		of this IType are mutable.
		</summary><value>true if the objects mapped by this IType are mutable.</value><remarks>
		With respect to the referencing object...
		Entities and Collections are considered immutable because they manage their own internal state.
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.Name">
            <summary>
		When implemented by a class, gets the abbreviated name of the type.
		</summary><value>The NHibernate type name.</value> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.HasNiceEquals">
            <summary>
		When implemented by a class, gets whether or not this IType contains 
		<see cref="T:System.Type"/>s that implement well-behaived <c>Equals()</c> method.
		</summary><value>true if a well-behaived <c>Equals()</c> is implemented.</value><remarks>
		<para>
		Strickly, if this method returns <c>true</c> then <c>x.Equals(y)</c> implies
		<c>IType.Equals(x, y)</c> and also <c>IType.Equals(x, y)</c> implies that
		probably <c>x.Equals(y)</c>
		</para>
		<para>
		In the default implementations <see cref="T:NHibernate.Type.ImmutableType"/>s are assumed to have
		HaveNiceEquals==true and <see cref="T:NHibernate.Type.MutableType"/>s are assumed to have 
		HaveNiceEquals==false.
		</para>
		<para>
		This code doesn't look like it is used anywhere internally because I did a search
		on ".HasNiceEquals" and found no results.  So it looks like it is used for a description
		of the IType only.
		</para>
		</remarks> 
        </member>
        <member name="P:NHibernate.Type.AbstractType.ReturnedClass">
            <summary>
		When implemented by a class, gets the <see cref="T:System.Type"/> returned 
		by the <c>NullSafeGet()</c> methods.
		</summary><value>
		The <see cref="T:System.Type"/> from the .NET framework.
		</value><remarks>
		This is used to establish the class of an array of this Itype
		</remarks> 
        </member>
        <member name="T:NHibernate.Type.AnsiCharType">
            <summary>
            Maps a <see cref="T:System.Char"/> Property 
            to a <c>DbType.AnsiStringFixedLength</c> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.BaseCharType">
            <summary>
            Common base class for <see cref="T:NHibernate.Type.CharType"/> and <see cref="T:NHibernate.Type.AnsiCharType"/>.
            </summary>
        </member>
        <member name="T:NHibernate.Type.ValueTypeType">
            <summary>
            Superclass of <see cref="T:System.ValueType"/> types.
            </summary>
        </member>
        <member name="T:NHibernate.Type.ImmutableType">
            <summary>
            Superclass of nullable immutable types.
            </summary>
        </member>
        <member name="T:NHibernate.Type.NullableType">
            <summary>
            Superclass of single-column nullable types.
            </summary>
            <remarks>
            Maps the Property to a single column that is capable of storing nulls in it. If a .net Struct is
            used it will be created with its unitialized value and then on Update the uninitialized value of
            the Struct will be written to the column - not <c>null</c>. 
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the NullableType class using a 
            <see cref="P:NHibernate.Type.NullableType.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/>.</param>
            <remarks>This is used when the Property is mapped to a single column.</remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            When implemented by a class, put the value from the mapped 
            Property into to the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the value into.</param>
            <param name="value">The object that contains the value.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param>
            <remarks>
            Implementors do not need to handle possibility of null values because this will
            only be called from <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/> after 
            it has checked for nulls.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            When implemented by a class, gets the object in the 
            <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="index">The index of the field to get the value from.</param>
            <returns>An object with the value from the database.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.String)">
            <summary>
            When implemented by a class, gets the object in the 
            <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>An object with the value from the database.</returns>
            <remarks>
            Most implementors just call the <see cref="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)"/> 
            overload of this method.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="val">The object that contains the values.
            </param>
            <returns>An Xml formatted string.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.ToString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
		When implemented by a class, a representation of the value to be 
		embedded in an XML element
		</summary><param name="value">The object that contains the values.</param><param name="factory"></param><returns>An Xml formatted string.</returns> 
            <remarks>
            <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.ToString(System.Object)"/> if the parameter 
            value is not null.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.ToString(System.Object)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.FromStringValue(System.String)">
            <summary>
            Parse the XML representation of an instance
            </summary>
            <param name="xml">XML string to parse, guaranteed to be non-empty</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.FromString(System.String)">
            <summary>
		Parse the XML representation of an instance
		</summary><param name="xml"></param><returns>an instance of the type</returns> 
            <remarks>
            <para>
            This implementation forwards the call to <see cref="M:NHibernate.Type.NullableType.FromStringValue(System.String)"/> if the parameter
            value is not empty.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.FromStringValue(System.String)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
		When implemented by a class, puts the value/values from the mapped 
		class into the <see cref="T:System.Data.IDbCommand"/>.
		</summary><param name="st">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param><param name="value">The object that contains the values.</param><param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the values to.</param><param name="session"></param><remarks>
		Implementors should handle possibility of null values.
		A multi-column type should be written to parameters starting from <c>Index</c>.
		</remarks> 
            <remarks>
            <para>
            This implemenation forwards the call to <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Puts the value from the mapped class into the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the values into.</param>
            <param name="value">The object that contains the values.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to write the value to.</param>
            <remarks>
            <para>
            This method checks to see if value is null, if it is then the value of 
            <see cref="T:System.DBNull"/> is written to the <see cref="T:System.Data.IDbCommand"/>.
            </para>
            <para>
            If the value is not null, then the method <see cref="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)"/> 
            is called and that method is responsible for setting the value.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object mapped by 
		this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="names">
		The names of the columns in the <see cref="T:System.Data.IDataReader"/> that contain the 
		value to populate the IType with.
		</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementors should handle possibility of null values.
		</remarks> 
            <remarks>
            This has been sealed because no other class should override it.  This 
            method calss <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/> for a single value.  
            It only takes the first name from the string[] names parameter - that is a 
            safe thing to do because a Nullable Type only has one field.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String[])">
            <summary>
            Extracts the values of the fields from the DataReader
            </summary>
            <param name="rs">The DataReader positioned on the correct record</param>
            <param name="names">An array of field names.</param>
            <returns>The value off the field from the DataReader</returns>
            <remarks>
            In this class this just ends up passing the first name to the NullSafeGet method
            that takes a string, not a string[].
            
            I don't know why this method is in here - it doesn't look like anybody that inherits
            from NullableType overrides this...
            
            TODO: determine if this is needed
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)">
            <summary>
            Gets the value of the field from the <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> positioned on the correct record.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>The value of the field.</returns>
            <remarks>
            <para>
            This method checks to see if value is null, if it is then the null is returned
            from this method.
            </para>
            <para>
            If the value is not null, then the method <see cref="M:NHibernate.Type.NullableType.Get(System.Data.IDataReader,System.Int32)"/> 
            is called and that method is responsible for retreiving the value.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
		When implemented by a class, gets an instance of the object 
		mapped by this IType from the <see cref="T:System.Data.IDataReader"/>.
		</summary><param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the values</param><param name="name">The name of the column in the <see cref="T:System.Data.IDataReader"/> that contains the 
		value to populate the IType with.</param><param name="session"></param><param name="owner"></param><returns>The object mapped by this IType.</returns><remarks>
		Implementations should handle possibility of null values.
		This method might be called if the IType is known to be a single-column type.
		</remarks> 
            <remarks>
            <para>
            This implemenation forwards the call to <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.NullSafeGet(System.Data.IDataReader,System.String)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
		When implemented by a class, returns the SqlTypes for the columns mapped by this IType.
		</summary><param name="mapping">The <see cref="T:NHibernate.Engine.IMapping"/> that uses this IType.</param><returns>An array of <see cref="P:NHibernate.Type.NullableType.SqlType"/>s.</returns> 
            <remarks>
            <para>
            This implemenation forwards the call to <see cref="P:NHibernate.Type.NullableType.SqlType"/>.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need to and should not override this method because they map to a single
            column.  All of their implementation should be in <see cref="P:NHibernate.Type.NullableType.SqlType"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            Returns the number of columns spanned by this <see cref="T:NHibernate.Type.NullableType"/>
            </summary>
            <returns>A <see cref="T:NHibernate.Type.NullableType"/> always returns 1.</returns>
            <remarks>
            This has the hard coding of 1 in there because, by definition of this class, 
            a NullableType can only map to one column in a table.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.DeepCopyNotNull(System.Object)">
            <summary>
            When implemented by a class, returns a deep copy of the persistent state.
            </summary>
            <param name="val">The value to deep copy.</param>
            <returns>A deep copy of the object.</returns>
            <remarks>
            Most of the built in NullableTypes will just return the same object
            passed into it.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.DeepCopy(System.Object)">
            <summary>
		When implemented by a class, returns a deep copy of the persistent 
		state, stopping at entities and at collections.
		</summary><param name="val">A Collection element or Entity field</param><returns>A deep copy of the object.</returns> 
            <remarks>
            <para>
            This implemenation forwards the call to <see cref="M:NHibernate.Type.NullableType.DeepCopyNotNull(System.Object)"/> if the parameter 
            value is not null.
            </para>
            <para>
            It has been "sealed" because the Types inheriting from <see cref="T:NHibernate.Type.NullableType"/>
            do not need and should not override this method.  All of their implementation
            should be in <see cref="M:NHibernate.Type.NullableType.DeepCopyNotNull(System.Object)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.NullableType.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this
            <see cref="T:NHibernate.Type.NullableType"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this NullableType.</param>
            <returns>true if the SqlType and Name properties are the same.</returns>
        </member>
        <member name="M:NHibernate.Type.NullableType.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:NHibernate.Type.NullableType"/>, 
            suitable for use in hashing algorithms and data structures like a hash table.
            </summary>
            <returns>
            A hash code that is based on the <see cref="P:NHibernate.Type.NullableType.SqlType"/>'s 
            hash code and the <see cref="P:NHibernate.Type.AbstractType.Name"/>'s hash code.</returns>
        </member>
        <member name="P:NHibernate.Type.NullableType.SqlType">
            <summary>
            Gets the underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/> for 
            the column mapped by this <see cref="T:NHibernate.Type.NullableType"/>.
            </summary>
            <value>The underlying <see cref="P:NHibernate.Type.NullableType.SqlType"/>.</value>
            <remarks>
            This implementation should be suitable for all subclasses unless they need to
            do some special things to get the value.  There are no built in <see cref="T:NHibernate.Type.NullableType"/>s
            that override this Property.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ImmutableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the ImmutableType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="M:NHibernate.Type.ImmutableType.DeepCopyNotNull(System.Object)">
            <summary>
            Returns a deep copy of the persistent state.
            </summary>
            <param name="val">The value to deep copy.</param>
            <returns>A deep copy of the object.</returns>
            <remarks>
            A <see cref="T:System.ValueType"/> is considered immutable because a boxed version
            of the <see cref="T:System.ValueType"/> is being stored by NHibernate.  So any changes
            made to it would require the <see cref="T:System.ValueType"/> to be unboxed and
            then reboxed.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.ImmutableType.IsMutable">
            <summary>
            Gets the value indicating if this IType is mutable.
            </summary>
            <value>false - an <see cref="T:NHibernate.Type.ImmutableType"/> is not mutable.</value>
            <remarks>
            This has been "sealed" because any subclasses are expected to be immutable.  If
            the type is mutable then they should inherit from <see cref="T:NHibernate.Type.MutableType"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.ImmutableType.HasNiceEquals">
            <summary>
            Gets whether or not this IType contains 
            <see cref="T:System.Type"/>s that implement well-behaived <c>Equals()</c> method.
            </summary>
            <value>
            true - it is assumed that a ImmutableType implements a 
            well-behaived <c>Equals()</c>.
            </value>
            <remarks>
            There is no concrete rule that <see cref="T:NHibernate.Type.ImmutableType"/>s implement
            a well-behaived <c>Equals()</c>.  If the <see cref="T:NHibernate.Type.ImmutableType"/> does 
            not implement the <c>Equals()</c> then set this to <c>false</c>.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.ILiteralType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may appear as an SQL literal
            </summary>
        </member>
        <member name="M:NHibernate.Type.ILiteralType.ObjectToSQLString(System.Object)">
            <summary>
            When implemented by a class, return a <see cref="T:System.String"/> representation 
            of the value, suitable for embedding in an SQL statement
            </summary>
            <param name="value">The object to convert to a string for the SQL statement.</param>
            <returns>A string that containts a well formed SQL Statement.</returns>
        </member>
        <member name="M:NHibernate.Type.ValueTypeType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the ValueTypeType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="M:NHibernate.Type.ValueTypeType.Equals(System.Object,System.Object)">
            <summary>
            Compare two instances of the class mapped by this 
            IType for persistence "equality" - ie. Equality of persistent state.
            </summary>
            <param name="x">The left hand side object.</param>
            <param name="y">The right hand side object.</param>
            <returns>True if the two objects contain the same values.</returns>
        </member>
        <member name="M:NHibernate.Type.ValueTypeType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="val">The object that contains the values.
            </param>
            <returns>An Xml formatted string.</returns>
            <remarks>
            This just calls <see cref="M:System.Object.ToString"/> so if there is 
            a possibility of this PrimitiveType having any characters
            that need to be encoded then this method should be overridden.
            
            TODO: figure out if this is used to build Xml strings or will have encoding
            done automattically.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ValueTypeType.ObjectToSQLString(System.Object)">
            <summary>
            When implemented by a class, return a <see cref="T:System.String"/> representation 
            of the value, suitable for embedding in an SQL statement
            </summary>
            <param name="val">The object to convert to a string for the SQL statement.</param>
            <returns>A string that containts a well formed SQL Statement.</returns>
        </member>
        <member name="T:NHibernate.Type.IDiscriminatorType">
            <summary>
            An IType that may be used for a discriminator column.
            </summary>
            <remarks>
            This interface contains no new methods but does require that an
            <see cref="T:NHibernate.Type.IType"/> that will be used in a discriminator column must implement
            both the <see cref="T:NHibernate.Type.IIdentifierType"/> and <see cref="T:NHibernate.Type.ILiteralType"/> interfaces.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.IIdentifierType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may be used as an identifier.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IIdentifierType.StringToObject(System.String)">
            <summary>
            When implemented by a class, converts the xml string from the 
            mapping file to the .NET object.
            </summary>
            <param name="xml">The value of <c>discriminator-value</c> or <c>unsaved-value</c> attribute.</param>
            <returns>The string converted to the object.</returns>
            <remarks>
            This method needs to be able to handle any string.  It should not just 
            call System.Type.Parse without verifying that it is a parsable value
            for the System.Type.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.AnsiStringType">
            <summary>
            Maps a <see cref="T:System.String"/> Property 
            to a <see cref="F:System.Data.DbType.AnsiString"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.#ctor(NHibernate.SqlTypes.AnsiStringSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.AnsiStringType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.AnsiStringType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.AnsiStringType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.ArrayType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.PersistentCollectionType">
            <summary>
            PersistentCollectionType.
            </summary>
        </member>
        <member name="T:NHibernate.Type.IAssociationType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that represents some kind of association between entities.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetJoinable(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Get the "persister" for this association - a class or collection persister
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetReferencedColumns(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            Get the columns referenced by this association.
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAssociationType.GetAssociatedClass(NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.ForeignKeyType">
            <summary>
            When implemented by a class, gets the type of foreign key directionality 
            of this association.
            </summary>
            <value>The <see cref="P:NHibernate.Type.IAssociationType.ForeignKeyType"/> of this association.</value>
        </member>
        <member name="P:NHibernate.Type.IAssociationType.UsePrimaryKeyAsForeignKey">
            <summary>
            Is the foreign key the primary key of the table?
            </summary>
        </member>
        <member name="M:NHibernate.Type.PersistentCollectionType.GetElementsCollection(System.Object)">
            <summary>
            Returns a reference to the elements in the collection.  
            </summary>
            <param name="collection">The object that holds the ICollection.</param>
            <returns>An ICollection of the Elements(classes) in the Collection.</returns>
            <remarks>
            By default the parameter <c>collection</c> is just cast to an ICollection.  Collections
            such as Maps and Sets should override this so that the Elements are returned - not a
            DictionaryEntry.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.PersistentCollectionType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps a collection from System.Collections or Iesi.Collections inside one of the 
            NHibernate collections.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped collection.</param>
            <returns>
            A subclass of <see cref="T:NHibernate.Collection.PersistentCollection"/> that wraps the non NHibernate collection.
            </returns>
        </member>
        <member name="M:NHibernate.Type.ArrayType.#ctor(System.String,System.Type)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <param name="elementClass"></param>
        </member>
        <member name="M:NHibernate.Type.ArrayType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ArrayType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.ArrayType.GetElementsCollection(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ArrayType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ArrayType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps a <see cref="T:System.Array"/> in a <see cref="T:NHibernate.Collection.ArrayHolder"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="array">The unwrapped array.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.ArrayHolder"/> that wraps the non NHibernate <see cref="T:System.Array"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Type.ArrayType.Copy(System.Object,System.Object,NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="original"></param>
            <param name="target"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <param name="copiedAlready"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.ArrayType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ArrayType.IsArrayType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BagType">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.BagType.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
        </member>
        <member name="M:NHibernate.Type.BagType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BagType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.IList"/> in a <see cref="T:NHibernate.Collection.Bag"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.IList"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Bag"/> that wraps the non NHibernate <see cref="T:System.Collections.IList"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.BagType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BinaryBlobType">
            <summary>
            Maps a System.Byte[] Property to an column that can store a BLOB.
            </summary>
            <remarks>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a BinaryType
            would work just fine.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.BinaryType">
            <summary>
            BinaryType.
            </summary>
        </member>
        <member name="T:NHibernate.Type.MutableType">
            <summary>
            Superclass for mutable nullable types.
            </summary>
        </member>
        <member name="M:NHibernate.Type.MutableType.#ctor(NHibernate.SqlTypes.SqlType)">
            <summary>
            Initialize a new instance of the MutableType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="P:NHibernate.Type.MutableType.IsMutable">
            <summary>
            Gets the value indicating if this IType is mutable.
            </summary>
            <value>true - a <see cref="T:NHibernate.Type.MutableType"/> is mutable.</value>
            <remarks>
            This has been "sealed" because any subclasses are expected to be mutable.  If
            the type is immutable then they should inherit from <see cref="T:NHibernate.Type.ImmutableType"/>.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.MutableType.HasNiceEquals">
            <summary>
            Gets whether or not this IType contains 
            <see cref="T:System.Type"/>s that implement well-behaived <c>Equals()</c> method.
            </summary>
            <value>
            false - it is assumed that a MutableType does not implement a 
            well-behaved <c>Equals()</c>.
            </value>
            <remarks>
            There is no concrete rule that <see cref="T:NHibernate.Type.MutableType"/>s don't implement
            a well-behaved <c>Equals()</c>.  If the <see cref="T:NHibernate.Type.MutableType"/> does implement
            the <c>Equals()</c> then set this to <c>true</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.BinaryType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.BinaryType.#ctor(NHibernate.SqlTypes.BinarySqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.BinaryType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.BinaryType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BinaryType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BinaryType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BinaryType.DeepCopyNotNull(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.BinaryType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.BinaryType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.BinaryBlobType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.BinaryBlobType.#ctor(NHibernate.SqlTypes.BinarySqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="P:NHibernate.Type.BinaryBlobType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BlobType">
            <summary>
            Summary description for BlobType.
            </summary>
        </member>
        <member name="M:NHibernate.Type.BlobType.#ctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.BooleanType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> Property 
            to a <see cref="F:System.Data.DbType.Boolean"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.BooleanType.#ctor">
            <summary>
            Initialize a new instance of the BooleanType
            </summary>
            <remarks>This is used when the Property is mapped to a native boolean type.</remarks>
        </member>
        <member name="M:NHibernate.Type.BooleanType.#ctor(NHibernate.SqlTypes.AnsiStringFixedLengthSqlType)">
            <summary>
            Initialize a new instance of the BooleanType class using a
            <see cref="T:NHibernate.SqlTypes.AnsiStringFixedLengthSqlType"/>.
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
            <remarks>
            This is used when the Property is mapped to a string column
            that stores true or false as a string.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.ByteType">
            <summary>
            Maps a <see cref="T:System.Byte"/> Property 
            to a <see cref="F:System.Data.DbType.Byte"/> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.IVersionType">
            <summary>
            An <see cref="T:NHibernate.Type.IType"/> that may be used to version data.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IVersionType.Next(System.Object)">
            <summary>
            When implemented by a class, increments the version.
            </summary>
            <param name="current">The current version</param>
            <returns>an instance of the <see cref="T:NHibernate.Type.IType"/> that has been incremented.</returns>
        </member>
        <member name="M:NHibernate.Type.IVersionType.StringToObject(System.String)">
            <summary>
            When implemented by a class, converts the xml string from the 
            mapping file to the .NET object.
            </summary>
            <param name="xml">The value of <c>discriminator-value</c> or <c>unsaved-value</c> attribute.</param>
            <returns>The string converted to the object.</returns>
            <remarks>
            This method needs to be able to handle any string.  It should not just 
            call System.Type.Parse without verifying that it is a parsable value
            for the System.Type.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.IVersionType.Seed">
            <summary>
            When implemented by a class, gets an initial version.
            </summary>
            <value>Returns an instance of the <see cref="T:NHibernate.Type.IType"/></value>
        </member>
        <member name="P:NHibernate.Type.IVersionType.Comparator">
            <summary>
            Get a comparator for the version numbers
            </summary>
        </member>
        <member name="M:NHibernate.Type.ByteType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.ByteType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ByteType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ByteType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.ByteType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ByteType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.ByteType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ByteType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CharBooleanType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> Property 
            to a <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.#ctor(NHibernate.SqlTypes.AnsiStringFixedLengthSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CharBooleanType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CharBooleanType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CharBooleanType.FalseString">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CharType">
            <summary>
            Maps a <see cref="T:System.Char"/> Property 
            to a <c>DbType.StringFixedLength</c> column.
            </summary>
        </member>
        <member name="T:NHibernate.Type.ClobType">
            <summary>
            Summary description for ClobType.
            </summary>
        </member>
        <member name="M:NHibernate.Type.ClobType.#ctor">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.ComponentType">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.IAbstractComponentType">
            <summary>
            Enables other Component-like types to hold collections and have cascades, etc.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValues(System.Object)">
            <summary>
            Optional Operation
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            Optional operation
            </summary>
            <param name="component"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.GetPropertyValue(System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="i"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.Cascade(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IAbstractComponentType.EnableJoinedFetch(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.IAbstractComponentType.Subtypes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.IAbstractComponentType.PropertyNames">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.ComponentType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.#ctor(System.Type,System.String[],NHibernate.Property.IGetter[],NHibernate.Property.ISetter[],System.Boolean,NHibernate.Type.IType[],NHibernate.Loader.OuterJoinFetchStrategy[],NHibernate.Engine.Cascades.CascadeStyle[],System.String)">
            <summary>
            
            </summary>
            <param name="componentClass"></param>
            <param name="propertyNames"></param>
            <param name="propertyGetters"></param>
            <param name="propertySetters"></param>
            <param name="foundCustomAcessor"></param>
            <param name="propertyTypes"></param>
            <param name="joinedFetch"></param>
            <param name="cascade"></param>
            <param name="parentProperty"></param>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.IsDirty(System.Object,System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="names"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="begin"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.ComponentType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetPropertyValue(System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="i"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.GetPropertyValues(System.Object)">
            <summary>
            
            </summary>
            <remarks>
            Use the IGetSetHelper if available
            </remarks>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            
            </summary>
            <remarks>
            Use the IGetSetHelper if available
            </remarks>
            <param name="component"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Type.ComponentType.ToString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.FromString(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.DeepCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Instantiate">
            <remarks>
            This method does not populate the component parent
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Cascade(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.EnableJoinedFetch(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ComponentType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="names"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsPersistentCollectionType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsComponentType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsEntityType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.Subtypes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.PropertyNames">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.IsMutable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.ComponentType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CompositeCustomType">
            <summary>
            Summary description for CompositeCustomType.
            </summary>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="userTypeClass"></param>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.GetPropertyValues(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.SetPropertyValues(System.Object,System.Object[])">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="values"></param>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.GetPropertyValue(System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="component"></param>
            <param name="i"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.Cascade(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.EnableJoinedFetch(System.Int32)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="cached"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.DeepCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="names"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.ToString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CompositeCustomType.FromString(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.Subtypes">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.PropertyNames">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.IsComponentType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CompositeCustomType.IsMutable">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CultureInfoType">
            <summary>
            Maps a <see cref="T:System.Globalization.CultureInfo"/> Property 
            to a <see cref="F:System.Data.DbType.String"/> column.
            </summary>
            <remarks>
            CultureInfoType stores the culture name (not the Culture ID) of the 
            <see cref="T:System.Globalization.CultureInfo"/> in the DB.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CultureInfoType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CultureInfoType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CultureInfoType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.CustomType">
            <summary>
            Adapts IUserType to the generic IType interface.
            <seealso cref="T:NHibernate.IUserType"/>
            </summary>
        </member>
        <member name="M:NHibernate.Type.CustomType.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="userTypeClass"></param>
        </member>
        <member name="M:NHibernate.Type.CustomType.SqlTypes(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="mapping"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="names"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.NullSafeGet(System.Data.IDataReader,System.String,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.CustomType.ToString(System.Object,NHibernate.Engine.ISessionFactoryImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="factory"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.FromString(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.CustomType.DeepCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.CustomType.UserType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.IsMutable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.CustomType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DateTimeType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to a <see cref="F:System.Data.DbType.DateTime"/> column that 
            stores date &amp; time down to the accuracy of a second.
            </summary>
            <remarks>
            This only stores down to a second, so if you are looking for the most accurate
            date and time storage your provider can give you use the <see cref="T:NHibernate.Type.TimestampType"/>. 
            or the <see cref="T:NHibernate.Type.TicksType"/>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateTimeType.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.DateTimeType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateTimeType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateTimeType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateTimeType.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DateType">
            <summary>
            Maps the Year, Month, and Day of a <see cref="T:System.DateTime"/> Property to a 
            <see cref="F:System.Data.DbType.Date"/> column
            </summary>
        </member>
        <member name="M:NHibernate.Type.DateType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.DateType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.DateType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DateType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.DateType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DateType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DecimalType">
            <summary>
            Maps a <see cref="T:System.Decimal"/> Property 
            to a <see cref="F:System.Data.DbType.Decimal"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.DecimalType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.DecimalType.#ctor(NHibernate.SqlTypes.DecimalSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.DecimalType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DecimalType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DecimalType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.DecimalType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DecimalType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DecimalType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.DecimalType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DecimalType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DoubleType">
            <summary>
            Maps a <see cref="T:System.Double"/> Property 
            to a <see cref="F:System.Data.DbType.Double"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.DoubleType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.DoubleType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.DoubleType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.DoubleType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.DoubleType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.DynamicComponentType">
            <summary>
            Handles "dynamic" components, represented as <c>&lt;map&gt;</c>s
            </summary>
        </member>
        <member name="T:NHibernate.Type.EntityType">
            <summary>
            A reference to an entity class
            </summary>
        </member>
        <member name="M:NHibernate.Type.EntityType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Converts the id contained in the <see cref="T:System.Data.IDataReader"/> to an object.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the query results.</param>
            <param name="names">A string array of column names that contain the id.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this is occurring in.</param>
            <param name="owner">The object that this Entity will be a part of.</param>
            <returns>
            An instance of the object or <c>null</c> if the identifer was null.
            </returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Resolve an identifier
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EntityType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Resolve an identifier or unique key value
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.EntityType.IsMutable">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.EntityType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.EntityType.IsAssociationType">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.EntityType.ForeignKeyType">
            <summary>
            When implemented by a class, gets the type of foreign key directionality 
            of this association.
            </summary>
            <value>The <see cref="P:NHibernate.Type.EntityType.ForeignKeyType"/> of this association.</value>
        </member>
        <member name="P:NHibernate.Type.EntityType.UsePrimaryKeyAsForeignKey">
            <summary>
            Is the foreign key the primary key of the table?
            </summary>
        </member>
        <member name="T:NHibernate.Type.EnumStringType">
            <summary>
            Maps a <see cref="T:System.Enum"/> to a 
            <see cref="F:System.Data.DbType.String">DbType.String</see>.
            </summary>
            <remarks>
            If your database should store the <see cref="T:System.Enum"/>
            using the named values in the enum instead of the underlying values
            then subclass this <see cref="T:NHibernate.Type.IType"/>.
            
            <para>
            All that needs to be done is to provide a default constructor that
            NHibernate can use to create the specific type.  For example, if 
            you had an enum defined as.
            </para>
            
            <code>
            public enum MyEnum 
            {
            	On,
            	Off,
            	Dimmed
            }
            </code>
            
            <para>
            all that needs to be written for your enum string type is:
            </para>
            
            <code>
            public class MyEnumStringType : NHibernate.Type.EnumStringType
            {
            	public MyEnumStringType()
            		: base( typeof( MyEnum ) )
            	{
            	}
            }
            </code>
            
            <para>
            The mapping would look like:
            </para>
            
            <code>
            ...
            	&lt;property name="Status" type="MyEnumStringType, AssemblyContaining" /&gt;
            ...
            </code>
            
            <para>
            The TestFixture that shows the working code can be seen
            in <c>NHibernate.Test.TypesTest.EnumStringTypeFixture.cs</c>
            , <c>NHibernate.Test.TypesTest.EnumStringClass.cs</c>
            , and <c>NHibernate.Test.TypesTest.EnumStringClass.hbm.xml</c>
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.Type.EnumStringType.MaxLengthForEnumString">
            <summary>
            Hardcoding of <c>255</c> for the maximum length
            of the Enum name that will be saved to the db.
            </summary>
            <value>
            <c>255</c> because that matches the default length that hbm2ddl will
            use to create the column.
            </value>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.#ctor(System.Type)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Type.EnumStringType"/>.
            </summary>
            <param name="enumClass">The <see cref="T:System.Type"/> of the Enum.</param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.#ctor(System.Type,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:NHibernate.Type.EnumStringType"/>.
            </summary>
            <param name="enumClass">The <see cref="T:System.Type"/> of the Enum.</param>
            <param name="length">The length of the string that can be written to the column.</param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.GetInstance(System.Object)">
            <summary>
            
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.GetValue(System.Object)">
            <summary>
            
            </summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="cached"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.EnumStringType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.EnumStringType.ReturnedClass">
            <summary>
            
            </summary>
        </member>
        <member name="P:NHibernate.Type.EnumStringType.Name">
            <summary>
            
            </summary>
            <remarks>
            This appends <c>enumstring - </c> to the beginning of the underlying
            enums name so that <see cref="T:System.Enum"/> could still be stored
            using the underlying value through the <see cref="T:NHibernate.Type.PersistentEnumType"/>
            also.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.GuidType">
            <summary>
            Maps a <see cref="T:System.Guid"/> Property 
            to a <see cref="F:System.Data.DbType.Guid"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.GuidType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.GuidType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GuidType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GuidType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.GuidType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.GuidType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.GuidType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.GuidType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.ForeignKeyType">
            <summary>
            Represents directionality of the foreign key constraint
            </summary>
        </member>
        <member name="M:NHibernate.Type.ForeignKeyType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.ForeignKeyType.CascadeNow(NHibernate.Engine.CascadePoint)">
            <summary>
            Should we cascade at this cascade point?
            </summary>
        </member>
        <member name="F:NHibernate.Type.ForeignKeyType.ForeignKeyToParent">
            <summary>
            A foreign key from child to parent
            </summary>
        </member>
        <member name="F:NHibernate.Type.ForeignKeyType.ForeignKeyFromParent">
            <summary>
            A foreign key from parent to child
            </summary>
        </member>
        <member name="T:NHibernate.Type.IdentifierBagType">
            <summary>
            Summary description for IdentifierBagType.
            </summary>
        </member>
        <member name="M:NHibernate.Type.IdentifierBagType.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
        </member>
        <member name="M:NHibernate.Type.IdentifierBagType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.IdentifierBagType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.IList"/> in a <see cref="T:NHibernate.Collection.IdentifierBag"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.IList"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.IdentifierBag"/> that wraps the non NHibernate <see cref="T:System.Collections.IList"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.IdentifierBagType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int16Type">
            <summary>
            Maps a <see cref="T:System.Int16"/> Property 
            to a <see cref="F:System.Data.DbType.Int16"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int16Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.Int16Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.Int16Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int16Type.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.Int16Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int16Type.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int16Type.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int32Type">
            <summary>
            Maps a <see cref="T:System.Int32"/> Property 
            to a <see cref="F:System.Data.DbType.Int32"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int32Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.Int32Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int32Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int32Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.Int32Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int32Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int32Type.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.Int32Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int32Type.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int32Type.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.Int64Type">
            <summary>
            Maps a <see cref="T:System.Int64"/> Property 
            to a <see cref="F:System.Data.DbType.Int64"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.Int64Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.Int64Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int64Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int64Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.Int64Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int64Type.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.Int64Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.Int64Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int64Type.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.Int64Type.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.ListType">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.ListType.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
        </member>
        <member name="M:NHibernate.Type.ListType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ListType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.ListType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.ManyToOneType">
            <summary>
            A many-to-one association to an entity
            </summary>
        </member>
        <member name="M:NHibernate.Type.ManyToOneType.Hydrate(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Hydrates the Identifier from <see cref="T:System.Data.IDataReader"/>.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the query results.</param>
            <param name="names">A string array of column names to read from.</param>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> this is occuring in.</param>
            <param name="owner">The object that this Entity will be a part of.</param>
            <returns>
            An instantiated object that used as the identifier of the type.
            </returns>
        </member>
        <member name="M:NHibernate.Type.ManyToOneType.ResolveIdentifier(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Resolves the Identifier to the actual object.
            </summary>
            <param name="id"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Type.MapType">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.MapType.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
        </member>
        <member name="M:NHibernate.Type.MapType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.MapType.GetElementsCollection(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.MapType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.IDictionary"/> in a <see cref="T:NHibernate.Collection.Map"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.IDictionary"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Map"/> that wraps the non NHibernate <see cref="T:System.Collections.IDictionary"/>.
            </returns>
        </member>
        <member name="P:NHibernate.Type.MapType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.ObjectType">
            <summary>
            	Handles "any" mappings and the old deprecated "object" type.
            </summary>
            <remarks>
            	The identifierType is any NHibernate IType that can be serailized by default.
            	For example, you can specify the identifierType as an Int32 or a custom identifier
            	type that you built.  The identifierType matches to one or many columns.
            	
            	The metaType maps to a single column.  By default it stores the name of the Type
            	that the Identifier identifies.  
            	
            	For example, we can store a link to any table.  It will have the results
            	class_name					id_col1
            	========================================
            	Simple, AssemblyName			5
            	DiffClass, AssemblyName			5
            	Simple, AssemblyName			4
            	
            	You can also provide you own type that might map the name of the class to a table
            	with a giant switch statemet or a good naming convention for your class->table.  The
            	data stored might look like
            	class_name					id_col1
            	========================================
            	simple_table					5
            	diff_table						5
            	simple_table					4
            	
            </remarks>
        </member>
        <member name="M:NHibernate.Type.ObjectType.#ctor(NHibernate.Type.IType,NHibernate.Type.IType)">
            <summary>
            
            </summary>
            <param name="metaType"></param>
            <param name="identifierType"></param>
        </member>
        <member name="M:NHibernate.Type.ObjectType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.ObjectType.DeepCopy(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ObjectType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.ObjectType.GetColumnSpan(NHibernate.Engine.IMapping)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.ObjectType.UsePrimaryKeyAsForeignKey">
            <summary>
            Not really relevant to ObjectType, since it cannot be "joined"
            </summary>
        </member>
        <member name="T:NHibernate.Type.OneToOneType">
            <summary>
            A one-to-one association to an entity
            </summary>
        </member>
        <member name="T:NHibernate.Type.PersistentEnumType">
            <summary>
            PersistentEnumType
            </summary>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="enumClass"></param>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.GetUnderlyingSqlType(System.Type)">
            <summary>
            Determines what the NHibernate SqlType should be based on the 
            values contain in the Enum
            </summary>
            <param name="enumClass">The Enumeration class to get the values from.</param>
            <returns>The SqlType for this EnumClass</returns>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.GetInstance(System.Object)">
            <summary>
            Gets an instance of the Enum
            </summary>
            <param name="code">The underlying value of an item in the Enum.</param>
            <returns>
            An instance of the Enum set to the <c>code</c> value.
            </returns>
        </member>
        <member name="M:NHibernate.Type.PersistentEnumType.GetValue(System.Object)">
            <summary>
            Gets the correct value for the Enum.
            </summary>
            <param name="code">The value to convert.</param>
            <returns>A boxed version of the code converted to the correct type.</returns>
            <remarks>
            This handles situations where the DataProvider returns the value of the Enum
            from the db in the wrong underlying type.  It uses <see cref="T:System.Convert"/> to 
            convert it to the correct type.
            </remarks>
        </member>
        <member name="P:NHibernate.Type.PersistentEnumType.Name">
            <summary></summary> 
        </member>
        <member name="T:NHibernate.Type.SByteType">
            <summary>
            Maps a <see cref="T:System.SByte"/> Property 
            to a <see cref="F:System.Data.DbType.SByte"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SByteType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.SByteType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SByteType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SByteType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.SByteType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SByteType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SByteType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SByteType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.SByteType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SerializableType">
            <summary>
            Maps an instance of a <see cref="T:System.Object"/> that has the <see cref="T:System.SerializableAttribute"/>
            to a <see cref="F:System.Data.DbType.Binary"/> column.  
            </summary>
            <remarks>
            <para>
            The SerializableType should be used when you know that Bytes are 
            not going to be greater than 8,000.
            </para>
            <para>
            The base class is <see cref="T:NHibernate.Type.MutableType"/> because the data is stored in 
            a byte[].  The System.Array does not have a nice "equals" method so we must
            do a custom implementation.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.SerializableType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.DeepCopyNotNull(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.FromBytes(System.Byte[])">
            <summary>
            
            </summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="cached"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SerializableType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SerializableType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SerializationException">
            <summary>
            Thrown when a property cannot be serialized/deserialized
            </summary>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="e">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.Type.SerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.Type.SerializationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.Type.SetType">
            <summary>
            Summary description for SetType.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SetType.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
        </member>
        <member name="M:NHibernate.Type.SetType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            <see cref="M:NHibernate.Type.PersistentCollectionType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)"/>
            </summary>
            <param name="persister"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.Type.SetType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:Iesi.Collections.ISet"/> in a <see cref="T:NHibernate.Collection.Set"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:Iesi.Collections.ISet"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.Set"/> that wraps the non NHibernate <see cref="T:Iesi.Collections.ISet"/>.
            </returns>
        </member>
        <member name="M:NHibernate.Type.SetType.GetElementsCollection(System.Object)">
            <summary>
            
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SetType.ReturnedClass">
            <summary>
            <see cref="P:NHibernate.Type.AbstractType.ReturnedClass"/>
            </summary>
        </member>
        <member name="T:NHibernate.Type.SingleType">
            <summary>
            Maps a <see cref="T:System.Single"/> Property to an 
            <see cref="F:System.Data.DbType.Single"/> column.
            </summary>
            <remarks>
            Verify through your database's documentation if there is a column type that
            matches up with the capabilities of <see cref="T:System.Single"/>  
            </remarks>
        </member>
        <member name="M:NHibernate.Type.SingleType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.SingleType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SingleType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SingleType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.SingleType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.SingleType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.SingleType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.SortedMapType">
            <summary>
            Extends the MapType to provide Sorting.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SortedMapType.#ctor(System.String,System.Collections.IComparer)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NHibernate.Type.SortedMapType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SortedMapType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:System.Collections.IDictionary"/> in a <see cref="T:NHibernate.Collection.SortedMap"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:System.Collections.IDictionary"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.SortedMap"/> that wraps the non NHibernate <see cref="T:System.Collections.IDictionary"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.SortedSetType">
            <summary>
            Extends the SetType to provide Sorting.
            </summary>
        </member>
        <member name="M:NHibernate.Type.SortedSetType.#ctor(System.String,System.Collections.IComparer)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NHibernate.Type.SortedSetType.Instantiate(NHibernate.Engine.ISessionImplementor,NHibernate.Collection.ICollectionPersister)">
            <summary>
            
            </summary>
            <param name="session"></param>
            <param name="persister"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.SortedSetType.Wrap(NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Wraps an <see cref="T:Iesi.Collections.ISet"/> in a <see cref="T:NHibernate.Collection.SortedSet"/>.
            </summary>
            <param name="session">The <see cref="T:NHibernate.Engine.ISessionImplementor"/> for the collection to be a part of.</param>
            <param name="collection">The unwrapped <see cref="T:Iesi.Collections.ISet"/>.</param>
            <returns>
            An <see cref="T:NHibernate.Collection.SortedSet"/> that wraps the non NHibernate <see cref="T:Iesi.Collections.ISet"/>.
            </returns>
        </member>
        <member name="T:NHibernate.Type.StringClobType">
            <summary>
            Maps a <see cref="T:System.String"/> Property to an 
            <see cref="T:System.String"/> column that can store a CLOB.
            </summary>
            <remarks>
            This is only needed by DataProviders (SqlClient) that need to specify a Size for the
            IDbDataParameter.  Most DataProvider(Oralce) don't need to set the Size so a StringType
            would work just fine.
            </remarks>
        </member>
        <member name="T:NHibernate.Type.StringType">
            <summary>
            Maps a <see cref="T:System.String"/> to a <see cref="F:System.Data.DbType.String"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.StringType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.StringType.#ctor(NHibernate.SqlTypes.StringSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="M:NHibernate.Type.StringType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.StringType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.StringType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.StringType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.StringType.Name">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.StringClobType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.StringClobType.#ctor(NHibernate.SqlTypes.StringSqlType)">
            <summary>
            
            </summary>
            <param name="sqlType"></param>
        </member>
        <member name="P:NHibernate.Type.StringClobType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TicksType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to an <see cref="F:System.Data.DbType.Int64"/> column 
            that stores the DateTime using the Ticks property.
            </summary>
            <remarks>
            This is the recommended way to "timestamp" a column.  The System.DateTime.Ticks 
            is accurate to 100-nanosecond intervals. 
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TicksType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TicksType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.TicksType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.GetHashCode">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TicksType.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TicksType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TicksType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TicksType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TicksType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TicksType.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TimeSpanType">
            <summary>
            Maps a <see cref="T:System.TimeSpan"/> Property to an <see cref="F:System.Data.DbType.Int64"/> column 
            </summary>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeSpanType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeSpanType.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TimestampType">
            <summary>
            This is almost the exact same type as the DateTime except it can be used
            in the version column, stores it to the accuracy the Database supports, 
            and will default to the value of DateTime.Now if the value is null.
            </summary>
            <remarks>
            <p>
            The value stored in the database depends on what your Data Provider is capable
            of storing.  So there is a possibility that the DateTime you save will not be
            the same DateTime you get back when you check DateTime.Equals(DateTime) because
            they will have their milliseconds off.
            </p>  
            <p>
            For example - MsSql Server 2000 is only accurate to 3.33 milliseconds.  So if 
            NHibernate writes a value of <c>01/01/98 23:59:59.995</c> to the Prepared Command, MsSql
            will store it as <c>1998-01-01 23:59:59.997</c>.
            </p>
            <p>
            Please review the documentation of your Database server.
            </p>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TimestampType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TimestampType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimestampType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimestampType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Sets the value of this Type in the IDbCommand.
            </summary>
            <param name="st">The IDbCommand to add the Type's value to.</param>
            <param name="value">The value of the Type.</param>
            <param name="index">The index of the IDataParameter in the IDbCommand.</param>
            <remarks>
            No null values will be written to the IDbCommand for this Type. 
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TimestampType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimestampType.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimestampType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimestampType.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimestampType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimestampType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TimestampType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimestampType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimestampType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimestampType.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TimeType">
            <summary>
            Maps a <see cref="T:System.DateTime"/> Property to an DateTime column that only stores the 
            Hours, Minutes, and Seconds of the DateTime as significant.
            </summary>
            <remarks>
            <para>
            This defaults the Date to "1753-01-01" - that should not matter because
            using this Type indicates that you don't care about the Date portion of the DateTime.
            </para>
            <para>
            A more appropriate choice to store the duration/time is the <see cref="T:NHibernate.Type.TimeSpanType"/>.
            The underlying <see cref="F:System.Data.DbType.Time"/> tends to be handled diffently by different
            DataProviders.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TimeType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TimeType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="st"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.TimeType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.ToString(System.Object)">
            <summary>
            
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TimeType.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TimeType.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeType.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TimeType.HasNiceEquals">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TrueFalseType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> to a 1 char <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column 
            that stores a <code>'T'/'F'</code> to indicate <code>true/false</code>.
            </summary>
            <remarks>
            If you are using schema-export to generate your tables then you need
            to set the column attributes: <c>length=1</c> or <c>sql-type="char(1)"</c>.
            
            This needs to be done because in Java's JDBC there is a type for CHAR and 
            in ADO.NET there is not one specifically for char, so you need to tell schema
            export to create a char(1) column.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TrueFalseType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.FalseString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.TrueFalseType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.TypeFactory">
            <summary>
            Used internally to obtain instances of IType.
            </summary>
            <remarks>
            Applications should use static methods and constants on NHibernate.NHibernateUtil if the default
            IType is good enough.  For example, the TypeFactory should only be used when the String needs
            to have a length of 300 instead of 255.  At this point NHibernate.String does not get you the 
            correct IType.  Instead use TypeFactory.GetString(300) and keep a local variable that holds
            a reference to the IType.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.#cctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetTypeClassification(System.String)">
            <summary>
            Gets the classification of the Type based on the string.
            </summary>
            <param name="typeName">The name of the Type to get the classification for.</param>
            <returns>The Type of Classification</returns>
            <remarks>
            This parses through the string and makes the assumption that no class
            name and no assembly name will contain the <c>"("</c>.  
            <para>
            If it finds 
            the <c>"("</c> and then finds a <c>","</c> afterwards then it is a 
            <c>TypeClassification.PrecisionScale</c>.  
            </para>
            <para>
            If it finds the <c>"("</c>
            and doesn't find a <c>","</c> afterwards, then it is a 
            <c>TypeClassification.Length</c>.
            </para>
            <para>
            If it doesn't find the <c>"("</c> then it assumes that it is a
            <c>TypeClassification.Plain</c>.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Basic(System.String)">
            <summary>
            Given the name of a Hibernate type such as Decimal, Decimal(19,0)
            , Int32, or even NHibernate.Type.DecimalType, NHibernate.Type.DecimalType(19,0), 
            NHibernate.Type.Int32Type, then return an instance of NHibernate.Type.IType
            </summary>
            <param name="name">The name of the type.</param>
            <returns>The instance of the IType that the string represents.</returns>
            <remarks>
            This method will return null if the name is not found in the basicNameMap.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.HeuristicType(System.String)">
            <summary>
            Uses heuristics to deduce a NHibernate type given a string naming the 
            type. 
            </summary>
            <param name="typeName"></param>
            <returns>An instance of <c>NHibernate.Type.IType</c></returns>
            <remarks>
            When looking for the NHibernate type it will look in the cache of the Basic types first.
            If it doesn't find it in the cache then it uses the typeName to get a reference to the
            Class (Type in .NET).  Once we get the reference to the .NET class we check to see if it
            implements IType, ICompositeUserType, IUserType, ILifecycle (Association), or 
            IPersistentEnum.  If none of those are implemented then we will serialize the Type to the
            database using NHibernate.Type.SerializableType(typeName)  
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetAnsiStringType(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetBinaryType(System.Int32)">
            <summary>
            Gets the BinaryType with the specified length.
            </summary>
            <param name="length">The length of the data to store in the database.</param>
            <returns>A BinaryType</returns>
            <remarks>
            In addition to returning the BinaryType it will also ensure that it has
            been added to the basicNameMap with the keys <c>Byte[](length)</c> and 
            <c>NHibernate.Type.BinaryType(length)</c>.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetDecimalType(System.Byte,System.Byte)">
            <summary>
            
            </summary>
            <param name="precision"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type)">
            <summary>
            Gets the SerializableType for the specified Type
            </summary>
            <param name="serializableType">The Type that will be Serialized to the database.</param>
            <returns>A SerializableType</returns>
            <remarks>
            <para>
            In addition to returning the SerializableType it will also ensure that it has
            been added to the basicNameMap with the keys <c>Type.FullName</c> (the result
            of <c>IType.Name</c> and <c>Type.AssemblyQualifiedName</c>.  This is different 
            from the other items put in the basicNameMap because it is uses the AQN and the
            FQN as opposed to the short name used in the maps and the FQN.
            </para>
            <para>
            Since this method calls the method
            <see cref="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type,System.Int32)">GetSerializableType(System.Type, Int32)</see>
            with the default length, those keys will also be added.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Type,System.Int32)">
            <summary>
            
            </summary>
            <param name="serializableType"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetSerializableType(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetStringType(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.GetTypeType(System.Int32)">
            <summary>
            
            </summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.OneToOne(System.Type,NHibernate.Type.ForeignKeyType)">
            <summary>
            A one-to-one association type for the given class and cascade style.
            </summary>
            <param name="persistentClass"></param>
            <param name="foreignKeyType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.OneToOne(System.Type,NHibernate.Type.ForeignKeyType,System.String)">
            <summary>
            A one-to-one association type for the given class and cascade style.
            </summary>
            <param name="persistentClass"></param>
            <param name="foreignKeyType"></param>
            <param name="uniqueKeyPropertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.Type)">
            <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
            <param name="persistentClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.ManyToOne(System.Type,System.String)">
            <summary>
            A many-to-one association type for the given class and cascade style.
            </summary>
            <param name="persistentClass"></param>
            <param name="uniqueKeyPropertyName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Array(System.String,System.Type)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <param name="elementClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.List(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Bag(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.IdBag(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Map(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Set(System.String)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.SortedMap(System.String,System.Collections.IComparer)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.SortedSet(System.String,System.Collections.IComparer)">
            <summary>
            
            </summary>
            <param name="role"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.DeepCopy(System.Object[],NHibernate.Type.IType[],System.Boolean[],System.Object[])">
            <summary>
            Deep copy values in the first array into the second
            </summary>
            <param name="values"></param>
            <param name="types"></param>
            <param name="copy"></param>
            <param name="target"></param>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.FindDirty(NHibernate.Type.IType[],System.Object[],System.Object[],System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine if any of the given field values are dirty,
            returning an array containing indexes of
            the dirty fields or null if no fields are dirty.
            </summary>
            <param name="types"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="check"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.FindModified(NHibernate.Type.IType[],System.Object[],System.Object[],System.Boolean[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            Determine if any of the given field values are modified,
            returning an array containing indexes of
            the dirty fields or null if no fields are modified.
            </summary>
            <param name="types"></param>
            <param name="old"></param>
            <param name="current"></param>
            <param name="check"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Assemble(System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            
            </summary>
            <param name="row"></param>
            <param name="types"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Disassemble(System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor)">
            <summary>
            
            </summary>
            <param name="row"></param>
            <param name="types"></param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.TypeFactory.Copy(System.Object[],System.Object[],NHibernate.Type.IType[],NHibernate.Engine.ISessionImplementor,System.Object,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="original"></param>
            <param name="target"></param>
            <param name="types"></param>
            <param name="session"></param>
            <param name="owner"></param>
            <param name="copiedAlready"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Type.TypeType">
            <summary>
            Maps the Assembly Qualified Name of a <see cref="T:System.Type"/> to a 
            <see cref="F:System.Data.DbType.String"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.TypeType.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.TypeType.#ctor(NHibernate.SqlTypes.StringSqlType)">
            <summary>
            Initialize a new instance of the TypeType class using a 
            <see cref="T:NHibernate.SqlTypes.SqlType"/>. 
            </summary>
            <param name="sqlType">The underlying <see cref="T:NHibernate.SqlTypes.SqlType"/>.</param>
        </member>
        <member name="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            Gets the <see cref="T:System.Type"/> in the <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="index">The index of the field to get the value from.</param>
            <returns>The <see cref="T:System.Type"/> from the database.</returns>
            <exception cref="T:System.TypeLoadException">
            Thrown when the value in the database can not be loaded as a <see cref="T:System.Type"/>
            </exception>
        </member>
        <member name="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.String)">
            <summary>
            Gets the <see cref="T:System.Type"/> in the <see cref="T:System.Data.IDataReader"/> for the Property.
            </summary>
            <param name="rs">The <see cref="T:System.Data.IDataReader"/> that contains the value.</param>
            <param name="name">The name of the field to get the value from.</param>
            <returns>The <see cref="T:System.Type"/> from the database.</returns>
            <remarks>
            This just calls gets the index of the name in the IDataReader
            and calls the overloaded version <see cref="M:NHibernate.Type.TypeType.Get(System.Data.IDataReader,System.Int32)"/>
            (IDataReader, Int32). 
            </remarks>
            <exception cref="T:System.TypeLoadException">
            Thrown when the value in the database can not be loaded as a <see cref="T:System.Type"/>
            </exception>
        </member>
        <member name="M:NHibernate.Type.TypeType.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Puts the Assembly Qualified Name of the <see cref="T:System.Type"/> 
            Property into to the <see cref="T:System.Data.IDbCommand"/>.
            </summary>
            <param name="cmd">The <see cref="T:System.Data.IDbCommand"/> to put the value into.</param>
            <param name="value">The <see cref="T:System.Type"/> that contains the value.</param>
            <param name="index">The index of the <see cref="T:System.Data.IDbDataParameter"/> to start writing the value to.</param>
            <remarks>
            This uses the <see cref="M:NHibernate.Type.NullableType.Set(System.Data.IDbCommand,System.Object,System.Int32)"/> method of the 
            <see cref="F:NHibernate.NHibernateUtil.String"/> object to do the work.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.TypeType.ToString(System.Object)">
            <summary>
            A representation of the value to be embedded in an XML element 
            </summary>
            <param name="value">The <see cref="T:System.Type"/> that contains the values.
            </param>
            <returns>An Xml formatted string that contains the Assembly Qualified Name.</returns>
        </member>
        <member name="M:NHibernate.Type.TypeType.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.TypeType.ReturnedClass">
            <summary>
            Gets the <see cref="T:System.Type"/> that will be returned 
            by the <c>NullSafeGet()</c> methods.
            </summary>
            <value>
            A <see cref="T:System.Type"/> from the .NET framework.
            </value>
        </member>
        <member name="P:NHibernate.Type.TypeType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt16Type">
            <summary>
            Maps a <see cref="T:System.UInt16"/> Property 
            to a <see cref="F:System.Data.DbType.UInt16"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt16Type.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.UInt16Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt16Type.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt16Type.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt32Type">
            <summary>
            Maps a <see cref="T:System.UInt32"/> Property 
            to a <see cref="F:System.Data.DbType.UInt32"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt32Type.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.UInt32Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt32Type.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt32Type.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.UInt64Type">
            <summary>
            Maps a <see cref="T:System.UInt64"/> Property 
            to a <see cref="F:System.Data.DbType.UInt64"/> column.
            </summary>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.#ctor">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.Get(System.Data.IDataReader,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.Get(System.Data.IDataReader,System.String)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.Set(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            
            </summary>
            <param name="rs"></param>
            <param name="value"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.ObjectToSQLString(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.StringToObject(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.FromStringValue(System.String)">
            <summary>
            
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Type.UInt64Type.Next(System.Object)">
            <summary>
            
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Type.UInt64Type.ReturnedClass">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt64Type.Name">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.UInt64Type.Seed">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Type.YesNoType">
            <summary>
            Maps a <see cref="T:System.Boolean"/> to a 1 char <see cref="F:System.Data.DbType.AnsiStringFixedLength"/> column 
            that stores a <code>'Y'/'N'</code> to indicate <code>true/false</code>.
            </summary>
            <remarks>
            If you are using schema-export to generate your tables then you need
            to set the column attributes: <c>length=1</c> or <c>sql-type="char(1)"</c>.
            
            This needs to be done because in Java's JDBC there is a type for CHAR and 
            in ADO.NET there is not one specifically for char, so you need to tell schema
            export to create a char(1) column.
            </remarks>
        </member>
        <member name="M:NHibernate.Type.YesNoType.#ctor">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.TrueString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.FalseString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Type.YesNoType.Name">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Util.ArrayHelper">
            <summary>
            Helper class that contains common array functions and 
            data structures used through out NHibernate.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.IsAllNegative(System.Int32[])">
            <summary>
            
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.Equals(System.Byte[],System.Byte[])">
            <summary>
            Compares two byte[] arrays for equality.
            </summary>
            <param name="lhs">The byte[] array on the Left Hand Side </param>
            <param name="rhs">The byte[] array on the Right Hand Side</param>
            <returns>true if they contain the same items</returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.Equals(System.Array,System.Array)">
            <summary>
            Compares two object arrays for equality.
            </summary>
            <param name="lhs">The object array on the Left Hand Side </param>
            <param name="rhs">The object array on the Right Hand Side</param>
            <returns>true if they contain the same items</returns>
            <remarks>
            This relies on the objects in the array implementing the method Equals(object)
            correctly.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.ToStringArray(System.Object[])">
            <summary>
            
            </summary>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.FillArray(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.ToStringArray(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="coll"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.ToIntArray(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="coll"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.Slice(System.String[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="strings"></param>
            <param name="begin"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.Slice(System.Object[],System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="objects"></param>
            <param name="begin"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.Join(System.String[],System.String[])">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.Join(System.Data.DbType[],System.Data.DbType[])">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ArrayHelper.Join(NHibernate.SqlTypes.SqlType[],NHibernate.SqlTypes.SqlType[])">
            <summary>
            
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Util.IdentityMap">
            <summary>
            An <see cref="T:System.Collections.IDictionary"/> where keys are compared by object identity, rather than <c>equals</c>.
            
            All external users of this class need to have no knowledge of the IdentityKey - it is all
            hidden by this class.
            </summary>
            <remarks>
            <para>
            Do NOT use a System.Value type as the key for this Hashtable - only classes.  See
            the <a href="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;threadm=bds2rm%24ruc%241%40charly.heeg.de&amp;rnum=1&amp;prev=/groups%3Fhl%3Den%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26q%3DSystem.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%26sa%3DN%26tab%3Dwg">google thread</a>
            about why using System.Value is a bad thing.
            </para>
            <para>
            If I understand it correctly, the first call to get an object defined by a DateTime("2003-01-01")
            would box the DateTime and return the identity key for the box.  If you were to get that Key and
            unbox it into a DateTime struct, then the next time you passed it in as the Key the IdentityMap
            would box it again (into a different box) and it would have a different IdentityKey - so you would
            not get the same value for the same DateTime value. 
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Instantiate(System.Int32)">
            <summary>
            Create a new instance of the IdentityMap that has no 
            iteration order.
            </summary>
            <returns>A new IdentityMap based on a Hashtable.</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.InstantiateSequenced(System.Int32)">
            <summary>
            Create a new instance of the IdentityMap that has an 
            iteration order of the order the objects were added
            to the Map.
            </summary>
            <returns>A new IdentityMap based on ListDictionary.</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.ConcurrentEntries(System.Collections.IDictionary)">
            <summary>
            Return the Dictionary Entries (as instances of <c>DictionaryEntry</c> in a collection
            that is safe from concurrent modification).  Ie - we may safely add new instances
            to the underlying <c>IDictionary</c> during enumeration of the <c>Values</c>.
            </summary>
            <param name="map">The IDictionary to get the enumeration safe list.</param>
            <returns>A Collection of DictionaryEntries</returns>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.#ctor(System.Collections.IDictionary)">
            <summary>
            Create the IdentityMap class with the correct class for the IDictionary.
            Unsorted = Hashtable
            Sorted = ListDictionary
            </summary>
            <param name="underlyingMap">A class that implements the IDictionary for storing the objects.</param>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Add(System.Object,System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Add(System.Object,System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Clear">
            <summary>
            <see cref="M:System.Collections.IDictionary.Clear"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Contains(System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Contains(System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.GetEnumerator">
            <summary>
            <see cref="M:System.Collections.IDictionary.GetEnumerator"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.Remove(System.Object)">
            <summary>
            <see cref="M:System.Collections.IDictionary.Remove(System.Object)"/>
            </summary>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.CopyTo(System.Array,System.Int32)">
            <summary>
            <see cref="M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)"/>
            </summary>
            <param name="array"></param>
            <param name="i"></param>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.VerifyValidKey(System.Object)">
            <summary>
            Verifies that we are not using a System.ValueType as the Key in the Dictionary
            </summary>
            <param name="obj">The object that will be the key.</param>
            <returns>An object that is safe to be a key.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the obj is a System.ValueType</exception>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Count">
            <summary>
            <see cref="P:System.Collections.ICollection.Count"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsSynchronized">
            <summary>
            <see cref="P:System.Collections.ICollection.IsSynchronized"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.SyncRoot">
            <summary>
            <see cref="P:System.Collections.ICollection.SyncRoot"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsFixedSize">
            <summary>
            <see cref="P:System.Collections.IDictionary.IsFixedSize"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.IsReadOnly">
            <summary>
            <see cref="P:System.Collections.IDictionary.IsReadOnly"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Keys">
            <summary>
            Returns the Keys used in this IdentityMap
            <see cref="P:System.Collections.IDictionary.IsReadOnly"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Item(System.Object)">
            <summary>
            <see cref="P:System.Collections.IDictionary.Item(System.Object)"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.Values">
            <summary>
            <see cref="P:System.Collections.IDictionary.Values"/>
            </summary>
        </member>
        <member name="P:NHibernate.Util.IdentityMap.EntryList">
            <summary>
            Provides a snapshot VIEW in the form of a List of the contents of the IdentityMap.
            You can safely iterate over this VIEW and modify the actual IdentityMap because the
            VIEW is a copy of the contents, not a reference to the existing Map.
            
            Contains a copy (not that actual instance stored) of the DictionaryEntries in a List.
            </summary>
        </member>
        <member name="T:NHibernate.Util.IdentityMap.IdentityComparer">
            <summary>
            Compares two objects for Equality using "==" instead of Object.Equals
            </summary>
            <remarks>
            Only for use in IdentityMap.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.IdentityMap.IdentityComparer.Compare(System.Object,System.Object)">
            <summary>
            Performs a null safe comparison using "==" instead of Object.Equals()
            </summary>
            <param name="x">First object to compare.</param>
            <param name="y">Second object to compare.</param>
            <remarks>
            This is Lazy collection safe since it uses <c>==</c>, unlike <c>Object.Equals()</c> 
            which currently causes NHibernate to load up the collection.  This behaivior of 
            Collections is likely to change because Java's collections override Equals() and 
            .net's collections don't.  So in .net there is no need to override Equals() and 
            GetHashCode() on the NHibernate Collection implementations.
            </remarks>
            <returns>
            Unlike the standard IComparer interface this will not return a <c>1</c> or <c>-1</c>
            to indicate which is Greater Than or Less Than.  It always returns <c>-1</c> to 
            indicate the two are not Equal.
            </returns>
        </member>
        <member name="T:NHibernate.Util.JoinedEnumerable">
            <summary>
            Combines multiple objects implementing <see cref="T:System.Collections.IEnumerable"/> into one.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.#ctor(System.Collections.IEnumerable[])">
            <summary>
            Creates an IEnumerable object from multiple IEnumerables.
            </summary>
            <param name="enumerables">The IEnumerables to join together.</param>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.MoveNext">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.Reset">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.GetEnumerator">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.JoinedEnumerable._isAlreadyDisposed">
            <summary>
            A flag to indicate if <c>Disose()</c> has been called.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.Finalize">
            <summary>
            Finalizer that ensures the object is correctly disposed of.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.Dispose">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
        </member>
        <member name="M:NHibernate.Util.JoinedEnumerable.Dispose(System.Boolean)">
            <summary>
            Takes care of freeing the managed and unmanaged resources that 
            this class is responsible for.
            </summary>
            <param name="isDisposing">Indicates if this JoinedEnumerable is being Disposed of or Finalized.</param>
            <remarks>
            The command is closed and the reader is disposed.  This allows other ADO.NET
            related actions to occur without needing to move all the way through the
            EnumerableImpl.
            </remarks>
        </member>
        <member name="P:NHibernate.Util.JoinedEnumerable.Current">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Util.ObjectUtils">
            <summary>
            Summary description for ObjectUtils.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ObjectUtils.DefaultIfNull(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ObjectUtils.Equals(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ObjectUtils.IdentityToString(System.Object)">
            <summary>
            
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.Util.ObjectUtils.Null">
            <summary></summary>
        </member>
        <member name="T:NHibernate.Util.PropertiesHelper">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetBoolean(System.String,System.Collections.IDictionary,System.Boolean)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetBoolean(System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetInt32(System.String,System.Collections.IDictionary,System.Int32)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetString(System.String,System.Collections.IDictionary,System.String)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="properties"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.ToDictionary(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="delim"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.ToStringArray(System.String,System.String,System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="property"></param>
            <param name="delim"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.ToStringArray(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="propValue"></param>
            <param name="delim"></param>
            <returns></returns>
        </member>
        <member name="F:NHibernate.Util.PropertiesHelper.TagParam">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.PropertiesHelper.AttrValue">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.PropertiesHelper.AttrName">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.PropertiesHelper.GetParams(System.Xml.XmlElement)">
            <summary>
            Extracts a set of param child nodes from the specified node
            &lt;param name="theName" value="theValue"/&gt;
            </summary>
            <param name="node">Parent element.</param>
            <returns>null if no parameters are found</returns>
        </member>
        <member name="T:NHibernate.Util.ReflectHelper">
            <summary>
            Helper class for Reflection related code.
            </summary>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.OverridesEquals(System.Type)">
            <summary>
            Determine if the specified <see cref="T:System.Type"/> overrides the
            implementation of Equals from <see cref="T:System.Object"/>
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to reflect.</param>
            <returns><c>true</c> if any type in the hierarchy overrides Equals(object).</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.OverridesGetHashCode(System.Type)">
            <summary>
            Determine if the specified <see cref="T:System.Type"/> overrides the
            implementation of GetHashCode from <see cref="T:System.Object"/>
            </summary>
            <param name="clazz">The <see cref="T:System.Type"/> to reflect.</param>
            <returns><c>true</c> if any type in the hierarchy overrides GetHashCode().</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetGetter(System.Type,System.String,System.String)">
            <summary>
            Finds the <see cref="T:NHibernate.Property.IGetter"/> for the property in the <see cref="T:System.Type"/>.
            </summary>
            <param name="theClass"></param>
            <param name="propertyName"></param>
            <param name="propertyAccessorName"></param>
            <returns></returns>
            <remarks>
            This one takes a propertyAccessor name as we might know the correct strategy by now so we avoid Exceptions which are costly
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetGetter(System.Type,System.String)">
            <summary>
            Finds the <see cref="T:NHibernate.Property.IGetter"/> for the property in the <see cref="T:System.Type"/>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property/Field in.</param>
            <param name="propertyName">The name of the Property/Field to find.</param>
            <returns>The <see cref="T:NHibernate.Property.IGetter"/> for the property.</returns>
            <remarks>
            <para>
            This does not use the <c>access=""</c> attribute specified in the mapping.  It
            first checks to see if there is a Property in your class with the same name.  If
            no Property is found then it moves through each <see cref="T:NHibernate.Property.IPropertyAccessor"/> strategy
            and tries to find an <see cref="T:NHibernate.Property.IGetter"/> through them.
            </para>
            </remarks>
            <exception cref="T:NHibernate.PropertyNotFoundException">
            No Property or Field with the <c>propertyName</c> could be found.
            </exception>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyType(System.Type,System.String,System.String)">
            <summary>
            Get the NHibernate <see cref="T:NHibernate.Type.IType"/> for the named property of the <see cref="T:System.Type"/>.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the Property in.</param>
            <param name="name">The name of the property/field to find in the class.</param>
            <param name="access">The name of the property accessor for the property.</param>
            <returns>
            The NHibernate <see cref="T:NHibernate.Type.IType"/> for the named property.
            </returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ReflectedPropertyClass(System.Type,System.String,System.String)">
            <summary>
            Get the <see cref="T:System.Type"/> for the named property of a type.
            </summary>
            <param name="theClass">The <see cref="T:System.Type"/> to find the property in.</param>
            <param name="name">The name of the property/field to find in the class.</param>
            <returns>The <see cref="T:System.Type"/> for the named property.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.ClassForName(System.String)">
            <summary>
            Returns a reference to the Type.
            </summary>
            <param name="name">The name of the class or a fully qualified name.</param>
            <returns>The Type for the Class.</returns>
            <remarks>
            See <see cref="M:System.Type.GetType(System.String,System.Boolean)"/> for a full
            description of how this works. This method trims the <c>name</c> before passing
            it to GetType.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.TypeFromAssembly(NHibernate.Util.AssemblyQualifiedTypeName)">
            <summary>
            Returns a <see cref="T:System.Type"/> from an already loaded Assembly or an
            Assembly that is loaded with a partial name.
            </summary>
            <param name="name">An <see cref="T:NHibernate.Util.AssemblyQualifiedTypeName"/>.</param>
            <returns>
            A <see cref="T:System.Type"/> object that represents the specified type,
            or <c>null</c> if the type cannot be loaded.
            </returns>
            <remarks>
            Attempts to get a reference to the type from an already loaded assembly.  If the 
            type cannot be found then the assembly is loaded using
            <see cref="M:System.Reflection.Assembly.LoadWithPartialName(System.String)"/>.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetConstantValue(System.String,System.String)">
            <summary>
            Returns the value contained in the static field.
            </summary>
            <param name="typeName">The name of the <see cref="T:System.Type"/>.</param>
            <param name="fieldName">The name of the Field in the <see cref="T:System.Type"/>.</param>
            <returns>The value contained in that field or <c>null</c> if the Type or Field does not exist.</returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetConstantValue(System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetDefaultConstructor(System.Type)">
            <summary>
            Gets the default no arg constructor for the <see cref="T:System.Type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the constructor for.</param>
            <returns>
            The <see cref="T:System.Reflection.ConstructorInfo"/> for the no argument constructor, or <c>null</c> if the
            <c>type</c> is an abstract class.
            </returns>
            <exception cref="T:NHibernate.InstantiationException">
            Thrown when there is a problem calling the method GetConstructor on <see cref="T:System.Type"/>.
            </exception>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.GetConstructor(System.Type,NHibernate.Type.IType[])">
            <summary>
            Finds the constructor that takes the parameters.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to find the constructor in.</param>
            <param name="types">The <see cref="T:NHibernate.Type.IType"/> objects to use to find the appropriate constructor.</param>
            <returns>
            An <see cref="T:System.Reflection.ConstructorInfo"/> that can be used to create the type with
            the specified parameters.
            </returns>
            <exception cref="T:NHibernate.InstantiationException">
            Thrown when no constructor with the correct signature can be found.
            </exception>
        </member>
        <member name="M:NHibernate.Util.ReflectHelper.IsAbstractClass(System.Type)">
            <summary>
            Determines if the <see cref="T:System.Type"/> is a non creatable class.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to check.</param>
            <returns><c>true</c> if the <see cref="T:System.Type"/> is an Abstract Class or an Interface.</returns>
        </member>
        <member name="T:NHibernate.Util.SequencedHashMap">
            <summary>
            A map of objects whose mapping entries are sequenced based on the order in which they were
            added. This data structure has fast <c>O(1)</c> search time, deletion time, and insertion time
            </summary>
            <remarks>
            This class is not thread safe.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.CreateSentinel">
            <summary>
            Construct an empty sentinel used to hold the head (sentinel.next) and the tail (sentinal.prev)
            of the list. The sentinal has a <c>null</c> key and value
            </summary>
            <returns></returns>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._sentinel">
            <summary>
            Sentinel used to hold the head and tail of the list of entries
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._entries">
            <summary>
            Map of keys to entries
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap._modCount">
            <summary>
            Holds the number of modifications that have occurred to the map, excluding modifications
            made through a collection view's iterator.
            </summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor">
            <summary>
            Construct a new sequenced hash map with default initial size and load factor
            </summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32)">
            <summary>
            Construct a new sequenced hash map with the specified initial size and default load factor
            </summary>
            <param name="capacity">the initial size for the hash table</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Single)">
            <summary>
            Construct a new sequenced hash map with the specified initial size and load factor
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="loadFactor">the load factor for the hash table</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Construct a new sequenced hash map with the specified initial size, hash code provider
            and comparer
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="hcp"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Creates an empty Hashtable with the default initial capacity and using the default load factor, 
            the specified hash code provider and the specified comparer
            </summary>
            <param name="hcp"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.#ctor(System.Int32,System.Single,System.Collections.IHashCodeProvider,System.Collections.IComparer)">
            <summary>
            Creates an empty Hashtable with the default initial capacity and using the default load factor, 
            the specified hash code provider and the specified comparer
            </summary>
            <param name="capacity">the initial size for the hashtable</param>
            <param name="loadFactor">the load factor for the hash table</param>
            <param name="hcp"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.RemoveEntry(NHibernate.Util.SequencedHashMap.Entry)">
            <summary>
            Removes an internal entry from the linked list. THis does not remove it from the underlying
            map.
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.InsertEntry(NHibernate.Util.SequencedHashMap.Entry)">
            <summary>
            Inserts a new internal entry to the tail of the linked list. This does not add the 
            entry to the underlying map.
            </summary>
            <param name="entry"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Add(System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Clear">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Contains(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.Remove(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.CopyTo(System.Array,System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.System#Collections#IEnumerable#GetEnumerator">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ContainsKey(System.Object)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ContainsValue(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.RemoveImpl(System.Object)">
            <summary>
            Remove the Entry identified by the Key if it exists.
            </summary>
            <param name="key">The Key to remove.</param>
        </member>
        <member name="M:NHibernate.Util.SequencedHashMap.ToString">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsFixedSize">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsReadOnly">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Item(System.Object)">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Keys">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Values">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.Count">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.IsSynchronized">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.SyncRoot">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.FirstKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.FirstValue">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.LastKey">
            <summary></summary>
        </member>
        <member name="P:NHibernate.Util.SequencedHashMap.LastValue">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnKey">
            <summary>
            Return only the Key of the DictionaryEntry
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnValue">
            <summary>
            Return only the Value of the DictionaryEntry
            </summary>
        </member>
        <member name="F:NHibernate.Util.SequencedHashMap.ReturnType.ReturnEntry">
            <summary>
            Return the full DictionaryEntry
            </summary>
        </member>
        <member name="T:NHibernate.Util.StringHelper">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Dot">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Underscore">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.CommaSpace">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.Comma">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.OpenParen">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.ClosedParen">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.SingleQuote">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.NamePrefix">
            <summary></summary>
        </member>
        <member name="F:NHibernate.Util.StringHelper.SqlParameter">
            <summary></summary>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Repeat(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Replace(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="placeholder"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.ReplaceOnce(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="template"></param>
            <param name="placeholder"></param>
            <param name="replacement"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Split(System.String,System.String)">
            <summary>
            Just a façade for calling string.Split()
            We don't use our StringTokenizer because string.Split() is
            more efficient (but it only works when we don't want to retrieve the delimiters)
            </summary>
            <param name="separators">separators for the tokens of the list</param>
            <param name="list">the string that will be broken into tokens</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Split(System.String,System.String,System.Boolean)">
            <summary>
            Splits the String using the StringTokenizer.  
            </summary>
            <param name="separators">separators for the tokens of the list</param>
            <param name="list">the string that will be broken into tokens</param>
            <param name="include">true to include the seperators in the tokens.</param>
            <returns></returns>
            <remarks>
            This is more powerful than Split because you have the option of including or 
            not including the seperators in the tokens.
            </remarks>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Unqualify(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Unqualify(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <param name="seperator"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.GetFullClassname(System.String)">
            <summary>
            Takes a fully qualified type name and returns the full name of the 
            Class - includes namespaces.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.GetClassname(System.String)">
            <summary>
            Takes a fully qualifed type name (can include the assembly) and just returns
            the name of the Class.
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Qualifier(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Suffix(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="columns"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Suffix(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="suffix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Prefix(System.String[],System.String)">
            <summary>
            
            </summary>
            <param name="columns"></param>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Root(System.String)">
            <summary>
            
            </summary>
            <param name="qualifiedName"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.BooleanValue(System.String)">
            <summary>
            Converts a <see cref="T:System.String"/> in the format of "true", "t", "false", or "f" to
            a <see cref="T:System.Boolean"/>.
            </summary>
            <param name="value">The string to convert.</param>
            <returns>
            The <c>value</c> converted to a <see cref="T:System.Boolean"/> .
            </returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.ToString(System.Object[])">
            <summary>
            
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Multiply(System.String,System.Collections.IEnumerator,System.Collections.IEnumerator)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="placeholders"></param>
            <param name="replacements"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Multiply(System.String[],System.String,System.String[])">
            <summary>
            
            </summary>
            <param name="strings"></param>
            <param name="placeholder"></param>
            <param name="replacements"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.CountUnquoted(System.String,System.Char)">
            <summary>
            Counts the unquoted instances of the character.
            </summary>
            <param name="str"></param>
            <param name="character"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.Util.StringHelper.Qualify(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="prefix"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.Util.StringTokenizer">
            <summary>
            A StringTokenizer java like object 
            </summary>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="delim"></param>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="str"></param>
            <param name="delim"></param>
            <param name="returnDelims"></param>
        </member>
        <member name="M:NHibernate.Util.StringTokenizer.GetEnumerator">
            <summary></summary>
        </member>
        <member name="T:NHibernate.ADOException">
            <summary>
            Wraps exceptions that occur during ADO.NET calls.
            </summary>
            <remarks>
            Exceptions thrown by various ADO.NET providers are not derived from
            a common base class (<c>SQLException</c> in Java), so <c>Exception</c>
            is used instead in NHibernate.
            </remarks>
        </member>
        <member name="M:NHibernate.ADOException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ADOException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.ADOException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ADOException"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.AssertionFailure">
            <summary>
            Indicates failure of an assertion: a possible bug in NHibernate
            </summary>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.AssertionFailure.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.AssertionFailure"/> class.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.CallbackException">
            <summary></summary>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.CallbackException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.CallbackException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.CriteriaUtil">
            <summary>
            Contains static declarations from Criteria interface in Hibernate.
            </summary>
        </member>
        <member name="F:NHibernate.CriteriaUtil.RootAlias">
            <summary>
            The alias that refers to the "root" entity of the criteria query.
            </summary>
        </member>
        <member name="F:NHibernate.CriteriaUtil.AliasToEntityMap">
            <summary>
            Each row of results is an <c>IDictionary</c> from alias to entity instance
            </summary>
        </member>
        <member name="F:NHibernate.CriteriaUtil.RootEntity">
            <summary>
            Each row of results is an instance of the root entity
            </summary>
        </member>
        <member name="F:NHibernate.CriteriaUtil.DistinctRootEntity">
            <summary>
            Each row of results is a distinct instance of the root entity
            </summary>
        </member>
        <member name="T:NHibernate.FetchMode">
            <summary>
            Represents a fetching strategy.
            </summary>
            <remarks>
            This is used together with the <see cref="T:NHibernate.ICriteria"/> API to specify
            runtime fetching strategies.
            <para>
            For Hql queries, use the <c>FETCH</c> keyword instead.
            </para>
            </remarks>
        </member>
        <member name="F:NHibernate.FetchMode.Default">
            <summary>
            Default to the setting configured in the mapping file.
            </summary>
        </member>
        <member name="F:NHibernate.FetchMode.Select">
            <summary>
            Fetch eagerly, using a separate select. Equivalent to
            <c>fetch="select"</c> (and <c>outer-join="false"</c>)
            </summary>
        </member>
        <member name="F:NHibernate.FetchMode.Join">
            <summary>
            Fetch using an outer join.  Equivalent to
            <c>fetch="join"</c> (and <c>outer-join="true"</c>)
            </summary>
        </member>
        <member name="T:NHibernate.FlushMode">
            <summary>
            Represents a flushing strategy.
            </summary>
            <remarks>
            The flush process synchronizes database state with session state by detecting state
            changes and executing SQL statements
            </remarks>
        </member>
        <member name="F:NHibernate.FlushMode.Never">
            <summary>
            The <c>ISession</c> is never flushed unless <c>Flush()</c> is explicitly
            called by the application. This mode is very efficient for read only
            transactions
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Commit">
            <summary>
            The <c>ISession</c> is flushed when <c>Transaction.Commit()</c> is called
            </summary>
        </member>
        <member name="F:NHibernate.FlushMode.Auto">
            <summary>
            The <c>ISession</c> is sometimes flushed before query execution in order to
            ensure that queries never return stale state. This is the default flush mode.
            </summary>
        </member>
        <member name="T:NHibernate.ICompositeUserType">
            <summary>
            A UserType that may be dereferenced in a query.
            This interface allows a custom type to define "properties".
            These need not necessarily correspond to physical .NET style properties.
            
            A ICompositeUserType may be used in almost every way 
            that a component may be used. It may even contain many-to-one
            associations.
            
            Implementors must be immutable and must declare a public
            default constructor.
            
            Unlike UserType, cacheability does not depend upon
            serializability. Instead, Assemble() and 
            Disassemble() provide conversion to/from a cacheable
            representation.
            </summary>
        </member>
        <member name="M:NHibernate.ICompositeUserType.GetPropertyValue(System.Object,System.Int32)">
            <summary>
            Get the value of a property
            </summary>
            <param name="component">an instance of class mapped by this "type"</param>
            <param name="property"></param>
            <returns>the property value</returns>
        </member>
        <member name="M:NHibernate.ICompositeUserType.SetPropertyValue(System.Object,System.Int32,System.Object)">
            <summary>
            Set the value of a property
            </summary>
            <param name="component">an instance of class mapped by this "type"</param>
            <param name="property"></param>
            <param name="value">the value to set</param>
        </member>
        <member name="M:NHibernate.ICompositeUserType.Equals(System.Object,System.Object)">
            <summary>
            Compare two instances of the class mapped by this type for persistence
            "equality", ie. equality of persistent state.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICompositeUserType.NullSafeGet(System.Data.IDataReader,System.String[],NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Retrieve an instance of the mapped class from a IDataReader. Implementors
            should handle possibility of null values.
            </summary>
            <param name="dr">IDataReader</param>
            <param name="names">the column names</param>
            <param name="session"></param>
            <param name="owner">the containing entity</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICompositeUserType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Write an instance of the mapped class to a prepared statement.
            Implementors should handle possibility of null values.
            A multi-column type should be written to parameters starting from index.
            </summary>
            <param name="cmd"></param>
            <param name="value"></param>
            <param name="index"></param>
            <param name="session"></param>
        </member>
        <member name="M:NHibernate.ICompositeUserType.DeepCopy(System.Object)">
            <summary>
            Return a deep copy of the persistent state, stopping at entities and at collections.
            </summary>
            <param name="value">generally a collection element or entity field</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICompositeUserType.Disassemble(System.Object,NHibernate.Engine.ISessionImplementor)">
            <summary>
            Transform the object into its cacheable representation.
            At the very least this method should perform a deep copy.
            That may not be enough for some implementations, method should perform a deep copy. That may not be enough for some implementations, however; for example, associations must be cached as identifier values. (optional operation)
            </summary>
            <param name="value">the object to be cached</param>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ICompositeUserType.Assemble(System.Object,NHibernate.Engine.ISessionImplementor,System.Object)">
            <summary>
            Reconstruct an object from the cacheable representation.
            At the very least this method should perform a deep copy. (optional operation)
            </summary>
            <param name="cached">the object to be cached</param>
            <param name="session"></param>
            <param name="owner"></param>
            <returns></returns>
        </member>
        <member name="P:NHibernate.ICompositeUserType.PropertyNames">
            <summary>
            Get the "property names" that may be used in a query. 
            </summary>
        </member>
        <member name="P:NHibernate.ICompositeUserType.PropertyTypes">
            <summary>
            Get the corresponding "property types"
            </summary>
        </member>
        <member name="P:NHibernate.ICompositeUserType.ReturnedClass">
            <summary>
            The class returned by NullSafeGet().
            </summary>
        </member>
        <member name="P:NHibernate.ICompositeUserType.IsMutable">
            <summary>
            Are objects of this type mutable?
            </summary>
        </member>
        <member name="T:NHibernate.IDatabinder">
            <summary>
            Provides XML marshalling for classes registered with a <c>SessionFactory</c>
            </summary>
            <remarks>
            <para>
            Hibernate defines a generic XML format that may be used to represent any class
            (<c>hibernate-generic.dtd</c>). The user configures an XSLT stylesheet for marshalling
            data from this generic format to an application and/or user readable format. By default,
            Hibernate will use <c>hibernate-default.xslt</c> which maps data to a useful human-
            readable format.
            </para>
            <para>
            The property <c>hibernate.xml.output_stylesheet</c> specifies a user-written stylesheet.
            Hibernate will attempt to load the stylesheet from the classpath first and if not found,
            will attempt to load it as a file
            </para>
            <para>
            It is not intended that implementors be threadsafe
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IDatabinder.Bind(System.Object)">
            <summary>
            Add an object to the output document.
            </summary>
            <param name="obj">A transient or persistent instance</param>
            <returns>Databinder</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.BindAll(System.Collections.ICollection)">
            <summary>
            Add a collection of objects to the output document
            </summary>
            <param name="objs">A collection of transient or persistent instance</param>
            <returns>Databinder</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToGenericXml">
            <summary>
            Output the generic XML representation of the bound objects
            </summary>
            <returns>Generic Xml representation</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToGenericXmlDocument">
            <summary>
            Output the generic XML Representation of the bound objects
            to a <c>XmlDocument</c>
            </summary>
            <returns>A generic Xml tree</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToXML">
            <summary>
            Output the custom XML representation of the bound objects
            </summary>
            <returns>Custom Xml representation</returns>
        </member>
        <member name="M:NHibernate.IDatabinder.ToXmlDocument">
            <summary>
            Output the custom XML representation of the bound objects as
            an <c>XmlDocument</c>
            </summary>
            <returns>A custom Xml Tree</returns>
        </member>
        <member name="P:NHibernate.IDatabinder.InitializeLazy">
            <summary>
            Controls whether bound objects (and their associated objects) that are lazily instanciated
            are explicityl initialized or left as they are
            </summary>
            <value>True to explicitly initilize lazy objects, false to leave them in the state they are in</value>
        </member>
        <member name="T:NHibernate.ILifecycle">
            <summary>
            Provides callbacks from the <c>ISession</c> to the persistent object. Persistent classes may
            implement this interface but they are not required to.
            </summary>
            <remarks>
            <para>
            <c>OnSave()</c>, <c>OnDelete()</c>, and <c>OnUpdate()</c> are intended to be used to cascade
            saves and deletions of dependent objects. This is an alternative to declaring cascaded operations
            in the mapping file.
            </para>
            <para>
            <c>OnLoad()</c> may be used to initialize transient properties of the object from its persistent
            state. It may <b>not</b> be used to load dependent objects since the <c>ISession</c> interface
            may not be invoked from inside this method
            </para>
            <para>
            A further intended usage of <c>OnLoad()</c>, <c>OnSave()</c>, and <c>OnUpdate()</c> is to store
            a reference to the <c>ISession</c> for later use.
            </para>
            <para>
            If <c>OnSave()</c>, <c>OnUpdate()</c>, or <c>OnDelete</c> return <c>Veto</c>, the operation is
            silently vetoed. If a <c>CallbackException</c> is thrown, the operation is vetoed and the
            exception is passed back to the application
            </para>
            <para>
            Note that <c>OnSave()</c> is called after an identifier is assigned to the object, exception when
            native key generation is used.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.ILifecycle.OnSave(NHibernate.ISession)">
            <summary>
            Called when an entity is saved
            </summary>
            <param name="s">The session</param>
            <returns>If we should veto the save</returns>
        </member>
        <member name="M:NHibernate.ILifecycle.OnUpdate(NHibernate.ISession)">
            <summary>
            Called when an entity is passed to <c>ISession.Update()</c>.
            </summary>
            <remarks>
            This method is <em>not</em> called every time the object's state is
            persisted during a flush.
            </remarks>
            <param name="s">The session</param>
            <returns>If we should veto the update</returns>
        </member>
        <member name="M:NHibernate.ILifecycle.OnDelete(NHibernate.ISession)">
            <summary>
            Called when an entity is deleted
            </summary>
            <param name="s">The session</param>
            <returns>If we should veto the delete</returns>
        </member>
        <member name="M:NHibernate.ILifecycle.OnLoad(NHibernate.ISession,System.Object)">
            <summary>
            Called after an entity is loaded. 
            </summary>
            <remarks>
            <em>It is illegal to access the <c>ISession</c> from inside this method.</em>. 
            However, the object may keep a reference to the session for later use
            </remarks>
            <param name="s">The session</param>
            <param name="id">The identifier</param>
        </member>
        <member name="T:NHibernate.LifecycleVeto">
            <summary></summary>
        </member>
        <member name="F:NHibernate.LifecycleVeto.Veto">
            <summary>
            Veto the action
            </summary>
        </member>
        <member name="F:NHibernate.LifecycleVeto.NoVeto">
            <summary>
            Accept the action
            </summary>
        </member>
        <member name="T:NHibernate.InstantiationException">
            <summary>
            Thrown if Hibernate can't instantiate an entity or component class at runtime.
            </summary>
        </member>
        <member name="M:NHibernate.InstantiationException.#ctor(System.String,System.Exception,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.InstantiationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
            <param name="type">The <see cref="T:System.Type"/> that NHibernate was trying to instantiate.</param>
        </member>
        <member name="M:NHibernate.InstantiationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.InstantiationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.InstantiationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.InstantiationException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.InstantiationException.PersistentType">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was trying to instantiate.
            </summary>
        </member>
        <member name="P:NHibernate.InstantiationException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.InstantiationException"/>.
            </summary>
            <value>
            The error message that explains the reason for this exception and the Type that
            was trying to be instantiated.
            </value>
        </member>
        <member name="T:NHibernate.IUserType">
            <summary>
            The inteface to be implemented by user-defined types.
            </summary>
            <remarks>
            <para>
            The inteface abstracts user code from future changes to the <see cref="T:NHibernate.Type.IType"/> inteface,
            simplifies the implementation of custom types and hides certain "internal interfaces from
            user code.
            </para>
            <para>
            Implemenators must be immutable and must declare a public default constructor.
            </para>
            <para>
            The actual class mapped by a <c>IUserType</c> may be just about anything. However, if it is to
            be cacheble by a persistent cache, it must be serializable.
            </para>
            <para>
            Alternatively, custom types could implement <see cref="T:NHibernate.Type.IType"/> directly or extend one of the
            abstract classes in <c>NHibernate.Type</c>. This approach risks future incompatible changes
            to classes or intefaces in the package.
            </para>
            </remarks>
        </member>
        <member name="M:NHibernate.IUserType.Equals(System.Object,System.Object)">
            <summary>
            Compare two instances of the class mapped by this type for persistent "equality"
            ie. equality of persistent state
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.IUserType.NullSafeGet(System.Data.IDataReader,System.String[],System.Object)">
            <summary>
            Retrieve an instance of the mapped class from a JDBC resultset.
            Implementors should handle possibility of null values.
            </summary>
            <param name="rs">a IDataReader</param>
            <param name="names">column names</param>
            <param name="owner">the containing entity</param>
            <returns></returns>
            <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
        </member>
        <member name="M:NHibernate.IUserType.NullSafeSet(System.Data.IDbCommand,System.Object,System.Int32)">
            <summary>
            Write an instance of the mapped class to a prepared statement.
            Implementors should handle possibility of null values.
            A multi-column type should be written to parameters starting from index.
            </summary>
            <param name="cmd">a IDbCommand</param>
            <param name="value">the object to write</param>
            <param name="index">command parameter index</param>
            <exception cref="T:NHibernate.HibernateException">HibernateException</exception>
        </member>
        <member name="M:NHibernate.IUserType.DeepCopy(System.Object)">
            <summary>
            Return a deep copy of the persistent state, stopping at entities and at collections.
            </summary>
            <param name="value">generally a collection element or entity field</param>
            <returns>a copy</returns>
        </member>
        <member name="P:NHibernate.IUserType.SqlTypes">
            <summary>
            The SQL types for the columns mapped by this type. 
            </summary>
        </member>
        <member name="P:NHibernate.IUserType.ReturnedType">
            <summary>
            The type returned by <c>NullSafeGet()</c>
            </summary>
        </member>
        <member name="P:NHibernate.IUserType.IsMutable">
            <summary>
            Are objects of this type mutable?
            </summary>
        </member>
        <member name="T:NHibernate.IValidatable">
            <summary>
            Implemented by persistent classes with invariants that must be checked before inserting
            into or updating the database
            </summary>
        </member>
        <member name="M:NHibernate.IValidatable.Validate">
            <summary>
            Validate the state of the object before persisting it. If a violation occurs,
            throw a <c>ValidationFailure</c>. This method must not change the state of the object
            by side-effect.
            </summary>
        </member>
        <member name="T:NHibernate.LazyInitializationException">
            <summary>
            A problem occurred trying to lazily initialize a collection or proxy (for example the session
            was closed) or iterate query results.
            </summary>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.LazyInitializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.LazyInitializationException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.LockMode">
            <summary>
            Instances represent a lock mode for a row of a relational database table.
            </summary>
            <remarks>
            It is not intended that users spend much time worrying about locking since Hibernate
            usually obtains exactly the right lock level automatically. Some "advanced" users may
            wish to explicitly specify lock levels.
            </remarks>
        </member>
        <member name="M:NHibernate.LockMode.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <param name="name"></param>
        </member>
        <member name="M:NHibernate.LockMode.ToString">
            <summary></summary>
        </member>
        <member name="M:NHibernate.LockMode.GreaterThan(NHibernate.LockMode)">
            <summary>
            Is this lock mode more restrictive than the given lock mode?
            </summary>
            <param name="mode"></param>
        </member>
        <member name="M:NHibernate.LockMode.LessThan(NHibernate.LockMode)">
            <summary>
            Is this lock mode less restrictive than the given lock mode?
            </summary>
            <param name="mode"></param>
        </member>
        <member name="F:NHibernate.LockMode.None">
            <summary>
            No lock required. 
            </summary>
            <remarks>
            If an object is requested with this lock mode, a <c>Read</c> lock
            might be obtained if necessary.
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Read">
            <summary>
            A shared lock. 
            </summary>
            <remarks>
            Objects are loaded in <c>Read</c> mode by default
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Upgrade">
            <summary>
            An upgrade lock. 
            </summary>
            <remarks>
            Objects loaded in this lock mode are materialized using an
            SQL <c>SELECT ... FOR UPDATE</c>
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.UpgradeNoWait">
            <summary>
            Attempty to obtain an upgrade lock, using an Oracle-style
            <c>SELECT ... FOR UPGRADE NOWAIT</c>. 
            </summary>
            <remarks>
            The semantics of this lock mode, once obtained, are the same as <c>Upgrade</c>
            </remarks>
        </member>
        <member name="F:NHibernate.LockMode.Write">
            <summary>
            A <c>Write</c> lock is obtained when an object is updated or inserted.
            </summary>
            <remarks>
            This is not a valid mode for <c>Load()</c> or <c>Lock()</c>.
            </remarks>
        </member>
        <member name="T:NHibernate.MappingException">
            <summary>
            An exception that usually occurs at configuration time, rather than runtime, as a result of
            something screwy in the O-R mappings
            </summary>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.MappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.MappingException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.NHibernateUtil">
            <summary>
            Provides access to the full range of NHibernate built-in types.
            IType instances may be used to bind values to query parameters.
            Also a factory for new Blobs and Clobs.
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.AnsiString">
            <summary>
            NHibernate Ansi String type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Binary">
            <summary>
            NHibernate binary type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.BinaryBlob">
            <summary>
            NHibernate binary blob type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Boolean">
            <summary>
            NHibernate boolean type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Byte">
            <summary>
            NHibernate byte type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Character">
            <summary>
            NHibernate character type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.CultureInfo">
            <summary>
            NHibernate Culture Info type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.DateTime">
            <summary>
            NHibernate date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Date">
            <summary>
            NHibernate date type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Decimal">
            <summary>
            NHibernate decimal type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Double">
            <summary>
            NHibernate double type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Guid">
            <summary>
            NHibernate Guid type.
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int16">
            <summary>
            NHibernate System.Int16 (short in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int32">
            <summary>
            NHibernate System.Int32 (int in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Int64">
            <summary>
            NHibernate System.Int64 (long in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.SByte">
            <summary>
            NHibernate System.SByte type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt16">
            <summary>
            NHibernate System.UInt16 (ushort in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt32">
            <summary>
            NHibernate System.UInt32 (uint in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.UInt64">
            <summary>
            NHibernate System.UInt64 (ulong in C#) type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Single">
            <summary>
            NHIbernate System.Single (float in C#) Type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.String">
            <summary>
            NHibernate String type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.StringClob">
            <summary>
            NHibernate string clob type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Time">
            <summary>
            NHibernate Time type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Ticks">
            <summary>
            NHibernate Ticks type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.TimeSpan">
            <summary>
            NHibernate Ticks type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Timestamp">
            <summary>
            NHibernate Timestamp type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.TrueFalse">
            <summary>
            NHibernate TrueFalse type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.YesNo">
            <summary>
            NHibernate YesNo type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Class">
            <summary>
            NHibernate class type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Serializable">
            <summary>
            NHibernate serializable type
            </summary>
        </member>
        <member name="F:NHibernate.NHibernateUtil.Object">
            <summary>
            NHibernate System.Object type
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.#ctor">
            <summary>
            Cannot be instantiated.
            </summary>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Enum(System.Type)">
            <summary>
            A NHibernate persistent enum type
            </summary>
            <param name="enumClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.GetSerializable(System.Type)">
            <summary>
            A NHibernate serializable type
            </summary>
            <param name="serializableClass"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Any(NHibernate.Type.IType,NHibernate.Type.IType)">
            <summary>
            A NHibernate serializable type
            </summary>
            <param name="metaType">a type mapping <see cref="T:NHibernate.Type.IType"/> to a single column</param>
            <param name="identifierType">the entity identifier type</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Association(System.Type)">
            <summary>
            A NHibernate persistent object (entity) type
            </summary>
            <param name="persistentClass">a mapped entity class</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Entity(System.Type)">
            <summary>
            A NHibernate persistent object (entity) type
            </summary>
            <param name="persistentClass">a mapped entity class</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Custom(System.Type)">
            <summary>
            A NHibernate custom type
            </summary>
            <param name="userTypeClass">a class that implements UserType</param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.Initialize(System.Object)">
            <summary>
            Force initialization of a proxy or persistent collection.
            </summary>
            <param name="proxy">a persistable object, proxy, persistent collection or null</param>
            <exception cref="T:NHibernate.HibernateException">if we can't initialize the proxy at this time, eg. the Session was closed</exception>
        </member>
        <member name="M:NHibernate.NHibernateUtil.IsInitialized(System.Object)">
            <summary>
            Is the proxy or persistent collection initialized?
            </summary>
            <param name="proxy">a persistable object, proxy, persistent collection or null</param>
            <returns>true if the argument is already initialized, or is not a proxy or collection</returns>
        </member>
        <member name="M:NHibernate.NHibernateUtil.GetClass(System.Object)">
            <summary>
            Get the true, underlying class of a proxied persistent class. This operation
            will initialize a proxy by side-effect.
            </summary>
            <param name="proxy">a persistable object or proxy</param>
            <returns>the true class of the instance</returns>
        </member>
        <member name="T:NHibernate.NonUniqueObjectException">
            <summary>
            This exception is thrown when an operation would
            break session-scoped identity. This occurs if the
            user tries to associate two different instances of
            the same class with a particular identifier,
            in the scope of a single <see cref="T:NHibernate.ISession"/>.
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="id">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
            <param name="id">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueObjectException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueObjectException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.InstantiationException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.NonUniqueResultException">
            <summary>
            Thrown when the application calls <see cref="M:NHibernate.IQuery.UniqueResult">IQuery.UniqueResult()</see> 
            and the query returned more than one result. Unlike all other NHibernate 
            exceptions, this one is recoverable!
            </summary>
        </member>
        <member name="M:NHibernate.NonUniqueResultException.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueResultException"/> class.
            </summary>
            <param name="resultCount">The number of items in the result.</param>
        </member>
        <member name="M:NHibernate.NonUniqueResultException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.NonUniqueResultException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ObjectDeletedException">
            <summary>
            Thrown when the user tries to pass a deleted object to the <c>ISession</c>.
            </summary>
        </member>
        <member name="T:NHibernate.UnresolvableObjectException">
            <summary>
            Thrown when Hibernate could not resolve an object by id, especially when
            loading an association.
            </summary>
        </member>
        <member name="M:NHibernate.UnresolvableObjectException.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.UnresolvableObjectException"/> class.
            </summary>
            <param name="identifier">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.UnresolvableObjectException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.UnresolvableObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="identifier">The identifier of the object that caused the exception.</param>
            <param name="clazz">The <see cref="T:System.Type"/> of the object attempted to be loaded.</param>
        </member>
        <member name="M:NHibernate.ObjectDeletedException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectDeletedException"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.ObjectDeletedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectDeletedException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ObjectNotFoundException">
            <summary>
            Thrown when <c>ISession.Load()</c> fails to select a row with
            the given primary key (identifier value). This exception might not
            be thrown when <c>Load()</c> is called, even if there was no
            row on the database, because <c>Load()</c> returns a proxy if
            possible. Applications should use <c>ISession.Get()</c> to test if 
            a row exists in the database.
            </summary>
        </member>
        <member name="M:NHibernate.ObjectNotFoundException.#ctor(System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectNotFoundException"/> class.
            </summary>
            <param name="identifier">The identifier of the object that was attempting to be loaded.</param>
            <param name="type">The <see cref="T:System.Type"/> that NHibernate was trying to find a row for in the database.</param>
        </member>
        <member name="M:NHibernate.ObjectNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ObjectNotFoundException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.PersistentObjectException">
            <summary>
            Thrown when the user passes a persistent instance to a <c>ISession</c> method that expects a
            transient instance
            </summary>
        </member>
        <member name="M:NHibernate.PersistentObjectException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PersistentObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.PersistentObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PersistentObjectException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.PropertyAccessException">
            <summary>
            A problem occurred accessing a property of an instance of a persistent class by reflection
            </summary>
        </member>
        <member name="M:NHibernate.PropertyAccessException.#ctor(System.Exception,System.String,System.Boolean,System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyAccessException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
            <param name="wasSetter">A <see cref="T:System.Boolean"/> indicating if this was a "setter" operation.</param>
            <param name="persistentType">The <see cref="T:System.Type"/> that NHibernate was trying find the Property or Field in.</param>
            <param name="propertyName">The mapped property name that was trying to be accessed.</param>
        </member>
        <member name="M:NHibernate.PropertyAccessException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyAccessException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyAccessException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.PropertyAccessException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.PropertyAccessException.PersistentType">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was trying find the Property or Field in.
            </summary>
        </member>
        <member name="P:NHibernate.PropertyAccessException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.PropertyAccessException"/>.
            </summary>
            <value>
            The error message that explains the reason for this exception and 
            information about the mapped property and its usage.
            </value>
        </member>
        <member name="T:NHibernate.PropertyNotFoundException">
            <summary>
            Indicates that an expected getter or setter method could not be found on a class
            </summary>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Type,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class,
            used when a property get/set accessor is missing.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> that is missing the property</param>
            <param name="propertyName">The name of the missing property</param>
            <param name="accessorType">The type of the missing accessor
            ("getter" or "setter")</param>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class,
            used when a field is missing.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> that is missing the field</param>
            <param name="fieldName">The name of the missing property</param>
        </member>
        <member name="M:NHibernate.PropertyNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyNotFoundException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyValueException.#ctor(System.String,System.Type,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyValueException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="persistentClass">The <see cref="T:System.Type"/> that NHibernate was trying to access.</param>
            <param name="propertyName">The name of the Property that was being get/set.</param>
        </member>
        <member name="M:NHibernate.PropertyValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.PropertyValueException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.PropertyValueException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.PropertyValueException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.QueryException">
            <summary>
            A problem occurred translating a Hibernate query to SQL due to invalid query syntax, etc.
            </summary>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="queryString">The query that contains the error.</param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.QueryException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.QueryException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.QueryException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.QueryException.QueryString">
            <summary>
            Gets or sets the <see cref="T:System.String"/> of HQL that caused the Exception.
            </summary>
        </member>
        <member name="P:NHibernate.QueryException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.QueryException"/>.
            </summary>
            <value>The error message that explains the reason for this exception including the HQL.</value>
        </member>
        <member name="T:NHibernate.ReplicationMode">
            <summary>
            Represents a replication strategy
            </summary>
        </member>
        <member name="M:NHibernate.ReplicationMode.#ctor(System.Int32,System.String)">
            <summary>
            
            </summary>
            <param name="level"></param>
            <param name="name"></param>
        </member>
        <member name="M:NHibernate.ReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="F:NHibernate.ReplicationMode.Exception">
            <summary></summary>
        </member>
        <member name="F:NHibernate.ReplicationMode.Ignore">
            <summary></summary>
        </member>
        <member name="F:NHibernate.ReplicationMode.Overwrite">
            <summary></summary>
        </member>
        <member name="F:NHibernate.ReplicationMode.LatestVersion">
            <summary></summary>
        </member>
        <member name="M:NHibernate.ReplicationMode.ExceptionReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Throw an exception when a row already exists
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ReplicationMode.IgnoreReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Ignore replicated entities when a row already exists
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ReplicationMode.OverwriteReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            Overwrite existing rows when a row already exists
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="M:NHibernate.ReplicationMode.LatestVersionReplicationMode.ShouldOverwriteCurrentVersion(System.Object,System.Object,System.Object,NHibernate.Type.IVersionType)">
            <summary>
            When a row already exists, choose the latest version
            </summary>
            <param name="entity"></param>
            <param name="currentVersion"></param>
            <param name="newVersion"></param>
            <param name="versionType"></param>
            <returns></returns>
        </member>
        <member name="T:NHibernate.StaleObjectStateException">
            <summary>
            Thrown when a version number check failed, indicating that the 
            <see cref="T:NHibernate.ISession"/> contained stale data (when using long transactions with
            versioning).
            </summary>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.#ctor(System.Type,System.Object)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.StaleObjectStateException"/> class.
            </summary>
            <param name="persistentType">The <see cref="T:System.Type"/> that NHibernate was trying to update in the database.</param>
            <param name="identifier">The identifier of the object that is stale.</param>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.StaleObjectStateException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.StaleObjectStateException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.StaleObjectStateException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.PersistentType">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was trying to update in the database.
            </summary>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.Identifier">
            <summary>
            Gets the identifier of the object that is stale.
            </summary>
        </member>
        <member name="P:NHibernate.StaleObjectStateException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.StaleObjectStateException"/>.
            </summary>
            <value>The error message that explains the reason for this exception.</value>
        </member>
        <member name="T:NHibernate.TransactionException">
            <summary>
            Indicated that a transaction could not be begun, committed, or rolled back
            </summary>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.TransactionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransactionException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.TransientObjectException">
            <summary>
            Throw when the user passes a transient instance to a <c>ISession</c> method that expects
            a persistent instance
            </summary>
        </member>
        <member name="M:NHibernate.TransientObjectException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransientObjectException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.TransientObjectException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.TransientObjectException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.ValidationFailure">
            <summary>
            Thrown from <c>IValidatable.Validate()</c> when an invariant was violated. Some applications
            might subclass this exception in order to provide more information about the violation
            </summary>
        </member>
        <member name="M:NHibernate.ValidationFailure.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ValidationFailure"/> class.
            </summary>
        </member>
        <member name="M:NHibernate.ValidationFailure.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ValidationFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:NHibernate.ValidationFailure.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ValidationFailure"/> class.
            </summary>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.ValidationFailure.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ValidationFailure"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="innerException">
            The exception that is the cause of the current exception. If the innerException parameter 
            is not a null reference, the current exception is raised in a catch block that handles 
            the inner exception.
            </param>
        </member>
        <member name="M:NHibernate.ValidationFailure.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.ValidationFailure"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="T:NHibernate.WrongClassException">
            <summary>
            Thrown when <c>ISession.Load()</c> selects a row with the given primary key (identifier value)
            but the row's discriminator value specifies a different subclass from the one requested
            </summary>
        </member>
        <member name="M:NHibernate.WrongClassException.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.WrongClassException"/> class.
            </summary>
            <param name="message">The message that describes the error. </param>
            <param name="identifier">The identifier of the object that was being loaded.</param>
            <param name="type">The <see cref="T:System.Type"/> that NHibernate was told to load.</param>
        </member>
        <member name="M:NHibernate.WrongClassException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:NHibernate.WrongClassException"/> class
            with serialized data.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="M:NHibernate.WrongClassException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Sets the serialization info for <see cref="T:NHibernate.WrongClassException"/> after 
            getting the info from the base Exception.
            </summary>
            <param name="info">
            The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object 
            data about the exception being thrown.
            </param>
            <param name="context">
            The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.
            </param>
        </member>
        <member name="P:NHibernate.WrongClassException.Identifier">
            <summary>
            Gets the identifier of the object that was being loaded.
            </summary>
        </member>
        <member name="P:NHibernate.WrongClassException.Type">
            <summary>
            Gets the <see cref="T:System.Type"/> that NHibernate was told to load.
            </summary>
        </member>
        <member name="P:NHibernate.WrongClassException.Message">
            <summary>
            Gets a message that describes the current <see cref="T:NHibernate.WrongClassException"/>.
            </summary>
            <value>The error message that explains the reason for this exception.</value>
        </member>
    </members>
</doc>
